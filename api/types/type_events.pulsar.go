// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package types

import (
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	common "github.com/mapprotocol/compass-tss/api/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_PoolMod           protoreflect.MessageDescriptor
	fd_PoolMod_asset     protoreflect.FieldDescriptor
	fd_PoolMod_rune_amt  protoreflect.FieldDescriptor
	fd_PoolMod_rune_add  protoreflect.FieldDescriptor
	fd_PoolMod_asset_amt protoreflect.FieldDescriptor
	fd_PoolMod_asset_add protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_PoolMod = File_types_type_events_proto.Messages().ByName("PoolMod")
	fd_PoolMod_asset = md_PoolMod.Fields().ByName("asset")
	fd_PoolMod_rune_amt = md_PoolMod.Fields().ByName("rune_amt")
	fd_PoolMod_rune_add = md_PoolMod.Fields().ByName("rune_add")
	fd_PoolMod_asset_amt = md_PoolMod.Fields().ByName("asset_amt")
	fd_PoolMod_asset_add = md_PoolMod.Fields().ByName("asset_add")
}

var _ protoreflect.Message = (*fastReflection_PoolMod)(nil)

type fastReflection_PoolMod PoolMod

func (x *PoolMod) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolMod)(x)
}

func (x *PoolMod) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolMod_messageType fastReflection_PoolMod_messageType
var _ protoreflect.MessageType = fastReflection_PoolMod_messageType{}

type fastReflection_PoolMod_messageType struct{}

func (x fastReflection_PoolMod_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolMod)(nil)
}
func (x fastReflection_PoolMod_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolMod)
}
func (x fastReflection_PoolMod_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolMod
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolMod) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolMod
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolMod) Type() protoreflect.MessageType {
	return _fastReflection_PoolMod_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolMod) New() protoreflect.Message {
	return new(fastReflection_PoolMod)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolMod) Interface() protoreflect.ProtoMessage {
	return (*PoolMod)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolMod) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_PoolMod_asset, value) {
			return
		}
	}
	if x.RuneAmt != "" {
		value := protoreflect.ValueOfString(x.RuneAmt)
		if !f(fd_PoolMod_rune_amt, value) {
			return
		}
	}
	if x.RuneAdd != false {
		value := protoreflect.ValueOfBool(x.RuneAdd)
		if !f(fd_PoolMod_rune_add, value) {
			return
		}
	}
	if x.AssetAmt != "" {
		value := protoreflect.ValueOfString(x.AssetAmt)
		if !f(fd_PoolMod_asset_amt, value) {
			return
		}
	}
	if x.AssetAdd != false {
		value := protoreflect.ValueOfBool(x.AssetAdd)
		if !f(fd_PoolMod_asset_add, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolMod) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.PoolMod.asset":
		return x.Asset != nil
	case "types.PoolMod.rune_amt":
		return x.RuneAmt != ""
	case "types.PoolMod.rune_add":
		return x.RuneAdd != false
	case "types.PoolMod.asset_amt":
		return x.AssetAmt != ""
	case "types.PoolMod.asset_add":
		return x.AssetAdd != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolMod) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.PoolMod.asset":
		x.Asset = nil
	case "types.PoolMod.rune_amt":
		x.RuneAmt = ""
	case "types.PoolMod.rune_add":
		x.RuneAdd = false
	case "types.PoolMod.asset_amt":
		x.AssetAmt = ""
	case "types.PoolMod.asset_add":
		x.AssetAdd = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolMod) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.PoolMod.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.PoolMod.rune_amt":
		value := x.RuneAmt
		return protoreflect.ValueOfString(value)
	case "types.PoolMod.rune_add":
		value := x.RuneAdd
		return protoreflect.ValueOfBool(value)
	case "types.PoolMod.asset_amt":
		value := x.AssetAmt
		return protoreflect.ValueOfString(value)
	case "types.PoolMod.asset_add":
		value := x.AssetAdd
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolMod) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.PoolMod.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.PoolMod.rune_amt":
		x.RuneAmt = value.Interface().(string)
	case "types.PoolMod.rune_add":
		x.RuneAdd = value.Bool()
	case "types.PoolMod.asset_amt":
		x.AssetAmt = value.Interface().(string)
	case "types.PoolMod.asset_add":
		x.AssetAdd = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolMod) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.PoolMod.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.PoolMod.rune_amt":
		panic(fmt.Errorf("field rune_amt of message types.PoolMod is not mutable"))
	case "types.PoolMod.rune_add":
		panic(fmt.Errorf("field rune_add of message types.PoolMod is not mutable"))
	case "types.PoolMod.asset_amt":
		panic(fmt.Errorf("field asset_amt of message types.PoolMod is not mutable"))
	case "types.PoolMod.asset_add":
		panic(fmt.Errorf("field asset_add of message types.PoolMod is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolMod) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.PoolMod.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.PoolMod.rune_amt":
		return protoreflect.ValueOfString("")
	case "types.PoolMod.rune_add":
		return protoreflect.ValueOfBool(false)
	case "types.PoolMod.asset_amt":
		return protoreflect.ValueOfString("")
	case "types.PoolMod.asset_add":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolMod"))
		}
		panic(fmt.Errorf("message types.PoolMod does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolMod) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.PoolMod", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolMod) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolMod) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolMod) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolMod) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolMod)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RuneAdd {
			n += 2
		}
		l = len(x.AssetAmt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AssetAdd {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolMod)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.AssetAdd {
			i--
			if x.AssetAdd {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.AssetAmt) > 0 {
			i -= len(x.AssetAmt)
			copy(dAtA[i:], x.AssetAmt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAmt)))
			i--
			dAtA[i] = 0x22
		}
		if x.RuneAdd {
			i--
			if x.RuneAdd {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.RuneAmt) > 0 {
			i -= len(x.RuneAmt)
			copy(dAtA[i:], x.RuneAmt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmt)))
			i--
			dAtA[i] = 0x12
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolMod)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolMod: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolMod: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAdd", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.RuneAdd = bool(v != 0)
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAmt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAdd", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.AssetAdd = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventLimitOrder        protoreflect.MessageDescriptor
	fd_EventLimitOrder_source protoreflect.FieldDescriptor
	fd_EventLimitOrder_target protoreflect.FieldDescriptor
	fd_EventLimitOrder_tx_id  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventLimitOrder = File_types_type_events_proto.Messages().ByName("EventLimitOrder")
	fd_EventLimitOrder_source = md_EventLimitOrder.Fields().ByName("source")
	fd_EventLimitOrder_target = md_EventLimitOrder.Fields().ByName("target")
	fd_EventLimitOrder_tx_id = md_EventLimitOrder.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventLimitOrder)(nil)

type fastReflection_EventLimitOrder EventLimitOrder

func (x *EventLimitOrder) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventLimitOrder)(x)
}

func (x *EventLimitOrder) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventLimitOrder_messageType fastReflection_EventLimitOrder_messageType
var _ protoreflect.MessageType = fastReflection_EventLimitOrder_messageType{}

type fastReflection_EventLimitOrder_messageType struct{}

func (x fastReflection_EventLimitOrder_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventLimitOrder)(nil)
}
func (x fastReflection_EventLimitOrder_messageType) New() protoreflect.Message {
	return new(fastReflection_EventLimitOrder)
}
func (x fastReflection_EventLimitOrder_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLimitOrder
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventLimitOrder) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLimitOrder
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventLimitOrder) Type() protoreflect.MessageType {
	return _fastReflection_EventLimitOrder_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventLimitOrder) New() protoreflect.Message {
	return new(fastReflection_EventLimitOrder)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventLimitOrder) Interface() protoreflect.ProtoMessage {
	return (*EventLimitOrder)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventLimitOrder) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Source != nil {
		value := protoreflect.ValueOfMessage(x.Source.ProtoReflect())
		if !f(fd_EventLimitOrder_source, value) {
			return
		}
	}
	if x.Target != nil {
		value := protoreflect.ValueOfMessage(x.Target.ProtoReflect())
		if !f(fd_EventLimitOrder_target, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventLimitOrder_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventLimitOrder) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventLimitOrder.source":
		return x.Source != nil
	case "types.EventLimitOrder.target":
		return x.Target != nil
	case "types.EventLimitOrder.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLimitOrder) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventLimitOrder.source":
		x.Source = nil
	case "types.EventLimitOrder.target":
		x.Target = nil
	case "types.EventLimitOrder.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventLimitOrder) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventLimitOrder.source":
		value := x.Source
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventLimitOrder.target":
		value := x.Target
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventLimitOrder.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLimitOrder) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventLimitOrder.source":
		x.Source = value.Message().Interface().(*common.Coin)
	case "types.EventLimitOrder.target":
		x.Target = value.Message().Interface().(*common.Coin)
	case "types.EventLimitOrder.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLimitOrder) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLimitOrder.source":
		if x.Source == nil {
			x.Source = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.Source.ProtoReflect())
	case "types.EventLimitOrder.target":
		if x.Target == nil {
			x.Target = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.Target.ProtoReflect())
	case "types.EventLimitOrder.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventLimitOrder is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventLimitOrder) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLimitOrder.source":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventLimitOrder.target":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventLimitOrder.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLimitOrder"))
		}
		panic(fmt.Errorf("message types.EventLimitOrder does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventLimitOrder) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventLimitOrder", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventLimitOrder) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLimitOrder) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventLimitOrder) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventLimitOrder) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventLimitOrder)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Source != nil {
			l = options.Size(x.Source)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Target != nil {
			l = options.Size(x.Target)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventLimitOrder)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Target != nil {
			encoded, err := options.Marshal(x.Target)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.Source != nil {
			encoded, err := options.Marshal(x.Source)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventLimitOrder)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLimitOrder: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLimitOrder: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Source == nil {
					x.Source = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Source); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Target == nil {
					x.Target = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Target); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventStreamingSwap_10_list)(nil)

type _EventStreamingSwap_10_list struct {
	list *[]uint64
}

func (x *_EventStreamingSwap_10_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventStreamingSwap_10_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfUint64((*x.list)[i])
}

func (x *_EventStreamingSwap_10_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventStreamingSwap_10_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Uint()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventStreamingSwap_10_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventStreamingSwap at list field FailedSwaps as it is not of Message kind"))
}

func (x *_EventStreamingSwap_10_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventStreamingSwap_10_list) NewElement() protoreflect.Value {
	v := uint64(0)
	return protoreflect.ValueOfUint64(v)
}

func (x *_EventStreamingSwap_10_list) IsValid() bool {
	return x.list != nil
}

var _ protoreflect.List = (*_EventStreamingSwap_11_list)(nil)

type _EventStreamingSwap_11_list struct {
	list *[]string
}

func (x *_EventStreamingSwap_11_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventStreamingSwap_11_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_EventStreamingSwap_11_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventStreamingSwap_11_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventStreamingSwap_11_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventStreamingSwap at list field FailedSwapReasons as it is not of Message kind"))
}

func (x *_EventStreamingSwap_11_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventStreamingSwap_11_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_EventStreamingSwap_11_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventStreamingSwap                     protoreflect.MessageDescriptor
	fd_EventStreamingSwap_tx_id               protoreflect.FieldDescriptor
	fd_EventStreamingSwap_interval            protoreflect.FieldDescriptor
	fd_EventStreamingSwap_quantity            protoreflect.FieldDescriptor
	fd_EventStreamingSwap_count               protoreflect.FieldDescriptor
	fd_EventStreamingSwap_last_height         protoreflect.FieldDescriptor
	fd_EventStreamingSwap_trade_target        protoreflect.FieldDescriptor
	fd_EventStreamingSwap_deposit             protoreflect.FieldDescriptor
	fd_EventStreamingSwap_in                  protoreflect.FieldDescriptor
	fd_EventStreamingSwap_out                 protoreflect.FieldDescriptor
	fd_EventStreamingSwap_failed_swaps        protoreflect.FieldDescriptor
	fd_EventStreamingSwap_failed_swap_reasons protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventStreamingSwap = File_types_type_events_proto.Messages().ByName("EventStreamingSwap")
	fd_EventStreamingSwap_tx_id = md_EventStreamingSwap.Fields().ByName("tx_id")
	fd_EventStreamingSwap_interval = md_EventStreamingSwap.Fields().ByName("interval")
	fd_EventStreamingSwap_quantity = md_EventStreamingSwap.Fields().ByName("quantity")
	fd_EventStreamingSwap_count = md_EventStreamingSwap.Fields().ByName("count")
	fd_EventStreamingSwap_last_height = md_EventStreamingSwap.Fields().ByName("last_height")
	fd_EventStreamingSwap_trade_target = md_EventStreamingSwap.Fields().ByName("trade_target")
	fd_EventStreamingSwap_deposit = md_EventStreamingSwap.Fields().ByName("deposit")
	fd_EventStreamingSwap_in = md_EventStreamingSwap.Fields().ByName("in")
	fd_EventStreamingSwap_out = md_EventStreamingSwap.Fields().ByName("out")
	fd_EventStreamingSwap_failed_swaps = md_EventStreamingSwap.Fields().ByName("failed_swaps")
	fd_EventStreamingSwap_failed_swap_reasons = md_EventStreamingSwap.Fields().ByName("failed_swap_reasons")
}

var _ protoreflect.Message = (*fastReflection_EventStreamingSwap)(nil)

type fastReflection_EventStreamingSwap EventStreamingSwap

func (x *EventStreamingSwap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventStreamingSwap)(x)
}

func (x *EventStreamingSwap) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventStreamingSwap_messageType fastReflection_EventStreamingSwap_messageType
var _ protoreflect.MessageType = fastReflection_EventStreamingSwap_messageType{}

type fastReflection_EventStreamingSwap_messageType struct{}

func (x fastReflection_EventStreamingSwap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventStreamingSwap)(nil)
}
func (x fastReflection_EventStreamingSwap_messageType) New() protoreflect.Message {
	return new(fastReflection_EventStreamingSwap)
}
func (x fastReflection_EventStreamingSwap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventStreamingSwap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventStreamingSwap) Descriptor() protoreflect.MessageDescriptor {
	return md_EventStreamingSwap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventStreamingSwap) Type() protoreflect.MessageType {
	return _fastReflection_EventStreamingSwap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventStreamingSwap) New() protoreflect.Message {
	return new(fastReflection_EventStreamingSwap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventStreamingSwap) Interface() protoreflect.ProtoMessage {
	return (*EventStreamingSwap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventStreamingSwap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventStreamingSwap_tx_id, value) {
			return
		}
	}
	if x.Interval != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Interval)
		if !f(fd_EventStreamingSwap_interval, value) {
			return
		}
	}
	if x.Quantity != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Quantity)
		if !f(fd_EventStreamingSwap_quantity, value) {
			return
		}
	}
	if x.Count != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Count)
		if !f(fd_EventStreamingSwap_count, value) {
			return
		}
	}
	if x.LastHeight != int64(0) {
		value := protoreflect.ValueOfInt64(x.LastHeight)
		if !f(fd_EventStreamingSwap_last_height, value) {
			return
		}
	}
	if x.TradeTarget != "" {
		value := protoreflect.ValueOfString(x.TradeTarget)
		if !f(fd_EventStreamingSwap_trade_target, value) {
			return
		}
	}
	if x.Deposit != nil {
		value := protoreflect.ValueOfMessage(x.Deposit.ProtoReflect())
		if !f(fd_EventStreamingSwap_deposit, value) {
			return
		}
	}
	if x.In != nil {
		value := protoreflect.ValueOfMessage(x.In.ProtoReflect())
		if !f(fd_EventStreamingSwap_in, value) {
			return
		}
	}
	if x.Out != nil {
		value := protoreflect.ValueOfMessage(x.Out.ProtoReflect())
		if !f(fd_EventStreamingSwap_out, value) {
			return
		}
	}
	if len(x.FailedSwaps) != 0 {
		value := protoreflect.ValueOfList(&_EventStreamingSwap_10_list{list: &x.FailedSwaps})
		if !f(fd_EventStreamingSwap_failed_swaps, value) {
			return
		}
	}
	if len(x.FailedSwapReasons) != 0 {
		value := protoreflect.ValueOfList(&_EventStreamingSwap_11_list{list: &x.FailedSwapReasons})
		if !f(fd_EventStreamingSwap_failed_swap_reasons, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventStreamingSwap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventStreamingSwap.tx_id":
		return x.TxId != ""
	case "types.EventStreamingSwap.interval":
		return x.Interval != uint64(0)
	case "types.EventStreamingSwap.quantity":
		return x.Quantity != uint64(0)
	case "types.EventStreamingSwap.count":
		return x.Count != uint64(0)
	case "types.EventStreamingSwap.last_height":
		return x.LastHeight != int64(0)
	case "types.EventStreamingSwap.trade_target":
		return x.TradeTarget != ""
	case "types.EventStreamingSwap.deposit":
		return x.Deposit != nil
	case "types.EventStreamingSwap.in":
		return x.In != nil
	case "types.EventStreamingSwap.out":
		return x.Out != nil
	case "types.EventStreamingSwap.failed_swaps":
		return len(x.FailedSwaps) != 0
	case "types.EventStreamingSwap.failed_swap_reasons":
		return len(x.FailedSwapReasons) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventStreamingSwap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventStreamingSwap.tx_id":
		x.TxId = ""
	case "types.EventStreamingSwap.interval":
		x.Interval = uint64(0)
	case "types.EventStreamingSwap.quantity":
		x.Quantity = uint64(0)
	case "types.EventStreamingSwap.count":
		x.Count = uint64(0)
	case "types.EventStreamingSwap.last_height":
		x.LastHeight = int64(0)
	case "types.EventStreamingSwap.trade_target":
		x.TradeTarget = ""
	case "types.EventStreamingSwap.deposit":
		x.Deposit = nil
	case "types.EventStreamingSwap.in":
		x.In = nil
	case "types.EventStreamingSwap.out":
		x.Out = nil
	case "types.EventStreamingSwap.failed_swaps":
		x.FailedSwaps = nil
	case "types.EventStreamingSwap.failed_swap_reasons":
		x.FailedSwapReasons = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventStreamingSwap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventStreamingSwap.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventStreamingSwap.interval":
		value := x.Interval
		return protoreflect.ValueOfUint64(value)
	case "types.EventStreamingSwap.quantity":
		value := x.Quantity
		return protoreflect.ValueOfUint64(value)
	case "types.EventStreamingSwap.count":
		value := x.Count
		return protoreflect.ValueOfUint64(value)
	case "types.EventStreamingSwap.last_height":
		value := x.LastHeight
		return protoreflect.ValueOfInt64(value)
	case "types.EventStreamingSwap.trade_target":
		value := x.TradeTarget
		return protoreflect.ValueOfString(value)
	case "types.EventStreamingSwap.deposit":
		value := x.Deposit
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventStreamingSwap.in":
		value := x.In
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventStreamingSwap.out":
		value := x.Out
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventStreamingSwap.failed_swaps":
		if len(x.FailedSwaps) == 0 {
			return protoreflect.ValueOfList(&_EventStreamingSwap_10_list{})
		}
		listValue := &_EventStreamingSwap_10_list{list: &x.FailedSwaps}
		return protoreflect.ValueOfList(listValue)
	case "types.EventStreamingSwap.failed_swap_reasons":
		if len(x.FailedSwapReasons) == 0 {
			return protoreflect.ValueOfList(&_EventStreamingSwap_11_list{})
		}
		listValue := &_EventStreamingSwap_11_list{list: &x.FailedSwapReasons}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventStreamingSwap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventStreamingSwap.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventStreamingSwap.interval":
		x.Interval = value.Uint()
	case "types.EventStreamingSwap.quantity":
		x.Quantity = value.Uint()
	case "types.EventStreamingSwap.count":
		x.Count = value.Uint()
	case "types.EventStreamingSwap.last_height":
		x.LastHeight = value.Int()
	case "types.EventStreamingSwap.trade_target":
		x.TradeTarget = value.Interface().(string)
	case "types.EventStreamingSwap.deposit":
		x.Deposit = value.Message().Interface().(*common.Coin)
	case "types.EventStreamingSwap.in":
		x.In = value.Message().Interface().(*common.Coin)
	case "types.EventStreamingSwap.out":
		x.Out = value.Message().Interface().(*common.Coin)
	case "types.EventStreamingSwap.failed_swaps":
		lv := value.List()
		clv := lv.(*_EventStreamingSwap_10_list)
		x.FailedSwaps = *clv.list
	case "types.EventStreamingSwap.failed_swap_reasons":
		lv := value.List()
		clv := lv.(*_EventStreamingSwap_11_list)
		x.FailedSwapReasons = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventStreamingSwap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventStreamingSwap.deposit":
		if x.Deposit == nil {
			x.Deposit = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.Deposit.ProtoReflect())
	case "types.EventStreamingSwap.in":
		if x.In == nil {
			x.In = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.In.ProtoReflect())
	case "types.EventStreamingSwap.out":
		if x.Out == nil {
			x.Out = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.Out.ProtoReflect())
	case "types.EventStreamingSwap.failed_swaps":
		if x.FailedSwaps == nil {
			x.FailedSwaps = []uint64{}
		}
		value := &_EventStreamingSwap_10_list{list: &x.FailedSwaps}
		return protoreflect.ValueOfList(value)
	case "types.EventStreamingSwap.failed_swap_reasons":
		if x.FailedSwapReasons == nil {
			x.FailedSwapReasons = []string{}
		}
		value := &_EventStreamingSwap_11_list{list: &x.FailedSwapReasons}
		return protoreflect.ValueOfList(value)
	case "types.EventStreamingSwap.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventStreamingSwap is not mutable"))
	case "types.EventStreamingSwap.interval":
		panic(fmt.Errorf("field interval of message types.EventStreamingSwap is not mutable"))
	case "types.EventStreamingSwap.quantity":
		panic(fmt.Errorf("field quantity of message types.EventStreamingSwap is not mutable"))
	case "types.EventStreamingSwap.count":
		panic(fmt.Errorf("field count of message types.EventStreamingSwap is not mutable"))
	case "types.EventStreamingSwap.last_height":
		panic(fmt.Errorf("field last_height of message types.EventStreamingSwap is not mutable"))
	case "types.EventStreamingSwap.trade_target":
		panic(fmt.Errorf("field trade_target of message types.EventStreamingSwap is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventStreamingSwap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventStreamingSwap.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventStreamingSwap.interval":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventStreamingSwap.quantity":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventStreamingSwap.count":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventStreamingSwap.last_height":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventStreamingSwap.trade_target":
		return protoreflect.ValueOfString("")
	case "types.EventStreamingSwap.deposit":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventStreamingSwap.in":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventStreamingSwap.out":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventStreamingSwap.failed_swaps":
		list := []uint64{}
		return protoreflect.ValueOfList(&_EventStreamingSwap_10_list{list: &list})
	case "types.EventStreamingSwap.failed_swap_reasons":
		list := []string{}
		return protoreflect.ValueOfList(&_EventStreamingSwap_11_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventStreamingSwap"))
		}
		panic(fmt.Errorf("message types.EventStreamingSwap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventStreamingSwap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventStreamingSwap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventStreamingSwap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventStreamingSwap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventStreamingSwap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventStreamingSwap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventStreamingSwap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Interval != 0 {
			n += 1 + runtime.Sov(uint64(x.Interval))
		}
		if x.Quantity != 0 {
			n += 1 + runtime.Sov(uint64(x.Quantity))
		}
		if x.Count != 0 {
			n += 1 + runtime.Sov(uint64(x.Count))
		}
		if x.LastHeight != 0 {
			n += 1 + runtime.Sov(uint64(x.LastHeight))
		}
		l = len(x.TradeTarget)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Deposit != nil {
			l = options.Size(x.Deposit)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.In != nil {
			l = options.Size(x.In)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Out != nil {
			l = options.Size(x.Out)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.FailedSwaps) > 0 {
			l = 0
			for _, e := range x.FailedSwaps {
				l += runtime.Sov(uint64(e))
			}
			n += 1 + runtime.Sov(uint64(l)) + l
		}
		if len(x.FailedSwapReasons) > 0 {
			for _, s := range x.FailedSwapReasons {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventStreamingSwap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.FailedSwapReasons) > 0 {
			for iNdEx := len(x.FailedSwapReasons) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.FailedSwapReasons[iNdEx])
				copy(dAtA[i:], x.FailedSwapReasons[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FailedSwapReasons[iNdEx])))
				i--
				dAtA[i] = 0x5a
			}
		}
		if len(x.FailedSwaps) > 0 {
			var pksize2 int
			for _, num := range x.FailedSwaps {
				pksize2 += runtime.Sov(uint64(num))
			}
			i -= pksize2
			j1 := i
			for _, num := range x.FailedSwaps {
				for num >= 1<<7 {
					dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
					num >>= 7
					j1++
				}
				dAtA[j1] = uint8(num)
				j1++
			}
			i = runtime.EncodeVarint(dAtA, i, uint64(pksize2))
			i--
			dAtA[i] = 0x52
		}
		if x.Out != nil {
			encoded, err := options.Marshal(x.Out)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if x.In != nil {
			encoded, err := options.Marshal(x.In)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if x.Deposit != nil {
			encoded, err := options.Marshal(x.Deposit)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.TradeTarget) > 0 {
			i -= len(x.TradeTarget)
			copy(dAtA[i:], x.TradeTarget)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TradeTarget)))
			i--
			dAtA[i] = 0x32
		}
		if x.LastHeight != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.LastHeight))
			i--
			dAtA[i] = 0x28
		}
		if x.Count != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Count))
			i--
			dAtA[i] = 0x20
		}
		if x.Quantity != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Quantity))
			i--
			dAtA[i] = 0x18
		}
		if x.Interval != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Interval))
			i--
			dAtA[i] = 0x10
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventStreamingSwap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventStreamingSwap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventStreamingSwap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
				}
				x.Interval = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Interval |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
				}
				x.Quantity = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Quantity |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
				}
				x.Count = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Count |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
				}
				x.LastHeight = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.LastHeight |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TradeTarget", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TradeTarget = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Deposit == nil {
					x.Deposit = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Deposit); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.In == nil {
					x.In = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.In); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Out == nil {
					x.Out = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Out); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType == 0 {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					x.FailedSwaps = append(x.FailedSwaps, v)
				} else if wireType == 2 {
					var packedLen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						packedLen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if packedLen < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					postIndex := iNdEx + packedLen
					if postIndex < 0 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
					}
					if postIndex > l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					var elementCount int
					var count int
					for _, integer := range dAtA[iNdEx:postIndex] {
						if integer < 128 {
							count++
						}
					}
					elementCount = count
					if elementCount != 0 && len(x.FailedSwaps) == 0 {
						x.FailedSwaps = make([]uint64, 0, elementCount)
					}
					for iNdEx < postIndex {
						var v uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							v |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						x.FailedSwaps = append(x.FailedSwaps, v)
					}
				} else {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FailedSwaps", wireType)
				}
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FailedSwapReasons", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FailedSwapReasons = append(x.FailedSwapReasons, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSwap                         protoreflect.MessageDescriptor
	fd_EventSwap_pool                    protoreflect.FieldDescriptor
	fd_EventSwap_swap_target             protoreflect.FieldDescriptor
	fd_EventSwap_swap_slip               protoreflect.FieldDescriptor
	fd_EventSwap_liquidity_fee           protoreflect.FieldDescriptor
	fd_EventSwap_liquidity_fee_in_rune   protoreflect.FieldDescriptor
	fd_EventSwap_in_tx                   protoreflect.FieldDescriptor
	fd_EventSwap_out_txs                 protoreflect.FieldDescriptor
	fd_EventSwap_emit_asset              protoreflect.FieldDescriptor
	fd_EventSwap_synth_units             protoreflect.FieldDescriptor
	fd_EventSwap_streaming_swap_quantity protoreflect.FieldDescriptor
	fd_EventSwap_streaming_swap_count    protoreflect.FieldDescriptor
	fd_EventSwap_pool_slip               protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSwap = File_types_type_events_proto.Messages().ByName("EventSwap")
	fd_EventSwap_pool = md_EventSwap.Fields().ByName("pool")
	fd_EventSwap_swap_target = md_EventSwap.Fields().ByName("swap_target")
	fd_EventSwap_swap_slip = md_EventSwap.Fields().ByName("swap_slip")
	fd_EventSwap_liquidity_fee = md_EventSwap.Fields().ByName("liquidity_fee")
	fd_EventSwap_liquidity_fee_in_rune = md_EventSwap.Fields().ByName("liquidity_fee_in_rune")
	fd_EventSwap_in_tx = md_EventSwap.Fields().ByName("in_tx")
	fd_EventSwap_out_txs = md_EventSwap.Fields().ByName("out_txs")
	fd_EventSwap_emit_asset = md_EventSwap.Fields().ByName("emit_asset")
	fd_EventSwap_synth_units = md_EventSwap.Fields().ByName("synth_units")
	fd_EventSwap_streaming_swap_quantity = md_EventSwap.Fields().ByName("streaming_swap_quantity")
	fd_EventSwap_streaming_swap_count = md_EventSwap.Fields().ByName("streaming_swap_count")
	fd_EventSwap_pool_slip = md_EventSwap.Fields().ByName("pool_slip")
}

var _ protoreflect.Message = (*fastReflection_EventSwap)(nil)

type fastReflection_EventSwap EventSwap

func (x *EventSwap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSwap)(x)
}

func (x *EventSwap) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSwap_messageType fastReflection_EventSwap_messageType
var _ protoreflect.MessageType = fastReflection_EventSwap_messageType{}

type fastReflection_EventSwap_messageType struct{}

func (x fastReflection_EventSwap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSwap)(nil)
}
func (x fastReflection_EventSwap_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSwap)
}
func (x fastReflection_EventSwap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSwap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSwap) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSwap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSwap) Type() protoreflect.MessageType {
	return _fastReflection_EventSwap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSwap) New() protoreflect.Message {
	return new(fastReflection_EventSwap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSwap) Interface() protoreflect.ProtoMessage {
	return (*EventSwap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSwap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventSwap_pool, value) {
			return
		}
	}
	if x.SwapTarget != "" {
		value := protoreflect.ValueOfString(x.SwapTarget)
		if !f(fd_EventSwap_swap_target, value) {
			return
		}
	}
	if x.SwapSlip != "" {
		value := protoreflect.ValueOfString(x.SwapSlip)
		if !f(fd_EventSwap_swap_slip, value) {
			return
		}
	}
	if x.LiquidityFee != "" {
		value := protoreflect.ValueOfString(x.LiquidityFee)
		if !f(fd_EventSwap_liquidity_fee, value) {
			return
		}
	}
	if x.LiquidityFeeInRune != "" {
		value := protoreflect.ValueOfString(x.LiquidityFeeInRune)
		if !f(fd_EventSwap_liquidity_fee_in_rune, value) {
			return
		}
	}
	if x.InTx != nil {
		value := protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
		if !f(fd_EventSwap_in_tx, value) {
			return
		}
	}
	if x.OutTxs != nil {
		value := protoreflect.ValueOfMessage(x.OutTxs.ProtoReflect())
		if !f(fd_EventSwap_out_txs, value) {
			return
		}
	}
	if x.EmitAsset != nil {
		value := protoreflect.ValueOfMessage(x.EmitAsset.ProtoReflect())
		if !f(fd_EventSwap_emit_asset, value) {
			return
		}
	}
	if x.SynthUnits != "" {
		value := protoreflect.ValueOfString(x.SynthUnits)
		if !f(fd_EventSwap_synth_units, value) {
			return
		}
	}
	if x.StreamingSwapQuantity != uint64(0) {
		value := protoreflect.ValueOfUint64(x.StreamingSwapQuantity)
		if !f(fd_EventSwap_streaming_swap_quantity, value) {
			return
		}
	}
	if x.StreamingSwapCount != uint64(0) {
		value := protoreflect.ValueOfUint64(x.StreamingSwapCount)
		if !f(fd_EventSwap_streaming_swap_count, value) {
			return
		}
	}
	if x.PoolSlip != "" {
		value := protoreflect.ValueOfString(x.PoolSlip)
		if !f(fd_EventSwap_pool_slip, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSwap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSwap.pool":
		return x.Pool != nil
	case "types.EventSwap.swap_target":
		return x.SwapTarget != ""
	case "types.EventSwap.swap_slip":
		return x.SwapSlip != ""
	case "types.EventSwap.liquidity_fee":
		return x.LiquidityFee != ""
	case "types.EventSwap.liquidity_fee_in_rune":
		return x.LiquidityFeeInRune != ""
	case "types.EventSwap.in_tx":
		return x.InTx != nil
	case "types.EventSwap.out_txs":
		return x.OutTxs != nil
	case "types.EventSwap.emit_asset":
		return x.EmitAsset != nil
	case "types.EventSwap.synth_units":
		return x.SynthUnits != ""
	case "types.EventSwap.streaming_swap_quantity":
		return x.StreamingSwapQuantity != uint64(0)
	case "types.EventSwap.streaming_swap_count":
		return x.StreamingSwapCount != uint64(0)
	case "types.EventSwap.pool_slip":
		return x.PoolSlip != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSwap.pool":
		x.Pool = nil
	case "types.EventSwap.swap_target":
		x.SwapTarget = ""
	case "types.EventSwap.swap_slip":
		x.SwapSlip = ""
	case "types.EventSwap.liquidity_fee":
		x.LiquidityFee = ""
	case "types.EventSwap.liquidity_fee_in_rune":
		x.LiquidityFeeInRune = ""
	case "types.EventSwap.in_tx":
		x.InTx = nil
	case "types.EventSwap.out_txs":
		x.OutTxs = nil
	case "types.EventSwap.emit_asset":
		x.EmitAsset = nil
	case "types.EventSwap.synth_units":
		x.SynthUnits = ""
	case "types.EventSwap.streaming_swap_quantity":
		x.StreamingSwapQuantity = uint64(0)
	case "types.EventSwap.streaming_swap_count":
		x.StreamingSwapCount = uint64(0)
	case "types.EventSwap.pool_slip":
		x.PoolSlip = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSwap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSwap.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSwap.swap_target":
		value := x.SwapTarget
		return protoreflect.ValueOfString(value)
	case "types.EventSwap.swap_slip":
		value := x.SwapSlip
		return protoreflect.ValueOfString(value)
	case "types.EventSwap.liquidity_fee":
		value := x.LiquidityFee
		return protoreflect.ValueOfString(value)
	case "types.EventSwap.liquidity_fee_in_rune":
		value := x.LiquidityFeeInRune
		return protoreflect.ValueOfString(value)
	case "types.EventSwap.in_tx":
		value := x.InTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSwap.out_txs":
		value := x.OutTxs
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSwap.emit_asset":
		value := x.EmitAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSwap.synth_units":
		value := x.SynthUnits
		return protoreflect.ValueOfString(value)
	case "types.EventSwap.streaming_swap_quantity":
		value := x.StreamingSwapQuantity
		return protoreflect.ValueOfUint64(value)
	case "types.EventSwap.streaming_swap_count":
		value := x.StreamingSwapCount
		return protoreflect.ValueOfUint64(value)
	case "types.EventSwap.pool_slip":
		value := x.PoolSlip
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSwap.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventSwap.swap_target":
		x.SwapTarget = value.Interface().(string)
	case "types.EventSwap.swap_slip":
		x.SwapSlip = value.Interface().(string)
	case "types.EventSwap.liquidity_fee":
		x.LiquidityFee = value.Interface().(string)
	case "types.EventSwap.liquidity_fee_in_rune":
		x.LiquidityFeeInRune = value.Interface().(string)
	case "types.EventSwap.in_tx":
		x.InTx = value.Message().Interface().(*common.Tx)
	case "types.EventSwap.out_txs":
		x.OutTxs = value.Message().Interface().(*common.Tx)
	case "types.EventSwap.emit_asset":
		x.EmitAsset = value.Message().Interface().(*common.Coin)
	case "types.EventSwap.synth_units":
		x.SynthUnits = value.Interface().(string)
	case "types.EventSwap.streaming_swap_quantity":
		x.StreamingSwapQuantity = value.Uint()
	case "types.EventSwap.streaming_swap_count":
		x.StreamingSwapCount = value.Uint()
	case "types.EventSwap.pool_slip":
		x.PoolSlip = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSwap.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventSwap.in_tx":
		if x.InTx == nil {
			x.InTx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
	case "types.EventSwap.out_txs":
		if x.OutTxs == nil {
			x.OutTxs = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.OutTxs.ProtoReflect())
	case "types.EventSwap.emit_asset":
		if x.EmitAsset == nil {
			x.EmitAsset = new(common.Coin)
		}
		return protoreflect.ValueOfMessage(x.EmitAsset.ProtoReflect())
	case "types.EventSwap.swap_target":
		panic(fmt.Errorf("field swap_target of message types.EventSwap is not mutable"))
	case "types.EventSwap.swap_slip":
		panic(fmt.Errorf("field swap_slip of message types.EventSwap is not mutable"))
	case "types.EventSwap.liquidity_fee":
		panic(fmt.Errorf("field liquidity_fee of message types.EventSwap is not mutable"))
	case "types.EventSwap.liquidity_fee_in_rune":
		panic(fmt.Errorf("field liquidity_fee_in_rune of message types.EventSwap is not mutable"))
	case "types.EventSwap.synth_units":
		panic(fmt.Errorf("field synth_units of message types.EventSwap is not mutable"))
	case "types.EventSwap.streaming_swap_quantity":
		panic(fmt.Errorf("field streaming_swap_quantity of message types.EventSwap is not mutable"))
	case "types.EventSwap.streaming_swap_count":
		panic(fmt.Errorf("field streaming_swap_count of message types.EventSwap is not mutable"))
	case "types.EventSwap.pool_slip":
		panic(fmt.Errorf("field pool_slip of message types.EventSwap is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSwap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSwap.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSwap.swap_target":
		return protoreflect.ValueOfString("")
	case "types.EventSwap.swap_slip":
		return protoreflect.ValueOfString("")
	case "types.EventSwap.liquidity_fee":
		return protoreflect.ValueOfString("")
	case "types.EventSwap.liquidity_fee_in_rune":
		return protoreflect.ValueOfString("")
	case "types.EventSwap.in_tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSwap.out_txs":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSwap.emit_asset":
		m := new(common.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSwap.synth_units":
		return protoreflect.ValueOfString("")
	case "types.EventSwap.streaming_swap_quantity":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventSwap.streaming_swap_count":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventSwap.pool_slip":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwap"))
		}
		panic(fmt.Errorf("message types.EventSwap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSwap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSwap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSwap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSwap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSwap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSwap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SwapTarget)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SwapSlip)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LiquidityFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LiquidityFeeInRune)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InTx != nil {
			l = options.Size(x.InTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.OutTxs != nil {
			l = options.Size(x.OutTxs)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.EmitAsset != nil {
			l = options.Size(x.EmitAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SynthUnits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.StreamingSwapQuantity != 0 {
			n += 1 + runtime.Sov(uint64(x.StreamingSwapQuantity))
		}
		if x.StreamingSwapCount != 0 {
			n += 1 + runtime.Sov(uint64(x.StreamingSwapCount))
		}
		l = len(x.PoolSlip)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSwap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PoolSlip) > 0 {
			i -= len(x.PoolSlip)
			copy(dAtA[i:], x.PoolSlip)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PoolSlip)))
			i--
			dAtA[i] = 0x62
		}
		if x.StreamingSwapCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.StreamingSwapCount))
			i--
			dAtA[i] = 0x58
		}
		if x.StreamingSwapQuantity != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.StreamingSwapQuantity))
			i--
			dAtA[i] = 0x50
		}
		if len(x.SynthUnits) > 0 {
			i -= len(x.SynthUnits)
			copy(dAtA[i:], x.SynthUnits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SynthUnits)))
			i--
			dAtA[i] = 0x4a
		}
		if x.EmitAsset != nil {
			encoded, err := options.Marshal(x.EmitAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if x.OutTxs != nil {
			encoded, err := options.Marshal(x.OutTxs)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if x.InTx != nil {
			encoded, err := options.Marshal(x.InTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.LiquidityFeeInRune) > 0 {
			i -= len(x.LiquidityFeeInRune)
			copy(dAtA[i:], x.LiquidityFeeInRune)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LiquidityFeeInRune)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.LiquidityFee) > 0 {
			i -= len(x.LiquidityFee)
			copy(dAtA[i:], x.LiquidityFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LiquidityFee)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.SwapSlip) > 0 {
			i -= len(x.SwapSlip)
			copy(dAtA[i:], x.SwapSlip)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SwapSlip)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.SwapTarget) > 0 {
			i -= len(x.SwapTarget)
			copy(dAtA[i:], x.SwapTarget)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SwapTarget)))
			i--
			dAtA[i] = 0x12
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSwap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSwap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSwap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapTarget", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SwapTarget = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SwapSlip", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SwapSlip = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidityFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LiquidityFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LiquidityFeeInRune", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LiquidityFeeInRune = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InTx == nil {
					x.InTx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OutTxs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.OutTxs == nil {
					x.OutTxs = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OutTxs); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.EmitAsset == nil {
					x.EmitAsset = &common.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.EmitAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SynthUnits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 10:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapQuantity", wireType)
				}
				x.StreamingSwapQuantity = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.StreamingSwapQuantity |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 11:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field StreamingSwapCount", wireType)
				}
				x.StreamingSwapCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.StreamingSwapCount |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 12:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolSlip", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PoolSlip = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventAffiliateFee              protoreflect.MessageDescriptor
	fd_EventAffiliateFee_tx_id        protoreflect.FieldDescriptor
	fd_EventAffiliateFee_memo         protoreflect.FieldDescriptor
	fd_EventAffiliateFee_thorname     protoreflect.FieldDescriptor
	fd_EventAffiliateFee_rune_address protoreflect.FieldDescriptor
	fd_EventAffiliateFee_asset        protoreflect.FieldDescriptor
	fd_EventAffiliateFee_gross_amount protoreflect.FieldDescriptor
	fd_EventAffiliateFee_fee_bps      protoreflect.FieldDescriptor
	fd_EventAffiliateFee_fee_amount   protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventAffiliateFee = File_types_type_events_proto.Messages().ByName("EventAffiliateFee")
	fd_EventAffiliateFee_tx_id = md_EventAffiliateFee.Fields().ByName("tx_id")
	fd_EventAffiliateFee_memo = md_EventAffiliateFee.Fields().ByName("memo")
	fd_EventAffiliateFee_thorname = md_EventAffiliateFee.Fields().ByName("thorname")
	fd_EventAffiliateFee_rune_address = md_EventAffiliateFee.Fields().ByName("rune_address")
	fd_EventAffiliateFee_asset = md_EventAffiliateFee.Fields().ByName("asset")
	fd_EventAffiliateFee_gross_amount = md_EventAffiliateFee.Fields().ByName("gross_amount")
	fd_EventAffiliateFee_fee_bps = md_EventAffiliateFee.Fields().ByName("fee_bps")
	fd_EventAffiliateFee_fee_amount = md_EventAffiliateFee.Fields().ByName("fee_amount")
}

var _ protoreflect.Message = (*fastReflection_EventAffiliateFee)(nil)

type fastReflection_EventAffiliateFee EventAffiliateFee

func (x *EventAffiliateFee) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventAffiliateFee)(x)
}

func (x *EventAffiliateFee) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventAffiliateFee_messageType fastReflection_EventAffiliateFee_messageType
var _ protoreflect.MessageType = fastReflection_EventAffiliateFee_messageType{}

type fastReflection_EventAffiliateFee_messageType struct{}

func (x fastReflection_EventAffiliateFee_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventAffiliateFee)(nil)
}
func (x fastReflection_EventAffiliateFee_messageType) New() protoreflect.Message {
	return new(fastReflection_EventAffiliateFee)
}
func (x fastReflection_EventAffiliateFee_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventAffiliateFee
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventAffiliateFee) Descriptor() protoreflect.MessageDescriptor {
	return md_EventAffiliateFee
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventAffiliateFee) Type() protoreflect.MessageType {
	return _fastReflection_EventAffiliateFee_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventAffiliateFee) New() protoreflect.Message {
	return new(fastReflection_EventAffiliateFee)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventAffiliateFee) Interface() protoreflect.ProtoMessage {
	return (*EventAffiliateFee)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventAffiliateFee) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventAffiliateFee_tx_id, value) {
			return
		}
	}
	if x.Memo != "" {
		value := protoreflect.ValueOfString(x.Memo)
		if !f(fd_EventAffiliateFee_memo, value) {
			return
		}
	}
	if x.Thorname != "" {
		value := protoreflect.ValueOfString(x.Thorname)
		if !f(fd_EventAffiliateFee_thorname, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventAffiliateFee_rune_address, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventAffiliateFee_asset, value) {
			return
		}
	}
	if x.GrossAmount != "" {
		value := protoreflect.ValueOfString(x.GrossAmount)
		if !f(fd_EventAffiliateFee_gross_amount, value) {
			return
		}
	}
	if x.FeeBps != uint64(0) {
		value := protoreflect.ValueOfUint64(x.FeeBps)
		if !f(fd_EventAffiliateFee_fee_bps, value) {
			return
		}
	}
	if x.FeeAmount != "" {
		value := protoreflect.ValueOfString(x.FeeAmount)
		if !f(fd_EventAffiliateFee_fee_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventAffiliateFee) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventAffiliateFee.tx_id":
		return x.TxId != ""
	case "types.EventAffiliateFee.memo":
		return x.Memo != ""
	case "types.EventAffiliateFee.thorname":
		return x.Thorname != ""
	case "types.EventAffiliateFee.rune_address":
		return x.RuneAddress != ""
	case "types.EventAffiliateFee.asset":
		return x.Asset != nil
	case "types.EventAffiliateFee.gross_amount":
		return x.GrossAmount != ""
	case "types.EventAffiliateFee.fee_bps":
		return x.FeeBps != uint64(0)
	case "types.EventAffiliateFee.fee_amount":
		return x.FeeAmount != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAffiliateFee) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventAffiliateFee.tx_id":
		x.TxId = ""
	case "types.EventAffiliateFee.memo":
		x.Memo = ""
	case "types.EventAffiliateFee.thorname":
		x.Thorname = ""
	case "types.EventAffiliateFee.rune_address":
		x.RuneAddress = ""
	case "types.EventAffiliateFee.asset":
		x.Asset = nil
	case "types.EventAffiliateFee.gross_amount":
		x.GrossAmount = ""
	case "types.EventAffiliateFee.fee_bps":
		x.FeeBps = uint64(0)
	case "types.EventAffiliateFee.fee_amount":
		x.FeeAmount = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventAffiliateFee) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventAffiliateFee.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventAffiliateFee.memo":
		value := x.Memo
		return protoreflect.ValueOfString(value)
	case "types.EventAffiliateFee.thorname":
		value := x.Thorname
		return protoreflect.ValueOfString(value)
	case "types.EventAffiliateFee.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventAffiliateFee.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventAffiliateFee.gross_amount":
		value := x.GrossAmount
		return protoreflect.ValueOfString(value)
	case "types.EventAffiliateFee.fee_bps":
		value := x.FeeBps
		return protoreflect.ValueOfUint64(value)
	case "types.EventAffiliateFee.fee_amount":
		value := x.FeeAmount
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAffiliateFee) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventAffiliateFee.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventAffiliateFee.memo":
		x.Memo = value.Interface().(string)
	case "types.EventAffiliateFee.thorname":
		x.Thorname = value.Interface().(string)
	case "types.EventAffiliateFee.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventAffiliateFee.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventAffiliateFee.gross_amount":
		x.GrossAmount = value.Interface().(string)
	case "types.EventAffiliateFee.fee_bps":
		x.FeeBps = value.Uint()
	case "types.EventAffiliateFee.fee_amount":
		x.FeeAmount = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAffiliateFee) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventAffiliateFee.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventAffiliateFee.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.memo":
		panic(fmt.Errorf("field memo of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.thorname":
		panic(fmt.Errorf("field thorname of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.gross_amount":
		panic(fmt.Errorf("field gross_amount of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.fee_bps":
		panic(fmt.Errorf("field fee_bps of message types.EventAffiliateFee is not mutable"))
	case "types.EventAffiliateFee.fee_amount":
		panic(fmt.Errorf("field fee_amount of message types.EventAffiliateFee is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventAffiliateFee) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventAffiliateFee.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventAffiliateFee.memo":
		return protoreflect.ValueOfString("")
	case "types.EventAffiliateFee.thorname":
		return protoreflect.ValueOfString("")
	case "types.EventAffiliateFee.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventAffiliateFee.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventAffiliateFee.gross_amount":
		return protoreflect.ValueOfString("")
	case "types.EventAffiliateFee.fee_bps":
		return protoreflect.ValueOfUint64(uint64(0))
	case "types.EventAffiliateFee.fee_amount":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAffiliateFee"))
		}
		panic(fmt.Errorf("message types.EventAffiliateFee does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventAffiliateFee) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventAffiliateFee", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventAffiliateFee) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAffiliateFee) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventAffiliateFee) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventAffiliateFee) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventAffiliateFee)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Memo)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Thorname)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.GrossAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FeeBps != 0 {
			n += 1 + runtime.Sov(uint64(x.FeeBps))
		}
		l = len(x.FeeAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventAffiliateFee)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.FeeAmount) > 0 {
			i -= len(x.FeeAmount)
			copy(dAtA[i:], x.FeeAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FeeAmount)))
			i--
			dAtA[i] = 0x42
		}
		if x.FeeBps != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.FeeBps))
			i--
			dAtA[i] = 0x38
		}
		if len(x.GrossAmount) > 0 {
			i -= len(x.GrossAmount)
			copy(dAtA[i:], x.GrossAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.GrossAmount)))
			i--
			dAtA[i] = 0x32
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Thorname) > 0 {
			i -= len(x.Thorname)
			copy(dAtA[i:], x.Thorname)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Thorname)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Memo) > 0 {
			i -= len(x.Memo)
			copy(dAtA[i:], x.Memo)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Memo)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventAffiliateFee)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventAffiliateFee: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventAffiliateFee: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Memo = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Thorname", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Thorname = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field GrossAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.GrossAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeBps", wireType)
				}
				x.FeeBps = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.FeeBps |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FeeAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FeeAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventAddLiquidity                protoreflect.MessageDescriptor
	fd_EventAddLiquidity_pool           protoreflect.FieldDescriptor
	fd_EventAddLiquidity_provider_units protoreflect.FieldDescriptor
	fd_EventAddLiquidity_rune_address   protoreflect.FieldDescriptor
	fd_EventAddLiquidity_rune_amount    protoreflect.FieldDescriptor
	fd_EventAddLiquidity_asset_amount   protoreflect.FieldDescriptor
	fd_EventAddLiquidity_rune_tx_id     protoreflect.FieldDescriptor
	fd_EventAddLiquidity_asset_tx_id    protoreflect.FieldDescriptor
	fd_EventAddLiquidity_asset_address  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventAddLiquidity = File_types_type_events_proto.Messages().ByName("EventAddLiquidity")
	fd_EventAddLiquidity_pool = md_EventAddLiquidity.Fields().ByName("pool")
	fd_EventAddLiquidity_provider_units = md_EventAddLiquidity.Fields().ByName("provider_units")
	fd_EventAddLiquidity_rune_address = md_EventAddLiquidity.Fields().ByName("rune_address")
	fd_EventAddLiquidity_rune_amount = md_EventAddLiquidity.Fields().ByName("rune_amount")
	fd_EventAddLiquidity_asset_amount = md_EventAddLiquidity.Fields().ByName("asset_amount")
	fd_EventAddLiquidity_rune_tx_id = md_EventAddLiquidity.Fields().ByName("rune_tx_id")
	fd_EventAddLiquidity_asset_tx_id = md_EventAddLiquidity.Fields().ByName("asset_tx_id")
	fd_EventAddLiquidity_asset_address = md_EventAddLiquidity.Fields().ByName("asset_address")
}

var _ protoreflect.Message = (*fastReflection_EventAddLiquidity)(nil)

type fastReflection_EventAddLiquidity EventAddLiquidity

func (x *EventAddLiquidity) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventAddLiquidity)(x)
}

func (x *EventAddLiquidity) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventAddLiquidity_messageType fastReflection_EventAddLiquidity_messageType
var _ protoreflect.MessageType = fastReflection_EventAddLiquidity_messageType{}

type fastReflection_EventAddLiquidity_messageType struct{}

func (x fastReflection_EventAddLiquidity_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventAddLiquidity)(nil)
}
func (x fastReflection_EventAddLiquidity_messageType) New() protoreflect.Message {
	return new(fastReflection_EventAddLiquidity)
}
func (x fastReflection_EventAddLiquidity_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventAddLiquidity
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventAddLiquidity) Descriptor() protoreflect.MessageDescriptor {
	return md_EventAddLiquidity
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventAddLiquidity) Type() protoreflect.MessageType {
	return _fastReflection_EventAddLiquidity_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventAddLiquidity) New() protoreflect.Message {
	return new(fastReflection_EventAddLiquidity)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventAddLiquidity) Interface() protoreflect.ProtoMessage {
	return (*EventAddLiquidity)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventAddLiquidity) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventAddLiquidity_pool, value) {
			return
		}
	}
	if x.ProviderUnits != "" {
		value := protoreflect.ValueOfString(x.ProviderUnits)
		if !f(fd_EventAddLiquidity_provider_units, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventAddLiquidity_rune_address, value) {
			return
		}
	}
	if x.RuneAmount != "" {
		value := protoreflect.ValueOfString(x.RuneAmount)
		if !f(fd_EventAddLiquidity_rune_amount, value) {
			return
		}
	}
	if x.AssetAmount != "" {
		value := protoreflect.ValueOfString(x.AssetAmount)
		if !f(fd_EventAddLiquidity_asset_amount, value) {
			return
		}
	}
	if x.RuneTxId != "" {
		value := protoreflect.ValueOfString(x.RuneTxId)
		if !f(fd_EventAddLiquidity_rune_tx_id, value) {
			return
		}
	}
	if x.AssetTxId != "" {
		value := protoreflect.ValueOfString(x.AssetTxId)
		if !f(fd_EventAddLiquidity_asset_tx_id, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventAddLiquidity_asset_address, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventAddLiquidity) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventAddLiquidity.pool":
		return x.Pool != nil
	case "types.EventAddLiquidity.provider_units":
		return x.ProviderUnits != ""
	case "types.EventAddLiquidity.rune_address":
		return x.RuneAddress != ""
	case "types.EventAddLiquidity.rune_amount":
		return x.RuneAmount != ""
	case "types.EventAddLiquidity.asset_amount":
		return x.AssetAmount != ""
	case "types.EventAddLiquidity.rune_tx_id":
		return x.RuneTxId != ""
	case "types.EventAddLiquidity.asset_tx_id":
		return x.AssetTxId != ""
	case "types.EventAddLiquidity.asset_address":
		return x.AssetAddress != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAddLiquidity) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventAddLiquidity.pool":
		x.Pool = nil
	case "types.EventAddLiquidity.provider_units":
		x.ProviderUnits = ""
	case "types.EventAddLiquidity.rune_address":
		x.RuneAddress = ""
	case "types.EventAddLiquidity.rune_amount":
		x.RuneAmount = ""
	case "types.EventAddLiquidity.asset_amount":
		x.AssetAmount = ""
	case "types.EventAddLiquidity.rune_tx_id":
		x.RuneTxId = ""
	case "types.EventAddLiquidity.asset_tx_id":
		x.AssetTxId = ""
	case "types.EventAddLiquidity.asset_address":
		x.AssetAddress = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventAddLiquidity) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventAddLiquidity.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventAddLiquidity.provider_units":
		value := x.ProviderUnits
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.rune_amount":
		value := x.RuneAmount
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.asset_amount":
		value := x.AssetAmount
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.rune_tx_id":
		value := x.RuneTxId
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.asset_tx_id":
		value := x.AssetTxId
		return protoreflect.ValueOfString(value)
	case "types.EventAddLiquidity.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAddLiquidity) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventAddLiquidity.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventAddLiquidity.provider_units":
		x.ProviderUnits = value.Interface().(string)
	case "types.EventAddLiquidity.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventAddLiquidity.rune_amount":
		x.RuneAmount = value.Interface().(string)
	case "types.EventAddLiquidity.asset_amount":
		x.AssetAmount = value.Interface().(string)
	case "types.EventAddLiquidity.rune_tx_id":
		x.RuneTxId = value.Interface().(string)
	case "types.EventAddLiquidity.asset_tx_id":
		x.AssetTxId = value.Interface().(string)
	case "types.EventAddLiquidity.asset_address":
		x.AssetAddress = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAddLiquidity) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventAddLiquidity.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventAddLiquidity.provider_units":
		panic(fmt.Errorf("field provider_units of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.rune_amount":
		panic(fmt.Errorf("field rune_amount of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.asset_amount":
		panic(fmt.Errorf("field asset_amount of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.rune_tx_id":
		panic(fmt.Errorf("field rune_tx_id of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.asset_tx_id":
		panic(fmt.Errorf("field asset_tx_id of message types.EventAddLiquidity is not mutable"))
	case "types.EventAddLiquidity.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventAddLiquidity is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventAddLiquidity) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventAddLiquidity.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventAddLiquidity.provider_units":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.rune_amount":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.asset_amount":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.rune_tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.asset_tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventAddLiquidity.asset_address":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventAddLiquidity"))
		}
		panic(fmt.Errorf("message types.EventAddLiquidity does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventAddLiquidity) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventAddLiquidity", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventAddLiquidity) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventAddLiquidity) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventAddLiquidity) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventAddLiquidity) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventAddLiquidity)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ProviderUnits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneTxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetTxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventAddLiquidity)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.AssetTxId) > 0 {
			i -= len(x.AssetTxId)
			copy(dAtA[i:], x.AssetTxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetTxId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.RuneTxId) > 0 {
			i -= len(x.RuneTxId)
			copy(dAtA[i:], x.RuneTxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneTxId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.AssetAmount) > 0 {
			i -= len(x.AssetAmount)
			copy(dAtA[i:], x.AssetAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAmount)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAmount) > 0 {
			i -= len(x.RuneAmount)
			copy(dAtA[i:], x.RuneAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmount)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.ProviderUnits) > 0 {
			i -= len(x.ProviderUnits)
			copy(dAtA[i:], x.ProviderUnits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProviderUnits)))
			i--
			dAtA[i] = 0x12
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventAddLiquidity)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventAddLiquidity: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventAddLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProviderUnits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneTxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneTxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetTxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetTxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventWithdraw                protoreflect.MessageDescriptor
	fd_EventWithdraw_pool           protoreflect.FieldDescriptor
	fd_EventWithdraw_provider_units protoreflect.FieldDescriptor
	fd_EventWithdraw_basis_points   protoreflect.FieldDescriptor
	fd_EventWithdraw_asymmetry      protoreflect.FieldDescriptor
	fd_EventWithdraw_in_tx          protoreflect.FieldDescriptor
	fd_EventWithdraw_emit_asset     protoreflect.FieldDescriptor
	fd_EventWithdraw_emit_rune      protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventWithdraw = File_types_type_events_proto.Messages().ByName("EventWithdraw")
	fd_EventWithdraw_pool = md_EventWithdraw.Fields().ByName("pool")
	fd_EventWithdraw_provider_units = md_EventWithdraw.Fields().ByName("provider_units")
	fd_EventWithdraw_basis_points = md_EventWithdraw.Fields().ByName("basis_points")
	fd_EventWithdraw_asymmetry = md_EventWithdraw.Fields().ByName("asymmetry")
	fd_EventWithdraw_in_tx = md_EventWithdraw.Fields().ByName("in_tx")
	fd_EventWithdraw_emit_asset = md_EventWithdraw.Fields().ByName("emit_asset")
	fd_EventWithdraw_emit_rune = md_EventWithdraw.Fields().ByName("emit_rune")
}

var _ protoreflect.Message = (*fastReflection_EventWithdraw)(nil)

type fastReflection_EventWithdraw EventWithdraw

func (x *EventWithdraw) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventWithdraw)(x)
}

func (x *EventWithdraw) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventWithdraw_messageType fastReflection_EventWithdraw_messageType
var _ protoreflect.MessageType = fastReflection_EventWithdraw_messageType{}

type fastReflection_EventWithdraw_messageType struct{}

func (x fastReflection_EventWithdraw_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventWithdraw)(nil)
}
func (x fastReflection_EventWithdraw_messageType) New() protoreflect.Message {
	return new(fastReflection_EventWithdraw)
}
func (x fastReflection_EventWithdraw_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventWithdraw
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventWithdraw) Descriptor() protoreflect.MessageDescriptor {
	return md_EventWithdraw
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventWithdraw) Type() protoreflect.MessageType {
	return _fastReflection_EventWithdraw_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventWithdraw) New() protoreflect.Message {
	return new(fastReflection_EventWithdraw)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventWithdraw) Interface() protoreflect.ProtoMessage {
	return (*EventWithdraw)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventWithdraw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventWithdraw_pool, value) {
			return
		}
	}
	if x.ProviderUnits != "" {
		value := protoreflect.ValueOfString(x.ProviderUnits)
		if !f(fd_EventWithdraw_provider_units, value) {
			return
		}
	}
	if x.BasisPoints != int64(0) {
		value := protoreflect.ValueOfInt64(x.BasisPoints)
		if !f(fd_EventWithdraw_basis_points, value) {
			return
		}
	}
	if len(x.Asymmetry) != 0 {
		value := protoreflect.ValueOfBytes(x.Asymmetry)
		if !f(fd_EventWithdraw_asymmetry, value) {
			return
		}
	}
	if x.InTx != nil {
		value := protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
		if !f(fd_EventWithdraw_in_tx, value) {
			return
		}
	}
	if x.EmitAsset != "" {
		value := protoreflect.ValueOfString(x.EmitAsset)
		if !f(fd_EventWithdraw_emit_asset, value) {
			return
		}
	}
	if x.EmitRune != "" {
		value := protoreflect.ValueOfString(x.EmitRune)
		if !f(fd_EventWithdraw_emit_rune, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventWithdraw) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventWithdraw.pool":
		return x.Pool != nil
	case "types.EventWithdraw.provider_units":
		return x.ProviderUnits != ""
	case "types.EventWithdraw.basis_points":
		return x.BasisPoints != int64(0)
	case "types.EventWithdraw.asymmetry":
		return len(x.Asymmetry) != 0
	case "types.EventWithdraw.in_tx":
		return x.InTx != nil
	case "types.EventWithdraw.emit_asset":
		return x.EmitAsset != ""
	case "types.EventWithdraw.emit_rune":
		return x.EmitRune != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventWithdraw) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventWithdraw.pool":
		x.Pool = nil
	case "types.EventWithdraw.provider_units":
		x.ProviderUnits = ""
	case "types.EventWithdraw.basis_points":
		x.BasisPoints = int64(0)
	case "types.EventWithdraw.asymmetry":
		x.Asymmetry = nil
	case "types.EventWithdraw.in_tx":
		x.InTx = nil
	case "types.EventWithdraw.emit_asset":
		x.EmitAsset = ""
	case "types.EventWithdraw.emit_rune":
		x.EmitRune = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventWithdraw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventWithdraw.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventWithdraw.provider_units":
		value := x.ProviderUnits
		return protoreflect.ValueOfString(value)
	case "types.EventWithdraw.basis_points":
		value := x.BasisPoints
		return protoreflect.ValueOfInt64(value)
	case "types.EventWithdraw.asymmetry":
		value := x.Asymmetry
		return protoreflect.ValueOfBytes(value)
	case "types.EventWithdraw.in_tx":
		value := x.InTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventWithdraw.emit_asset":
		value := x.EmitAsset
		return protoreflect.ValueOfString(value)
	case "types.EventWithdraw.emit_rune":
		value := x.EmitRune
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventWithdraw) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventWithdraw.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventWithdraw.provider_units":
		x.ProviderUnits = value.Interface().(string)
	case "types.EventWithdraw.basis_points":
		x.BasisPoints = value.Int()
	case "types.EventWithdraw.asymmetry":
		x.Asymmetry = value.Bytes()
	case "types.EventWithdraw.in_tx":
		x.InTx = value.Message().Interface().(*common.Tx)
	case "types.EventWithdraw.emit_asset":
		x.EmitAsset = value.Interface().(string)
	case "types.EventWithdraw.emit_rune":
		x.EmitRune = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventWithdraw) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventWithdraw.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventWithdraw.in_tx":
		if x.InTx == nil {
			x.InTx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
	case "types.EventWithdraw.provider_units":
		panic(fmt.Errorf("field provider_units of message types.EventWithdraw is not mutable"))
	case "types.EventWithdraw.basis_points":
		panic(fmt.Errorf("field basis_points of message types.EventWithdraw is not mutable"))
	case "types.EventWithdraw.asymmetry":
		panic(fmt.Errorf("field asymmetry of message types.EventWithdraw is not mutable"))
	case "types.EventWithdraw.emit_asset":
		panic(fmt.Errorf("field emit_asset of message types.EventWithdraw is not mutable"))
	case "types.EventWithdraw.emit_rune":
		panic(fmt.Errorf("field emit_rune of message types.EventWithdraw is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventWithdraw) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventWithdraw.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventWithdraw.provider_units":
		return protoreflect.ValueOfString("")
	case "types.EventWithdraw.basis_points":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventWithdraw.asymmetry":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventWithdraw.in_tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventWithdraw.emit_asset":
		return protoreflect.ValueOfString("")
	case "types.EventWithdraw.emit_rune":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventWithdraw"))
		}
		panic(fmt.Errorf("message types.EventWithdraw does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventWithdraw) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventWithdraw", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventWithdraw) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventWithdraw) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventWithdraw) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventWithdraw) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventWithdraw)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.ProviderUnits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BasisPoints != 0 {
			n += 1 + runtime.Sov(uint64(x.BasisPoints))
		}
		l = len(x.Asymmetry)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InTx != nil {
			l = options.Size(x.InTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EmitAsset)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EmitRune)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventWithdraw)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.EmitRune) > 0 {
			i -= len(x.EmitRune)
			copy(dAtA[i:], x.EmitRune)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EmitRune)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.EmitAsset) > 0 {
			i -= len(x.EmitAsset)
			copy(dAtA[i:], x.EmitAsset)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EmitAsset)))
			i--
			dAtA[i] = 0x32
		}
		if x.InTx != nil {
			encoded, err := options.Marshal(x.InTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Asymmetry) > 0 {
			i -= len(x.Asymmetry)
			copy(dAtA[i:], x.Asymmetry)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Asymmetry)))
			i--
			dAtA[i] = 0x22
		}
		if x.BasisPoints != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BasisPoints))
			i--
			dAtA[i] = 0x18
		}
		if len(x.ProviderUnits) > 0 {
			i -= len(x.ProviderUnits)
			copy(dAtA[i:], x.ProviderUnits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.ProviderUnits)))
			i--
			dAtA[i] = 0x12
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventWithdraw)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProviderUnits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.ProviderUnits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
				}
				x.BasisPoints = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BasisPoints |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asymmetry", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Asymmetry = append(x.Asymmetry[:0], dAtA[iNdEx:postIndex]...)
				if x.Asymmetry == nil {
					x.Asymmetry = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InTx == nil {
					x.InTx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EmitAsset", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EmitAsset = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EmitRune", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EmitRune = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPendingLiquidity               protoreflect.MessageDescriptor
	fd_EventPendingLiquidity_pool          protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_pending_type  protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_rune_address  protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_rune_amount   protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_asset_address protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_asset_amount  protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_rune_tx_id    protoreflect.FieldDescriptor
	fd_EventPendingLiquidity_asset_tx_id   protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventPendingLiquidity = File_types_type_events_proto.Messages().ByName("EventPendingLiquidity")
	fd_EventPendingLiquidity_pool = md_EventPendingLiquidity.Fields().ByName("pool")
	fd_EventPendingLiquidity_pending_type = md_EventPendingLiquidity.Fields().ByName("pending_type")
	fd_EventPendingLiquidity_rune_address = md_EventPendingLiquidity.Fields().ByName("rune_address")
	fd_EventPendingLiquidity_rune_amount = md_EventPendingLiquidity.Fields().ByName("rune_amount")
	fd_EventPendingLiquidity_asset_address = md_EventPendingLiquidity.Fields().ByName("asset_address")
	fd_EventPendingLiquidity_asset_amount = md_EventPendingLiquidity.Fields().ByName("asset_amount")
	fd_EventPendingLiquidity_rune_tx_id = md_EventPendingLiquidity.Fields().ByName("rune_tx_id")
	fd_EventPendingLiquidity_asset_tx_id = md_EventPendingLiquidity.Fields().ByName("asset_tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventPendingLiquidity)(nil)

type fastReflection_EventPendingLiquidity EventPendingLiquidity

func (x *EventPendingLiquidity) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPendingLiquidity)(x)
}

func (x *EventPendingLiquidity) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPendingLiquidity_messageType fastReflection_EventPendingLiquidity_messageType
var _ protoreflect.MessageType = fastReflection_EventPendingLiquidity_messageType{}

type fastReflection_EventPendingLiquidity_messageType struct{}

func (x fastReflection_EventPendingLiquidity_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPendingLiquidity)(nil)
}
func (x fastReflection_EventPendingLiquidity_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPendingLiquidity)
}
func (x fastReflection_EventPendingLiquidity_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPendingLiquidity
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPendingLiquidity) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPendingLiquidity
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPendingLiquidity) Type() protoreflect.MessageType {
	return _fastReflection_EventPendingLiquidity_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPendingLiquidity) New() protoreflect.Message {
	return new(fastReflection_EventPendingLiquidity)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPendingLiquidity) Interface() protoreflect.ProtoMessage {
	return (*EventPendingLiquidity)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPendingLiquidity) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventPendingLiquidity_pool, value) {
			return
		}
	}
	if x.PendingType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.PendingType))
		if !f(fd_EventPendingLiquidity_pending_type, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventPendingLiquidity_rune_address, value) {
			return
		}
	}
	if x.RuneAmount != "" {
		value := protoreflect.ValueOfString(x.RuneAmount)
		if !f(fd_EventPendingLiquidity_rune_amount, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventPendingLiquidity_asset_address, value) {
			return
		}
	}
	if x.AssetAmount != "" {
		value := protoreflect.ValueOfString(x.AssetAmount)
		if !f(fd_EventPendingLiquidity_asset_amount, value) {
			return
		}
	}
	if x.RuneTxId != "" {
		value := protoreflect.ValueOfString(x.RuneTxId)
		if !f(fd_EventPendingLiquidity_rune_tx_id, value) {
			return
		}
	}
	if x.AssetTxId != "" {
		value := protoreflect.ValueOfString(x.AssetTxId)
		if !f(fd_EventPendingLiquidity_asset_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPendingLiquidity) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventPendingLiquidity.pool":
		return x.Pool != nil
	case "types.EventPendingLiquidity.pending_type":
		return x.PendingType != 0
	case "types.EventPendingLiquidity.rune_address":
		return x.RuneAddress != ""
	case "types.EventPendingLiquidity.rune_amount":
		return x.RuneAmount != ""
	case "types.EventPendingLiquidity.asset_address":
		return x.AssetAddress != ""
	case "types.EventPendingLiquidity.asset_amount":
		return x.AssetAmount != ""
	case "types.EventPendingLiquidity.rune_tx_id":
		return x.RuneTxId != ""
	case "types.EventPendingLiquidity.asset_tx_id":
		return x.AssetTxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPendingLiquidity) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventPendingLiquidity.pool":
		x.Pool = nil
	case "types.EventPendingLiquidity.pending_type":
		x.PendingType = 0
	case "types.EventPendingLiquidity.rune_address":
		x.RuneAddress = ""
	case "types.EventPendingLiquidity.rune_amount":
		x.RuneAmount = ""
	case "types.EventPendingLiquidity.asset_address":
		x.AssetAddress = ""
	case "types.EventPendingLiquidity.asset_amount":
		x.AssetAmount = ""
	case "types.EventPendingLiquidity.rune_tx_id":
		x.RuneTxId = ""
	case "types.EventPendingLiquidity.asset_tx_id":
		x.AssetTxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPendingLiquidity) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventPendingLiquidity.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventPendingLiquidity.pending_type":
		value := x.PendingType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "types.EventPendingLiquidity.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventPendingLiquidity.rune_amount":
		value := x.RuneAmount
		return protoreflect.ValueOfString(value)
	case "types.EventPendingLiquidity.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventPendingLiquidity.asset_amount":
		value := x.AssetAmount
		return protoreflect.ValueOfString(value)
	case "types.EventPendingLiquidity.rune_tx_id":
		value := x.RuneTxId
		return protoreflect.ValueOfString(value)
	case "types.EventPendingLiquidity.asset_tx_id":
		value := x.AssetTxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPendingLiquidity) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventPendingLiquidity.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventPendingLiquidity.pending_type":
		x.PendingType = (PendingLiquidityType)(value.Enum())
	case "types.EventPendingLiquidity.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventPendingLiquidity.rune_amount":
		x.RuneAmount = value.Interface().(string)
	case "types.EventPendingLiquidity.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventPendingLiquidity.asset_amount":
		x.AssetAmount = value.Interface().(string)
	case "types.EventPendingLiquidity.rune_tx_id":
		x.RuneTxId = value.Interface().(string)
	case "types.EventPendingLiquidity.asset_tx_id":
		x.AssetTxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPendingLiquidity) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPendingLiquidity.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventPendingLiquidity.pending_type":
		panic(fmt.Errorf("field pending_type of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.rune_amount":
		panic(fmt.Errorf("field rune_amount of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.asset_amount":
		panic(fmt.Errorf("field asset_amount of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.rune_tx_id":
		panic(fmt.Errorf("field rune_tx_id of message types.EventPendingLiquidity is not mutable"))
	case "types.EventPendingLiquidity.asset_tx_id":
		panic(fmt.Errorf("field asset_tx_id of message types.EventPendingLiquidity is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPendingLiquidity) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPendingLiquidity.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventPendingLiquidity.pending_type":
		return protoreflect.ValueOfEnum(0)
	case "types.EventPendingLiquidity.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventPendingLiquidity.rune_amount":
		return protoreflect.ValueOfString("")
	case "types.EventPendingLiquidity.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventPendingLiquidity.asset_amount":
		return protoreflect.ValueOfString("")
	case "types.EventPendingLiquidity.rune_tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventPendingLiquidity.asset_tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPendingLiquidity"))
		}
		panic(fmt.Errorf("message types.EventPendingLiquidity does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPendingLiquidity) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventPendingLiquidity", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPendingLiquidity) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPendingLiquidity) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPendingLiquidity) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPendingLiquidity) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPendingLiquidity)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PendingType != 0 {
			n += 1 + runtime.Sov(uint64(x.PendingType))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneTxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetTxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPendingLiquidity)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AssetTxId) > 0 {
			i -= len(x.AssetTxId)
			copy(dAtA[i:], x.AssetTxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetTxId)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.RuneTxId) > 0 {
			i -= len(x.RuneTxId)
			copy(dAtA[i:], x.RuneTxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneTxId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.AssetAmount) > 0 {
			i -= len(x.AssetAmount)
			copy(dAtA[i:], x.AssetAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAmount)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAmount) > 0 {
			i -= len(x.RuneAmount)
			copy(dAtA[i:], x.RuneAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmount)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.PendingType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.PendingType))
			i--
			dAtA[i] = 0x10
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPendingLiquidity)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPendingLiquidity: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPendingLiquidity: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PendingType", wireType)
				}
				x.PendingType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.PendingType |= PendingLiquidityType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneTxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneTxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetTxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetTxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventDonate       protoreflect.MessageDescriptor
	fd_EventDonate_pool  protoreflect.FieldDescriptor
	fd_EventDonate_in_tx protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventDonate = File_types_type_events_proto.Messages().ByName("EventDonate")
	fd_EventDonate_pool = md_EventDonate.Fields().ByName("pool")
	fd_EventDonate_in_tx = md_EventDonate.Fields().ByName("in_tx")
}

var _ protoreflect.Message = (*fastReflection_EventDonate)(nil)

type fastReflection_EventDonate EventDonate

func (x *EventDonate) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventDonate)(x)
}

func (x *EventDonate) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventDonate_messageType fastReflection_EventDonate_messageType
var _ protoreflect.MessageType = fastReflection_EventDonate_messageType{}

type fastReflection_EventDonate_messageType struct{}

func (x fastReflection_EventDonate_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventDonate)(nil)
}
func (x fastReflection_EventDonate_messageType) New() protoreflect.Message {
	return new(fastReflection_EventDonate)
}
func (x fastReflection_EventDonate_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventDonate
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventDonate) Descriptor() protoreflect.MessageDescriptor {
	return md_EventDonate
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventDonate) Type() protoreflect.MessageType {
	return _fastReflection_EventDonate_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventDonate) New() protoreflect.Message {
	return new(fastReflection_EventDonate)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventDonate) Interface() protoreflect.ProtoMessage {
	return (*EventDonate)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventDonate) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventDonate_pool, value) {
			return
		}
	}
	if x.InTx != nil {
		value := protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
		if !f(fd_EventDonate_in_tx, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventDonate) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventDonate.pool":
		return x.Pool != nil
	case "types.EventDonate.in_tx":
		return x.InTx != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDonate) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventDonate.pool":
		x.Pool = nil
	case "types.EventDonate.in_tx":
		x.InTx = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventDonate) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventDonate.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventDonate.in_tx":
		value := x.InTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDonate) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventDonate.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventDonate.in_tx":
		x.InTx = value.Message().Interface().(*common.Tx)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDonate) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventDonate.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventDonate.in_tx":
		if x.InTx == nil {
			x.InTx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventDonate) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventDonate.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventDonate.in_tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventDonate"))
		}
		panic(fmt.Errorf("message types.EventDonate does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventDonate) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventDonate", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventDonate) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventDonate) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventDonate) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventDonate) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventDonate)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InTx != nil {
			l = options.Size(x.InTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventDonate)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.InTx != nil {
			encoded, err := options.Marshal(x.InTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventDonate)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventDonate: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventDonate: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InTx == nil {
					x.InTx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPool        protoreflect.MessageDescriptor
	fd_EventPool_pool   protoreflect.FieldDescriptor
	fd_EventPool_Status protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventPool = File_types_type_events_proto.Messages().ByName("EventPool")
	fd_EventPool_pool = md_EventPool.Fields().ByName("pool")
	fd_EventPool_Status = md_EventPool.Fields().ByName("Status")
}

var _ protoreflect.Message = (*fastReflection_EventPool)(nil)

type fastReflection_EventPool EventPool

func (x *EventPool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPool)(x)
}

func (x *EventPool) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPool_messageType fastReflection_EventPool_messageType
var _ protoreflect.MessageType = fastReflection_EventPool_messageType{}

type fastReflection_EventPool_messageType struct{}

func (x fastReflection_EventPool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPool)(nil)
}
func (x fastReflection_EventPool_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPool)
}
func (x fastReflection_EventPool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPool) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPool) Type() protoreflect.MessageType {
	return _fastReflection_EventPool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPool) New() protoreflect.Message {
	return new(fastReflection_EventPool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPool) Interface() protoreflect.ProtoMessage {
	return (*EventPool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventPool_pool, value) {
			return
		}
	}
	if x.Status != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Status))
		if !f(fd_EventPool_Status, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventPool.pool":
		return x.Pool != nil
	case "types.EventPool.Status":
		return x.Status != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventPool.pool":
		x.Pool = nil
	case "types.EventPool.Status":
		x.Status = 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventPool.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventPool.Status":
		value := x.Status
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventPool.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventPool.Status":
		x.Status = (PoolStatus)(value.Enum())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPool.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventPool.Status":
		panic(fmt.Errorf("field Status of message types.EventPool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPool.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventPool.Status":
		return protoreflect.ValueOfEnum(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPool"))
		}
		panic(fmt.Errorf("message types.EventPool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventPool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Status != 0 {
			n += 1 + runtime.Sov(uint64(x.Status))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Status != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Status))
			i--
			dAtA[i] = 0x10
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
				}
				x.Status = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Status |= PoolStatus(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PoolAmt        protoreflect.MessageDescriptor
	fd_PoolAmt_asset  protoreflect.FieldDescriptor
	fd_PoolAmt_amount protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_PoolAmt = File_types_type_events_proto.Messages().ByName("PoolAmt")
	fd_PoolAmt_asset = md_PoolAmt.Fields().ByName("asset")
	fd_PoolAmt_amount = md_PoolAmt.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_PoolAmt)(nil)

type fastReflection_PoolAmt PoolAmt

func (x *PoolAmt) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PoolAmt)(x)
}

func (x *PoolAmt) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PoolAmt_messageType fastReflection_PoolAmt_messageType
var _ protoreflect.MessageType = fastReflection_PoolAmt_messageType{}

type fastReflection_PoolAmt_messageType struct{}

func (x fastReflection_PoolAmt_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PoolAmt)(nil)
}
func (x fastReflection_PoolAmt_messageType) New() protoreflect.Message {
	return new(fastReflection_PoolAmt)
}
func (x fastReflection_PoolAmt_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolAmt
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PoolAmt) Descriptor() protoreflect.MessageDescriptor {
	return md_PoolAmt
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PoolAmt) Type() protoreflect.MessageType {
	return _fastReflection_PoolAmt_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PoolAmt) New() protoreflect.Message {
	return new(fastReflection_PoolAmt)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PoolAmt) Interface() protoreflect.ProtoMessage {
	return (*PoolAmt)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PoolAmt) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_PoolAmt_asset, value) {
			return
		}
	}
	if x.Amount != int64(0) {
		value := protoreflect.ValueOfInt64(x.Amount)
		if !f(fd_PoolAmt_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PoolAmt) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.PoolAmt.asset":
		return x.Asset != nil
	case "types.PoolAmt.amount":
		return x.Amount != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolAmt) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.PoolAmt.asset":
		x.Asset = nil
	case "types.PoolAmt.amount":
		x.Amount = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PoolAmt) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.PoolAmt.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.PoolAmt.amount":
		value := x.Amount
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolAmt) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.PoolAmt.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.PoolAmt.amount":
		x.Amount = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolAmt) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.PoolAmt.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.PoolAmt.amount":
		panic(fmt.Errorf("field amount of message types.PoolAmt is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PoolAmt) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.PoolAmt.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.PoolAmt.amount":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.PoolAmt"))
		}
		panic(fmt.Errorf("message types.PoolAmt does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PoolAmt) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.PoolAmt", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PoolAmt) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PoolAmt) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PoolAmt) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PoolAmt) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PoolAmt)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Amount != 0 {
			n += 1 + runtime.Sov(uint64(x.Amount))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PoolAmt)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Amount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Amount))
			i--
			dAtA[i] = 0x10
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PoolAmt)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolAmt: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PoolAmt: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				x.Amount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Amount |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventRewards_2_list)(nil)

type _EventRewards_2_list struct {
	list *[]*PoolAmt
}

func (x *_EventRewards_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventRewards_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_EventRewards_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolAmt)
	(*x.list)[i] = concreteValue
}

func (x *_EventRewards_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolAmt)
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventRewards_2_list) AppendMutable() protoreflect.Value {
	v := new(PoolAmt)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventRewards_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_EventRewards_2_list) NewElement() protoreflect.Value {
	v := new(PoolAmt)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventRewards_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventRewards                  protoreflect.MessageDescriptor
	fd_EventRewards_bond_reward      protoreflect.FieldDescriptor
	fd_EventRewards_pool_rewards     protoreflect.FieldDescriptor
	fd_EventRewards_dev_fund_reward  protoreflect.FieldDescriptor
	fd_EventRewards_income_burn      protoreflect.FieldDescriptor
	fd_EventRewards_tcy_stake_reward protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventRewards = File_types_type_events_proto.Messages().ByName("EventRewards")
	fd_EventRewards_bond_reward = md_EventRewards.Fields().ByName("bond_reward")
	fd_EventRewards_pool_rewards = md_EventRewards.Fields().ByName("pool_rewards")
	fd_EventRewards_dev_fund_reward = md_EventRewards.Fields().ByName("dev_fund_reward")
	fd_EventRewards_income_burn = md_EventRewards.Fields().ByName("income_burn")
	fd_EventRewards_tcy_stake_reward = md_EventRewards.Fields().ByName("tcy_stake_reward")
}

var _ protoreflect.Message = (*fastReflection_EventRewards)(nil)

type fastReflection_EventRewards EventRewards

func (x *EventRewards) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRewards)(x)
}

func (x *EventRewards) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRewards_messageType fastReflection_EventRewards_messageType
var _ protoreflect.MessageType = fastReflection_EventRewards_messageType{}

type fastReflection_EventRewards_messageType struct{}

func (x fastReflection_EventRewards_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRewards)(nil)
}
func (x fastReflection_EventRewards_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRewards)
}
func (x fastReflection_EventRewards_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRewards
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRewards) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRewards
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRewards) Type() protoreflect.MessageType {
	return _fastReflection_EventRewards_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRewards) New() protoreflect.Message {
	return new(fastReflection_EventRewards)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRewards) Interface() protoreflect.ProtoMessage {
	return (*EventRewards)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRewards) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.BondReward != "" {
		value := protoreflect.ValueOfString(x.BondReward)
		if !f(fd_EventRewards_bond_reward, value) {
			return
		}
	}
	if len(x.PoolRewards) != 0 {
		value := protoreflect.ValueOfList(&_EventRewards_2_list{list: &x.PoolRewards})
		if !f(fd_EventRewards_pool_rewards, value) {
			return
		}
	}
	if x.DevFundReward != "" {
		value := protoreflect.ValueOfString(x.DevFundReward)
		if !f(fd_EventRewards_dev_fund_reward, value) {
			return
		}
	}
	if x.IncomeBurn != "" {
		value := protoreflect.ValueOfString(x.IncomeBurn)
		if !f(fd_EventRewards_income_burn, value) {
			return
		}
	}
	if x.TcyStakeReward != "" {
		value := protoreflect.ValueOfString(x.TcyStakeReward)
		if !f(fd_EventRewards_tcy_stake_reward, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRewards) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventRewards.bond_reward":
		return x.BondReward != ""
	case "types.EventRewards.pool_rewards":
		return len(x.PoolRewards) != 0
	case "types.EventRewards.dev_fund_reward":
		return x.DevFundReward != ""
	case "types.EventRewards.income_burn":
		return x.IncomeBurn != ""
	case "types.EventRewards.tcy_stake_reward":
		return x.TcyStakeReward != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRewards) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventRewards.bond_reward":
		x.BondReward = ""
	case "types.EventRewards.pool_rewards":
		x.PoolRewards = nil
	case "types.EventRewards.dev_fund_reward":
		x.DevFundReward = ""
	case "types.EventRewards.income_burn":
		x.IncomeBurn = ""
	case "types.EventRewards.tcy_stake_reward":
		x.TcyStakeReward = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRewards) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventRewards.bond_reward":
		value := x.BondReward
		return protoreflect.ValueOfString(value)
	case "types.EventRewards.pool_rewards":
		if len(x.PoolRewards) == 0 {
			return protoreflect.ValueOfList(&_EventRewards_2_list{})
		}
		listValue := &_EventRewards_2_list{list: &x.PoolRewards}
		return protoreflect.ValueOfList(listValue)
	case "types.EventRewards.dev_fund_reward":
		value := x.DevFundReward
		return protoreflect.ValueOfString(value)
	case "types.EventRewards.income_burn":
		value := x.IncomeBurn
		return protoreflect.ValueOfString(value)
	case "types.EventRewards.tcy_stake_reward":
		value := x.TcyStakeReward
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRewards) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventRewards.bond_reward":
		x.BondReward = value.Interface().(string)
	case "types.EventRewards.pool_rewards":
		lv := value.List()
		clv := lv.(*_EventRewards_2_list)
		x.PoolRewards = *clv.list
	case "types.EventRewards.dev_fund_reward":
		x.DevFundReward = value.Interface().(string)
	case "types.EventRewards.income_burn":
		x.IncomeBurn = value.Interface().(string)
	case "types.EventRewards.tcy_stake_reward":
		x.TcyStakeReward = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRewards) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRewards.pool_rewards":
		if x.PoolRewards == nil {
			x.PoolRewards = []*PoolAmt{}
		}
		value := &_EventRewards_2_list{list: &x.PoolRewards}
		return protoreflect.ValueOfList(value)
	case "types.EventRewards.bond_reward":
		panic(fmt.Errorf("field bond_reward of message types.EventRewards is not mutable"))
	case "types.EventRewards.dev_fund_reward":
		panic(fmt.Errorf("field dev_fund_reward of message types.EventRewards is not mutable"))
	case "types.EventRewards.income_burn":
		panic(fmt.Errorf("field income_burn of message types.EventRewards is not mutable"))
	case "types.EventRewards.tcy_stake_reward":
		panic(fmt.Errorf("field tcy_stake_reward of message types.EventRewards is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRewards) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRewards.bond_reward":
		return protoreflect.ValueOfString("")
	case "types.EventRewards.pool_rewards":
		list := []*PoolAmt{}
		return protoreflect.ValueOfList(&_EventRewards_2_list{list: &list})
	case "types.EventRewards.dev_fund_reward":
		return protoreflect.ValueOfString("")
	case "types.EventRewards.income_burn":
		return protoreflect.ValueOfString("")
	case "types.EventRewards.tcy_stake_reward":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRewards"))
		}
		panic(fmt.Errorf("message types.EventRewards does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRewards) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventRewards", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRewards) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRewards) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRewards) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRewards) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRewards)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.BondReward)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.PoolRewards) > 0 {
			for _, e := range x.PoolRewards {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.DevFundReward)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.IncomeBurn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TcyStakeReward)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRewards)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TcyStakeReward) > 0 {
			i -= len(x.TcyStakeReward)
			copy(dAtA[i:], x.TcyStakeReward)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TcyStakeReward)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.IncomeBurn) > 0 {
			i -= len(x.IncomeBurn)
			copy(dAtA[i:], x.IncomeBurn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.IncomeBurn)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.DevFundReward) > 0 {
			i -= len(x.DevFundReward)
			copy(dAtA[i:], x.DevFundReward)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DevFundReward)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PoolRewards) > 0 {
			for iNdEx := len(x.PoolRewards) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.PoolRewards[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.BondReward) > 0 {
			i -= len(x.BondReward)
			copy(dAtA[i:], x.BondReward)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BondReward)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRewards)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRewards: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRewards: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BondReward", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BondReward = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolRewards", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PoolRewards = append(x.PoolRewards, &PoolAmt{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PoolRewards[len(x.PoolRewards)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DevFundReward", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DevFundReward = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IncomeBurn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.IncomeBurn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TcyStakeReward", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TcyStakeReward = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventRefund        protoreflect.MessageDescriptor
	fd_EventRefund_code   protoreflect.FieldDescriptor
	fd_EventRefund_reason protoreflect.FieldDescriptor
	fd_EventRefund_in_tx  protoreflect.FieldDescriptor
	fd_EventRefund_fee    protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventRefund = File_types_type_events_proto.Messages().ByName("EventRefund")
	fd_EventRefund_code = md_EventRefund.Fields().ByName("code")
	fd_EventRefund_reason = md_EventRefund.Fields().ByName("reason")
	fd_EventRefund_in_tx = md_EventRefund.Fields().ByName("in_tx")
	fd_EventRefund_fee = md_EventRefund.Fields().ByName("fee")
}

var _ protoreflect.Message = (*fastReflection_EventRefund)(nil)

type fastReflection_EventRefund EventRefund

func (x *EventRefund) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRefund)(x)
}

func (x *EventRefund) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRefund_messageType fastReflection_EventRefund_messageType
var _ protoreflect.MessageType = fastReflection_EventRefund_messageType{}

type fastReflection_EventRefund_messageType struct{}

func (x fastReflection_EventRefund_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRefund)(nil)
}
func (x fastReflection_EventRefund_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRefund)
}
func (x fastReflection_EventRefund_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRefund
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRefund) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRefund
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRefund) Type() protoreflect.MessageType {
	return _fastReflection_EventRefund_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRefund) New() protoreflect.Message {
	return new(fastReflection_EventRefund)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRefund) Interface() protoreflect.ProtoMessage {
	return (*EventRefund)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRefund) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Code != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Code)
		if !f(fd_EventRefund_code, value) {
			return
		}
	}
	if x.Reason != "" {
		value := protoreflect.ValueOfString(x.Reason)
		if !f(fd_EventRefund_reason, value) {
			return
		}
	}
	if x.InTx != nil {
		value := protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
		if !f(fd_EventRefund_in_tx, value) {
			return
		}
	}
	if x.Fee != nil {
		value := protoreflect.ValueOfMessage(x.Fee.ProtoReflect())
		if !f(fd_EventRefund_fee, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRefund) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventRefund.code":
		return x.Code != uint32(0)
	case "types.EventRefund.reason":
		return x.Reason != ""
	case "types.EventRefund.in_tx":
		return x.InTx != nil
	case "types.EventRefund.fee":
		return x.Fee != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRefund) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventRefund.code":
		x.Code = uint32(0)
	case "types.EventRefund.reason":
		x.Reason = ""
	case "types.EventRefund.in_tx":
		x.InTx = nil
	case "types.EventRefund.fee":
		x.Fee = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRefund) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventRefund.code":
		value := x.Code
		return protoreflect.ValueOfUint32(value)
	case "types.EventRefund.reason":
		value := x.Reason
		return protoreflect.ValueOfString(value)
	case "types.EventRefund.in_tx":
		value := x.InTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventRefund.fee":
		value := x.Fee
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRefund) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventRefund.code":
		x.Code = uint32(value.Uint())
	case "types.EventRefund.reason":
		x.Reason = value.Interface().(string)
	case "types.EventRefund.in_tx":
		x.InTx = value.Message().Interface().(*common.Tx)
	case "types.EventRefund.fee":
		x.Fee = value.Message().Interface().(*common.Fee)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRefund) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRefund.in_tx":
		if x.InTx == nil {
			x.InTx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
	case "types.EventRefund.fee":
		if x.Fee == nil {
			x.Fee = new(common.Fee)
		}
		return protoreflect.ValueOfMessage(x.Fee.ProtoReflect())
	case "types.EventRefund.code":
		panic(fmt.Errorf("field code of message types.EventRefund is not mutable"))
	case "types.EventRefund.reason":
		panic(fmt.Errorf("field reason of message types.EventRefund is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRefund) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRefund.code":
		return protoreflect.ValueOfUint32(uint32(0))
	case "types.EventRefund.reason":
		return protoreflect.ValueOfString("")
	case "types.EventRefund.in_tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventRefund.fee":
		m := new(common.Fee)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRefund"))
		}
		panic(fmt.Errorf("message types.EventRefund does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRefund) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventRefund", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRefund) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRefund) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRefund) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRefund) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRefund)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Code != 0 {
			n += 1 + runtime.Sov(uint64(x.Code))
		}
		l = len(x.Reason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InTx != nil {
			l = options.Size(x.InTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Fee != nil {
			l = options.Size(x.Fee)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRefund)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Fee != nil {
			encoded, err := options.Marshal(x.Fee)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if x.InTx != nil {
			encoded, err := options.Marshal(x.InTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Reason) > 0 {
			i -= len(x.Reason)
			copy(dAtA[i:], x.Reason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Reason)))
			i--
			dAtA[i] = 0x12
		}
		if x.Code != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Code))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRefund)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRefund: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRefund: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
				}
				x.Code = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Code |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Reason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InTx == nil {
					x.InTx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Fee == nil {
					x.Fee = &common.Fee{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Fee); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventBond              protoreflect.MessageDescriptor
	fd_EventBond_amount       protoreflect.FieldDescriptor
	fd_EventBond_bond_type    protoreflect.FieldDescriptor
	fd_EventBond_tx_in        protoreflect.FieldDescriptor
	fd_EventBond_node_address protoreflect.FieldDescriptor
	fd_EventBond_bond_address protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventBond = File_types_type_events_proto.Messages().ByName("EventBond")
	fd_EventBond_amount = md_EventBond.Fields().ByName("amount")
	fd_EventBond_bond_type = md_EventBond.Fields().ByName("bond_type")
	fd_EventBond_tx_in = md_EventBond.Fields().ByName("tx_in")
	fd_EventBond_node_address = md_EventBond.Fields().ByName("node_address")
	fd_EventBond_bond_address = md_EventBond.Fields().ByName("bond_address")
}

var _ protoreflect.Message = (*fastReflection_EventBond)(nil)

type fastReflection_EventBond EventBond

func (x *EventBond) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventBond)(x)
}

func (x *EventBond) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventBond_messageType fastReflection_EventBond_messageType
var _ protoreflect.MessageType = fastReflection_EventBond_messageType{}

type fastReflection_EventBond_messageType struct{}

func (x fastReflection_EventBond_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventBond)(nil)
}
func (x fastReflection_EventBond_messageType) New() protoreflect.Message {
	return new(fastReflection_EventBond)
}
func (x fastReflection_EventBond_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventBond
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventBond) Descriptor() protoreflect.MessageDescriptor {
	return md_EventBond
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventBond) Type() protoreflect.MessageType {
	return _fastReflection_EventBond_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventBond) New() protoreflect.Message {
	return new(fastReflection_EventBond)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventBond) Interface() protoreflect.ProtoMessage {
	return (*EventBond)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventBond) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventBond_amount, value) {
			return
		}
	}
	if x.BondType != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.BondType))
		if !f(fd_EventBond_bond_type, value) {
			return
		}
	}
	if x.TxIn != nil {
		value := protoreflect.ValueOfMessage(x.TxIn.ProtoReflect())
		if !f(fd_EventBond_tx_in, value) {
			return
		}
	}
	if len(x.NodeAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.NodeAddress)
		if !f(fd_EventBond_node_address, value) {
			return
		}
	}
	if len(x.BondAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.BondAddress)
		if !f(fd_EventBond_bond_address, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventBond) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventBond.amount":
		return x.Amount != ""
	case "types.EventBond.bond_type":
		return x.BondType != 0
	case "types.EventBond.tx_in":
		return x.TxIn != nil
	case "types.EventBond.node_address":
		return len(x.NodeAddress) != 0
	case "types.EventBond.bond_address":
		return len(x.BondAddress) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventBond) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventBond.amount":
		x.Amount = ""
	case "types.EventBond.bond_type":
		x.BondType = 0
	case "types.EventBond.tx_in":
		x.TxIn = nil
	case "types.EventBond.node_address":
		x.NodeAddress = nil
	case "types.EventBond.bond_address":
		x.BondAddress = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventBond) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventBond.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventBond.bond_type":
		value := x.BondType
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "types.EventBond.tx_in":
		value := x.TxIn
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventBond.node_address":
		value := x.NodeAddress
		return protoreflect.ValueOfBytes(value)
	case "types.EventBond.bond_address":
		value := x.BondAddress
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventBond) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventBond.amount":
		x.Amount = value.Interface().(string)
	case "types.EventBond.bond_type":
		x.BondType = (BondType)(value.Enum())
	case "types.EventBond.tx_in":
		x.TxIn = value.Message().Interface().(*common.Tx)
	case "types.EventBond.node_address":
		x.NodeAddress = value.Bytes()
	case "types.EventBond.bond_address":
		x.BondAddress = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventBond) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventBond.tx_in":
		if x.TxIn == nil {
			x.TxIn = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.TxIn.ProtoReflect())
	case "types.EventBond.amount":
		panic(fmt.Errorf("field amount of message types.EventBond is not mutable"))
	case "types.EventBond.bond_type":
		panic(fmt.Errorf("field bond_type of message types.EventBond is not mutable"))
	case "types.EventBond.node_address":
		panic(fmt.Errorf("field node_address of message types.EventBond is not mutable"))
	case "types.EventBond.bond_address":
		panic(fmt.Errorf("field bond_address of message types.EventBond is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventBond) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventBond.amount":
		return protoreflect.ValueOfString("")
	case "types.EventBond.bond_type":
		return protoreflect.ValueOfEnum(0)
	case "types.EventBond.tx_in":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventBond.node_address":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventBond.bond_address":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventBond"))
		}
		panic(fmt.Errorf("message types.EventBond does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventBond) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventBond", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventBond) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventBond) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventBond) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventBond) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventBond)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BondType != 0 {
			n += 1 + runtime.Sov(uint64(x.BondType))
		}
		if x.TxIn != nil {
			l = options.Size(x.TxIn)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NodeAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BondAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventBond)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.BondAddress) > 0 {
			i -= len(x.BondAddress)
			copy(dAtA[i:], x.BondAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BondAddress)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.NodeAddress) > 0 {
			i -= len(x.NodeAddress)
			copy(dAtA[i:], x.NodeAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NodeAddress)))
			i--
			dAtA[i] = 0x22
		}
		if x.TxIn != nil {
			encoded, err := options.Marshal(x.TxIn)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.BondType != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BondType))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventBond)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventBond: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventBond: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BondType", wireType)
				}
				x.BondType = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BondType |= BondType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TxIn == nil {
					x.TxIn = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TxIn); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NodeAddress = append(x.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.NodeAddress == nil {
					x.NodeAddress = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BondAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BondAddress = append(x.BondAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.BondAddress == nil {
					x.BondAddress = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_GasPool           protoreflect.MessageDescriptor
	fd_GasPool_asset     protoreflect.FieldDescriptor
	fd_GasPool_rune_amt  protoreflect.FieldDescriptor
	fd_GasPool_asset_amt protoreflect.FieldDescriptor
	fd_GasPool_count     protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_GasPool = File_types_type_events_proto.Messages().ByName("GasPool")
	fd_GasPool_asset = md_GasPool.Fields().ByName("asset")
	fd_GasPool_rune_amt = md_GasPool.Fields().ByName("rune_amt")
	fd_GasPool_asset_amt = md_GasPool.Fields().ByName("asset_amt")
	fd_GasPool_count = md_GasPool.Fields().ByName("count")
}

var _ protoreflect.Message = (*fastReflection_GasPool)(nil)

type fastReflection_GasPool GasPool

func (x *GasPool) ProtoReflect() protoreflect.Message {
	return (*fastReflection_GasPool)(x)
}

func (x *GasPool) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_GasPool_messageType fastReflection_GasPool_messageType
var _ protoreflect.MessageType = fastReflection_GasPool_messageType{}

type fastReflection_GasPool_messageType struct{}

func (x fastReflection_GasPool_messageType) Zero() protoreflect.Message {
	return (*fastReflection_GasPool)(nil)
}
func (x fastReflection_GasPool_messageType) New() protoreflect.Message {
	return new(fastReflection_GasPool)
}
func (x fastReflection_GasPool_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_GasPool
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_GasPool) Descriptor() protoreflect.MessageDescriptor {
	return md_GasPool
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_GasPool) Type() protoreflect.MessageType {
	return _fastReflection_GasPool_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_GasPool) New() protoreflect.Message {
	return new(fastReflection_GasPool)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_GasPool) Interface() protoreflect.ProtoMessage {
	return (*GasPool)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_GasPool) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_GasPool_asset, value) {
			return
		}
	}
	if x.RuneAmt != "" {
		value := protoreflect.ValueOfString(x.RuneAmt)
		if !f(fd_GasPool_rune_amt, value) {
			return
		}
	}
	if x.AssetAmt != "" {
		value := protoreflect.ValueOfString(x.AssetAmt)
		if !f(fd_GasPool_asset_amt, value) {
			return
		}
	}
	if x.Count != int64(0) {
		value := protoreflect.ValueOfInt64(x.Count)
		if !f(fd_GasPool_count, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_GasPool) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.GasPool.asset":
		return x.Asset != nil
	case "types.GasPool.rune_amt":
		return x.RuneAmt != ""
	case "types.GasPool.asset_amt":
		return x.AssetAmt != ""
	case "types.GasPool.count":
		return x.Count != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GasPool) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.GasPool.asset":
		x.Asset = nil
	case "types.GasPool.rune_amt":
		x.RuneAmt = ""
	case "types.GasPool.asset_amt":
		x.AssetAmt = ""
	case "types.GasPool.count":
		x.Count = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_GasPool) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.GasPool.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.GasPool.rune_amt":
		value := x.RuneAmt
		return protoreflect.ValueOfString(value)
	case "types.GasPool.asset_amt":
		value := x.AssetAmt
		return protoreflect.ValueOfString(value)
	case "types.GasPool.count":
		value := x.Count
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GasPool) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.GasPool.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.GasPool.rune_amt":
		x.RuneAmt = value.Interface().(string)
	case "types.GasPool.asset_amt":
		x.AssetAmt = value.Interface().(string)
	case "types.GasPool.count":
		x.Count = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GasPool) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.GasPool.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.GasPool.rune_amt":
		panic(fmt.Errorf("field rune_amt of message types.GasPool is not mutable"))
	case "types.GasPool.asset_amt":
		panic(fmt.Errorf("field asset_amt of message types.GasPool is not mutable"))
	case "types.GasPool.count":
		panic(fmt.Errorf("field count of message types.GasPool is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_GasPool) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.GasPool.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.GasPool.rune_amt":
		return protoreflect.ValueOfString("")
	case "types.GasPool.asset_amt":
		return protoreflect.ValueOfString("")
	case "types.GasPool.count":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.GasPool"))
		}
		panic(fmt.Errorf("message types.GasPool does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_GasPool) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.GasPool", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_GasPool) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_GasPool) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_GasPool) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_GasPool) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*GasPool)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAmt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Count != 0 {
			n += 1 + runtime.Sov(uint64(x.Count))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*GasPool)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Count != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Count))
			i--
			dAtA[i] = 0x20
		}
		if len(x.AssetAmt) > 0 {
			i -= len(x.AssetAmt)
			copy(dAtA[i:], x.AssetAmt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAmt)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.RuneAmt) > 0 {
			i -= len(x.RuneAmt)
			copy(dAtA[i:], x.RuneAmt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmt)))
			i--
			dAtA[i] = 0x12
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*GasPool)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GasPool: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: GasPool: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAmt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAmt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
				}
				x.Count = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Count |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventGas_1_list)(nil)

type _EventGas_1_list struct {
	list *[]*GasPool
}

func (x *_EventGas_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventGas_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_EventGas_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*GasPool)
	(*x.list)[i] = concreteValue
}

func (x *_EventGas_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*GasPool)
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventGas_1_list) AppendMutable() protoreflect.Value {
	v := new(GasPool)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventGas_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_EventGas_1_list) NewElement() protoreflect.Value {
	v := new(GasPool)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventGas_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventGas       protoreflect.MessageDescriptor
	fd_EventGas_pools protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventGas = File_types_type_events_proto.Messages().ByName("EventGas")
	fd_EventGas_pools = md_EventGas.Fields().ByName("pools")
}

var _ protoreflect.Message = (*fastReflection_EventGas)(nil)

type fastReflection_EventGas EventGas

func (x *EventGas) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventGas)(x)
}

func (x *EventGas) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventGas_messageType fastReflection_EventGas_messageType
var _ protoreflect.MessageType = fastReflection_EventGas_messageType{}

type fastReflection_EventGas_messageType struct{}

func (x fastReflection_EventGas_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventGas)(nil)
}
func (x fastReflection_EventGas_messageType) New() protoreflect.Message {
	return new(fastReflection_EventGas)
}
func (x fastReflection_EventGas_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventGas
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventGas) Descriptor() protoreflect.MessageDescriptor {
	return md_EventGas
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventGas) Type() protoreflect.MessageType {
	return _fastReflection_EventGas_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventGas) New() protoreflect.Message {
	return new(fastReflection_EventGas)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventGas) Interface() protoreflect.ProtoMessage {
	return (*EventGas)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventGas) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Pools) != 0 {
		value := protoreflect.ValueOfList(&_EventGas_1_list{list: &x.Pools})
		if !f(fd_EventGas_pools, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventGas) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventGas.pools":
		return len(x.Pools) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventGas) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventGas.pools":
		x.Pools = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventGas) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventGas.pools":
		if len(x.Pools) == 0 {
			return protoreflect.ValueOfList(&_EventGas_1_list{})
		}
		listValue := &_EventGas_1_list{list: &x.Pools}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventGas) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventGas.pools":
		lv := value.List()
		clv := lv.(*_EventGas_1_list)
		x.Pools = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventGas) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventGas.pools":
		if x.Pools == nil {
			x.Pools = []*GasPool{}
		}
		value := &_EventGas_1_list{list: &x.Pools}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventGas) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventGas.pools":
		list := []*GasPool{}
		return protoreflect.ValueOfList(&_EventGas_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventGas"))
		}
		panic(fmt.Errorf("message types.EventGas does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventGas) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventGas", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventGas) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventGas) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventGas) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventGas) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventGas)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Pools) > 0 {
			for _, e := range x.Pools {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventGas)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Pools) > 0 {
			for iNdEx := len(x.Pools) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Pools[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventGas)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventGas: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventGas: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Pools = append(x.Pools, &GasPool{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pools[len(x.Pools)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventReserve                     protoreflect.MessageDescriptor
	fd_EventReserve_reserve_contributor protoreflect.FieldDescriptor
	fd_EventReserve_in_tx               protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventReserve = File_types_type_events_proto.Messages().ByName("EventReserve")
	fd_EventReserve_reserve_contributor = md_EventReserve.Fields().ByName("reserve_contributor")
	fd_EventReserve_in_tx = md_EventReserve.Fields().ByName("in_tx")
}

var _ protoreflect.Message = (*fastReflection_EventReserve)(nil)

type fastReflection_EventReserve EventReserve

func (x *EventReserve) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventReserve)(x)
}

func (x *EventReserve) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventReserve_messageType fastReflection_EventReserve_messageType
var _ protoreflect.MessageType = fastReflection_EventReserve_messageType{}

type fastReflection_EventReserve_messageType struct{}

func (x fastReflection_EventReserve_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventReserve)(nil)
}
func (x fastReflection_EventReserve_messageType) New() protoreflect.Message {
	return new(fastReflection_EventReserve)
}
func (x fastReflection_EventReserve_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventReserve
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventReserve) Descriptor() protoreflect.MessageDescriptor {
	return md_EventReserve
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventReserve) Type() protoreflect.MessageType {
	return _fastReflection_EventReserve_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventReserve) New() protoreflect.Message {
	return new(fastReflection_EventReserve)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventReserve) Interface() protoreflect.ProtoMessage {
	return (*EventReserve)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventReserve) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ReserveContributor != nil {
		value := protoreflect.ValueOfMessage(x.ReserveContributor.ProtoReflect())
		if !f(fd_EventReserve_reserve_contributor, value) {
			return
		}
	}
	if x.InTx != nil {
		value := protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
		if !f(fd_EventReserve_in_tx, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventReserve) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventReserve.reserve_contributor":
		return x.ReserveContributor != nil
	case "types.EventReserve.in_tx":
		return x.InTx != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventReserve) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventReserve.reserve_contributor":
		x.ReserveContributor = nil
	case "types.EventReserve.in_tx":
		x.InTx = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventReserve) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventReserve.reserve_contributor":
		value := x.ReserveContributor
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventReserve.in_tx":
		value := x.InTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventReserve) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventReserve.reserve_contributor":
		x.ReserveContributor = value.Message().Interface().(*ReserveContributor)
	case "types.EventReserve.in_tx":
		x.InTx = value.Message().Interface().(*common.Tx)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventReserve) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventReserve.reserve_contributor":
		if x.ReserveContributor == nil {
			x.ReserveContributor = new(ReserveContributor)
		}
		return protoreflect.ValueOfMessage(x.ReserveContributor.ProtoReflect())
	case "types.EventReserve.in_tx":
		if x.InTx == nil {
			x.InTx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.InTx.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventReserve) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventReserve.reserve_contributor":
		m := new(ReserveContributor)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventReserve.in_tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventReserve"))
		}
		panic(fmt.Errorf("message types.EventReserve does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventReserve) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventReserve", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventReserve) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventReserve) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventReserve) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventReserve) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventReserve)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.ReserveContributor != nil {
			l = options.Size(x.ReserveContributor)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.InTx != nil {
			l = options.Size(x.InTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventReserve)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.InTx != nil {
			encoded, err := options.Marshal(x.InTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.ReserveContributor != nil {
			encoded, err := options.Marshal(x.ReserveContributor)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventReserve)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventReserve: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventReserve: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ReserveContributor", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ReserveContributor == nil {
					x.ReserveContributor = &ReserveContributor{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ReserveContributor); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.InTx == nil {
					x.InTx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.InTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventScheduledOutbound        protoreflect.MessageDescriptor
	fd_EventScheduledOutbound_out_tx protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventScheduledOutbound = File_types_type_events_proto.Messages().ByName("EventScheduledOutbound")
	fd_EventScheduledOutbound_out_tx = md_EventScheduledOutbound.Fields().ByName("out_tx")
}

var _ protoreflect.Message = (*fastReflection_EventScheduledOutbound)(nil)

type fastReflection_EventScheduledOutbound EventScheduledOutbound

func (x *EventScheduledOutbound) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventScheduledOutbound)(x)
}

func (x *EventScheduledOutbound) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventScheduledOutbound_messageType fastReflection_EventScheduledOutbound_messageType
var _ protoreflect.MessageType = fastReflection_EventScheduledOutbound_messageType{}

type fastReflection_EventScheduledOutbound_messageType struct{}

func (x fastReflection_EventScheduledOutbound_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventScheduledOutbound)(nil)
}
func (x fastReflection_EventScheduledOutbound_messageType) New() protoreflect.Message {
	return new(fastReflection_EventScheduledOutbound)
}
func (x fastReflection_EventScheduledOutbound_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventScheduledOutbound
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventScheduledOutbound) Descriptor() protoreflect.MessageDescriptor {
	return md_EventScheduledOutbound
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventScheduledOutbound) Type() protoreflect.MessageType {
	return _fastReflection_EventScheduledOutbound_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventScheduledOutbound) New() protoreflect.Message {
	return new(fastReflection_EventScheduledOutbound)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventScheduledOutbound) Interface() protoreflect.ProtoMessage {
	return (*EventScheduledOutbound)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventScheduledOutbound) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.OutTx != nil {
		value := protoreflect.ValueOfMessage(x.OutTx.ProtoReflect())
		if !f(fd_EventScheduledOutbound_out_tx, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventScheduledOutbound) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		return x.OutTx != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventScheduledOutbound) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		x.OutTx = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventScheduledOutbound) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		value := x.OutTx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventScheduledOutbound) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		x.OutTx = value.Message().Interface().(*TxOutItem)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventScheduledOutbound) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		if x.OutTx == nil {
			x.OutTx = new(TxOutItem)
		}
		return protoreflect.ValueOfMessage(x.OutTx.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventScheduledOutbound) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventScheduledOutbound.out_tx":
		m := new(TxOutItem)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventScheduledOutbound"))
		}
		panic(fmt.Errorf("message types.EventScheduledOutbound does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventScheduledOutbound) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventScheduledOutbound", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventScheduledOutbound) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventScheduledOutbound) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventScheduledOutbound) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventScheduledOutbound) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventScheduledOutbound)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.OutTx != nil {
			l = options.Size(x.OutTx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventScheduledOutbound)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.OutTx != nil {
			encoded, err := options.Marshal(x.OutTx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventScheduledOutbound)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventScheduledOutbound: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventScheduledOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OutTx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.OutTx == nil {
					x.OutTx = &TxOutItem{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.OutTx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSecurity     protoreflect.MessageDescriptor
	fd_EventSecurity_msg protoreflect.FieldDescriptor
	fd_EventSecurity_tx  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSecurity = File_types_type_events_proto.Messages().ByName("EventSecurity")
	fd_EventSecurity_msg = md_EventSecurity.Fields().ByName("msg")
	fd_EventSecurity_tx = md_EventSecurity.Fields().ByName("tx")
}

var _ protoreflect.Message = (*fastReflection_EventSecurity)(nil)

type fastReflection_EventSecurity EventSecurity

func (x *EventSecurity) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSecurity)(x)
}

func (x *EventSecurity) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSecurity_messageType fastReflection_EventSecurity_messageType
var _ protoreflect.MessageType = fastReflection_EventSecurity_messageType{}

type fastReflection_EventSecurity_messageType struct{}

func (x fastReflection_EventSecurity_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSecurity)(nil)
}
func (x fastReflection_EventSecurity_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSecurity)
}
func (x fastReflection_EventSecurity_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecurity
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSecurity) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecurity
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSecurity) Type() protoreflect.MessageType {
	return _fastReflection_EventSecurity_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSecurity) New() protoreflect.Message {
	return new(fastReflection_EventSecurity)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSecurity) Interface() protoreflect.ProtoMessage {
	return (*EventSecurity)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSecurity) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Msg != "" {
		value := protoreflect.ValueOfString(x.Msg)
		if !f(fd_EventSecurity_msg, value) {
			return
		}
	}
	if x.Tx != nil {
		value := protoreflect.ValueOfMessage(x.Tx.ProtoReflect())
		if !f(fd_EventSecurity_tx, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSecurity) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSecurity.msg":
		return x.Msg != ""
	case "types.EventSecurity.tx":
		return x.Tx != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecurity) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSecurity.msg":
		x.Msg = ""
	case "types.EventSecurity.tx":
		x.Tx = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSecurity) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSecurity.msg":
		value := x.Msg
		return protoreflect.ValueOfString(value)
	case "types.EventSecurity.tx":
		value := x.Tx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecurity) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSecurity.msg":
		x.Msg = value.Interface().(string)
	case "types.EventSecurity.tx":
		x.Tx = value.Message().Interface().(*common.Tx)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecurity) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecurity.tx":
		if x.Tx == nil {
			x.Tx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.Tx.ProtoReflect())
	case "types.EventSecurity.msg":
		panic(fmt.Errorf("field msg of message types.EventSecurity is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSecurity) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecurity.msg":
		return protoreflect.ValueOfString("")
	case "types.EventSecurity.tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecurity"))
		}
		panic(fmt.Errorf("message types.EventSecurity does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSecurity) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSecurity", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSecurity) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecurity) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSecurity) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSecurity) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSecurity)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Msg)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Tx != nil {
			l = options.Size(x.Tx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSecurity)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Tx != nil {
			encoded, err := options.Marshal(x.Tx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Msg) > 0 {
			i -= len(x.Msg)
			copy(dAtA[i:], x.Msg)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Msg)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSecurity)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecurity: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecurity: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Msg = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Tx == nil {
					x.Tx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Tx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventSlash_2_list)(nil)

type _EventSlash_2_list struct {
	list *[]*PoolAmt
}

func (x *_EventSlash_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventSlash_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_EventSlash_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolAmt)
	(*x.list)[i] = concreteValue
}

func (x *_EventSlash_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolAmt)
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventSlash_2_list) AppendMutable() protoreflect.Value {
	v := new(PoolAmt)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventSlash_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_EventSlash_2_list) NewElement() protoreflect.Value {
	v := new(PoolAmt)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventSlash_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventSlash              protoreflect.MessageDescriptor
	fd_EventSlash_pool         protoreflect.FieldDescriptor
	fd_EventSlash_slash_amount protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSlash = File_types_type_events_proto.Messages().ByName("EventSlash")
	fd_EventSlash_pool = md_EventSlash.Fields().ByName("pool")
	fd_EventSlash_slash_amount = md_EventSlash.Fields().ByName("slash_amount")
}

var _ protoreflect.Message = (*fastReflection_EventSlash)(nil)

type fastReflection_EventSlash EventSlash

func (x *EventSlash) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSlash)(x)
}

func (x *EventSlash) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSlash_messageType fastReflection_EventSlash_messageType
var _ protoreflect.MessageType = fastReflection_EventSlash_messageType{}

type fastReflection_EventSlash_messageType struct{}

func (x fastReflection_EventSlash_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSlash)(nil)
}
func (x fastReflection_EventSlash_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSlash)
}
func (x fastReflection_EventSlash_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSlash
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSlash) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSlash
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSlash) Type() protoreflect.MessageType {
	return _fastReflection_EventSlash_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSlash) New() protoreflect.Message {
	return new(fastReflection_EventSlash)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSlash) Interface() protoreflect.ProtoMessage {
	return (*EventSlash)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSlash) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Pool != nil {
		value := protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
		if !f(fd_EventSlash_pool, value) {
			return
		}
	}
	if len(x.SlashAmount) != 0 {
		value := protoreflect.ValueOfList(&_EventSlash_2_list{list: &x.SlashAmount})
		if !f(fd_EventSlash_slash_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSlash) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSlash.pool":
		return x.Pool != nil
	case "types.EventSlash.slash_amount":
		return len(x.SlashAmount) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlash) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSlash.pool":
		x.Pool = nil
	case "types.EventSlash.slash_amount":
		x.SlashAmount = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSlash) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSlash.pool":
		value := x.Pool
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSlash.slash_amount":
		if len(x.SlashAmount) == 0 {
			return protoreflect.ValueOfList(&_EventSlash_2_list{})
		}
		listValue := &_EventSlash_2_list{list: &x.SlashAmount}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlash) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSlash.pool":
		x.Pool = value.Message().Interface().(*common.Asset)
	case "types.EventSlash.slash_amount":
		lv := value.List()
		clv := lv.(*_EventSlash_2_list)
		x.SlashAmount = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlash) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSlash.pool":
		if x.Pool == nil {
			x.Pool = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Pool.ProtoReflect())
	case "types.EventSlash.slash_amount":
		if x.SlashAmount == nil {
			x.SlashAmount = []*PoolAmt{}
		}
		value := &_EventSlash_2_list{list: &x.SlashAmount}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSlash) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSlash.pool":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSlash.slash_amount":
		list := []*PoolAmt{}
		return protoreflect.ValueOfList(&_EventSlash_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlash"))
		}
		panic(fmt.Errorf("message types.EventSlash does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSlash) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSlash", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSlash) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlash) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSlash) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSlash) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSlash)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Pool != nil {
			l = options.Size(x.Pool)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.SlashAmount) > 0 {
			for _, e := range x.SlashAmount {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSlash)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SlashAmount) > 0 {
			for iNdEx := len(x.SlashAmount) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.SlashAmount[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if x.Pool != nil {
			encoded, err := options.Marshal(x.Pool)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSlash)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSlash: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSlash: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pool == nil {
					x.Pool = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pool); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SlashAmount", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SlashAmount = append(x.SlashAmount, &PoolAmt{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SlashAmount[len(x.SlashAmount)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventErrata_2_list)(nil)

type _EventErrata_2_list struct {
	list *[]*PoolMod
}

func (x *_EventErrata_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventErrata_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_EventErrata_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolMod)
	(*x.list)[i] = concreteValue
}

func (x *_EventErrata_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*PoolMod)
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventErrata_2_list) AppendMutable() protoreflect.Value {
	v := new(PoolMod)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventErrata_2_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_EventErrata_2_list) NewElement() protoreflect.Value {
	v := new(PoolMod)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EventErrata_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventErrata       protoreflect.MessageDescriptor
	fd_EventErrata_tx_id protoreflect.FieldDescriptor
	fd_EventErrata_pools protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventErrata = File_types_type_events_proto.Messages().ByName("EventErrata")
	fd_EventErrata_tx_id = md_EventErrata.Fields().ByName("tx_id")
	fd_EventErrata_pools = md_EventErrata.Fields().ByName("pools")
}

var _ protoreflect.Message = (*fastReflection_EventErrata)(nil)

type fastReflection_EventErrata EventErrata

func (x *EventErrata) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventErrata)(x)
}

func (x *EventErrata) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventErrata_messageType fastReflection_EventErrata_messageType
var _ protoreflect.MessageType = fastReflection_EventErrata_messageType{}

type fastReflection_EventErrata_messageType struct{}

func (x fastReflection_EventErrata_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventErrata)(nil)
}
func (x fastReflection_EventErrata_messageType) New() protoreflect.Message {
	return new(fastReflection_EventErrata)
}
func (x fastReflection_EventErrata_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventErrata
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventErrata) Descriptor() protoreflect.MessageDescriptor {
	return md_EventErrata
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventErrata) Type() protoreflect.MessageType {
	return _fastReflection_EventErrata_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventErrata) New() protoreflect.Message {
	return new(fastReflection_EventErrata)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventErrata) Interface() protoreflect.ProtoMessage {
	return (*EventErrata)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventErrata) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventErrata_tx_id, value) {
			return
		}
	}
	if len(x.Pools) != 0 {
		value := protoreflect.ValueOfList(&_EventErrata_2_list{list: &x.Pools})
		if !f(fd_EventErrata_pools, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventErrata) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventErrata.tx_id":
		return x.TxId != ""
	case "types.EventErrata.pools":
		return len(x.Pools) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventErrata) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventErrata.tx_id":
		x.TxId = ""
	case "types.EventErrata.pools":
		x.Pools = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventErrata) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventErrata.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventErrata.pools":
		if len(x.Pools) == 0 {
			return protoreflect.ValueOfList(&_EventErrata_2_list{})
		}
		listValue := &_EventErrata_2_list{list: &x.Pools}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventErrata) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventErrata.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventErrata.pools":
		lv := value.List()
		clv := lv.(*_EventErrata_2_list)
		x.Pools = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventErrata) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventErrata.pools":
		if x.Pools == nil {
			x.Pools = []*PoolMod{}
		}
		value := &_EventErrata_2_list{list: &x.Pools}
		return protoreflect.ValueOfList(value)
	case "types.EventErrata.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventErrata is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventErrata) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventErrata.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventErrata.pools":
		list := []*PoolMod{}
		return protoreflect.ValueOfList(&_EventErrata_2_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventErrata"))
		}
		panic(fmt.Errorf("message types.EventErrata does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventErrata) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventErrata", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventErrata) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventErrata) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventErrata) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventErrata) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventErrata)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Pools) > 0 {
			for _, e := range x.Pools {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventErrata)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Pools) > 0 {
			for iNdEx := len(x.Pools) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Pools[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventErrata)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventErrata: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventErrata: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Pools = append(x.Pools, &PoolMod{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Pools[len(x.Pools)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventFee             protoreflect.MessageDescriptor
	fd_EventFee_tx_id       protoreflect.FieldDescriptor
	fd_EventFee_fee         protoreflect.FieldDescriptor
	fd_EventFee_synth_units protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventFee = File_types_type_events_proto.Messages().ByName("EventFee")
	fd_EventFee_tx_id = md_EventFee.Fields().ByName("tx_id")
	fd_EventFee_fee = md_EventFee.Fields().ByName("fee")
	fd_EventFee_synth_units = md_EventFee.Fields().ByName("synth_units")
}

var _ protoreflect.Message = (*fastReflection_EventFee)(nil)

type fastReflection_EventFee EventFee

func (x *EventFee) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventFee)(x)
}

func (x *EventFee) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventFee_messageType fastReflection_EventFee_messageType
var _ protoreflect.MessageType = fastReflection_EventFee_messageType{}

type fastReflection_EventFee_messageType struct{}

func (x fastReflection_EventFee_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventFee)(nil)
}
func (x fastReflection_EventFee_messageType) New() protoreflect.Message {
	return new(fastReflection_EventFee)
}
func (x fastReflection_EventFee_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventFee
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventFee) Descriptor() protoreflect.MessageDescriptor {
	return md_EventFee
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventFee) Type() protoreflect.MessageType {
	return _fastReflection_EventFee_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventFee) New() protoreflect.Message {
	return new(fastReflection_EventFee)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventFee) Interface() protoreflect.ProtoMessage {
	return (*EventFee)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventFee) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventFee_tx_id, value) {
			return
		}
	}
	if x.Fee != nil {
		value := protoreflect.ValueOfMessage(x.Fee.ProtoReflect())
		if !f(fd_EventFee_fee, value) {
			return
		}
	}
	if x.SynthUnits != "" {
		value := protoreflect.ValueOfString(x.SynthUnits)
		if !f(fd_EventFee_synth_units, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventFee) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventFee.tx_id":
		return x.TxId != ""
	case "types.EventFee.fee":
		return x.Fee != nil
	case "types.EventFee.synth_units":
		return x.SynthUnits != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFee) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventFee.tx_id":
		x.TxId = ""
	case "types.EventFee.fee":
		x.Fee = nil
	case "types.EventFee.synth_units":
		x.SynthUnits = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventFee) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventFee.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventFee.fee":
		value := x.Fee
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventFee.synth_units":
		value := x.SynthUnits
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFee) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventFee.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventFee.fee":
		x.Fee = value.Message().Interface().(*common.Fee)
	case "types.EventFee.synth_units":
		x.SynthUnits = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFee) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventFee.fee":
		if x.Fee == nil {
			x.Fee = new(common.Fee)
		}
		return protoreflect.ValueOfMessage(x.Fee.ProtoReflect())
	case "types.EventFee.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventFee is not mutable"))
	case "types.EventFee.synth_units":
		panic(fmt.Errorf("field synth_units of message types.EventFee is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventFee) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventFee.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventFee.fee":
		m := new(common.Fee)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventFee.synth_units":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventFee"))
		}
		panic(fmt.Errorf("message types.EventFee does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventFee) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventFee", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventFee) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventFee) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventFee) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventFee) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventFee)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Fee != nil {
			l = options.Size(x.Fee)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.SynthUnits)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventFee)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.SynthUnits) > 0 {
			i -= len(x.SynthUnits)
			copy(dAtA[i:], x.SynthUnits)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.SynthUnits)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Fee != nil {
			encoded, err := options.Marshal(x.Fee)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventFee)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventFee: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventFee: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Fee == nil {
					x.Fee = &common.Fee{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Fee); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SynthUnits", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.SynthUnits = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventOutbound          protoreflect.MessageDescriptor
	fd_EventOutbound_in_tx_id protoreflect.FieldDescriptor
	fd_EventOutbound_tx       protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventOutbound = File_types_type_events_proto.Messages().ByName("EventOutbound")
	fd_EventOutbound_in_tx_id = md_EventOutbound.Fields().ByName("in_tx_id")
	fd_EventOutbound_tx = md_EventOutbound.Fields().ByName("tx")
}

var _ protoreflect.Message = (*fastReflection_EventOutbound)(nil)

type fastReflection_EventOutbound EventOutbound

func (x *EventOutbound) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventOutbound)(x)
}

func (x *EventOutbound) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventOutbound_messageType fastReflection_EventOutbound_messageType
var _ protoreflect.MessageType = fastReflection_EventOutbound_messageType{}

type fastReflection_EventOutbound_messageType struct{}

func (x fastReflection_EventOutbound_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventOutbound)(nil)
}
func (x fastReflection_EventOutbound_messageType) New() protoreflect.Message {
	return new(fastReflection_EventOutbound)
}
func (x fastReflection_EventOutbound_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventOutbound
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventOutbound) Descriptor() protoreflect.MessageDescriptor {
	return md_EventOutbound
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventOutbound) Type() protoreflect.MessageType {
	return _fastReflection_EventOutbound_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventOutbound) New() protoreflect.Message {
	return new(fastReflection_EventOutbound)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventOutbound) Interface() protoreflect.ProtoMessage {
	return (*EventOutbound)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventOutbound) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.InTxId != "" {
		value := protoreflect.ValueOfString(x.InTxId)
		if !f(fd_EventOutbound_in_tx_id, value) {
			return
		}
	}
	if x.Tx != nil {
		value := protoreflect.ValueOfMessage(x.Tx.ProtoReflect())
		if !f(fd_EventOutbound_tx, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventOutbound) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventOutbound.in_tx_id":
		return x.InTxId != ""
	case "types.EventOutbound.tx":
		return x.Tx != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventOutbound) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventOutbound.in_tx_id":
		x.InTxId = ""
	case "types.EventOutbound.tx":
		x.Tx = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventOutbound) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventOutbound.in_tx_id":
		value := x.InTxId
		return protoreflect.ValueOfString(value)
	case "types.EventOutbound.tx":
		value := x.Tx
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventOutbound) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventOutbound.in_tx_id":
		x.InTxId = value.Interface().(string)
	case "types.EventOutbound.tx":
		x.Tx = value.Message().Interface().(*common.Tx)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventOutbound) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventOutbound.tx":
		if x.Tx == nil {
			x.Tx = new(common.Tx)
		}
		return protoreflect.ValueOfMessage(x.Tx.ProtoReflect())
	case "types.EventOutbound.in_tx_id":
		panic(fmt.Errorf("field in_tx_id of message types.EventOutbound is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventOutbound) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventOutbound.in_tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventOutbound.tx":
		m := new(common.Tx)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventOutbound"))
		}
		panic(fmt.Errorf("message types.EventOutbound does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventOutbound) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventOutbound", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventOutbound) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventOutbound) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventOutbound) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventOutbound) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventOutbound)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.InTxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Tx != nil {
			l = options.Size(x.Tx)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventOutbound)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Tx != nil {
			encoded, err := options.Marshal(x.Tx)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.InTxId) > 0 {
			i -= len(x.InTxId)
			copy(dAtA[i:], x.InTxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.InTxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventOutbound)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventOutbound: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventOutbound: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field InTxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.InTxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Tx == nil {
					x.Tx = &common.Tx{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Tx); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventTssKeygenSuccess_2_list)(nil)

type _EventTssKeygenSuccess_2_list struct {
	list *[]string
}

func (x *_EventTssKeygenSuccess_2_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventTssKeygenSuccess_2_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_EventTssKeygenSuccess_2_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventTssKeygenSuccess_2_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventTssKeygenSuccess_2_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventTssKeygenSuccess at list field Members as it is not of Message kind"))
}

func (x *_EventTssKeygenSuccess_2_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventTssKeygenSuccess_2_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_EventTssKeygenSuccess_2_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventTssKeygenSuccess         protoreflect.MessageDescriptor
	fd_EventTssKeygenSuccess_pub_key protoreflect.FieldDescriptor
	fd_EventTssKeygenSuccess_members protoreflect.FieldDescriptor
	fd_EventTssKeygenSuccess_height  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTssKeygenSuccess = File_types_type_events_proto.Messages().ByName("EventTssKeygenSuccess")
	fd_EventTssKeygenSuccess_pub_key = md_EventTssKeygenSuccess.Fields().ByName("pub_key")
	fd_EventTssKeygenSuccess_members = md_EventTssKeygenSuccess.Fields().ByName("members")
	fd_EventTssKeygenSuccess_height = md_EventTssKeygenSuccess.Fields().ByName("height")
}

var _ protoreflect.Message = (*fastReflection_EventTssKeygenSuccess)(nil)

type fastReflection_EventTssKeygenSuccess EventTssKeygenSuccess

func (x *EventTssKeygenSuccess) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTssKeygenSuccess)(x)
}

func (x *EventTssKeygenSuccess) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTssKeygenSuccess_messageType fastReflection_EventTssKeygenSuccess_messageType
var _ protoreflect.MessageType = fastReflection_EventTssKeygenSuccess_messageType{}

type fastReflection_EventTssKeygenSuccess_messageType struct{}

func (x fastReflection_EventTssKeygenSuccess_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTssKeygenSuccess)(nil)
}
func (x fastReflection_EventTssKeygenSuccess_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenSuccess)
}
func (x fastReflection_EventTssKeygenSuccess_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenSuccess
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTssKeygenSuccess) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenSuccess
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTssKeygenSuccess) Type() protoreflect.MessageType {
	return _fastReflection_EventTssKeygenSuccess_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTssKeygenSuccess) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenSuccess)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTssKeygenSuccess) Interface() protoreflect.ProtoMessage {
	return (*EventTssKeygenSuccess)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTssKeygenSuccess) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PubKey != "" {
		value := protoreflect.ValueOfString(x.PubKey)
		if !f(fd_EventTssKeygenSuccess_pub_key, value) {
			return
		}
	}
	if len(x.Members) != 0 {
		value := protoreflect.ValueOfList(&_EventTssKeygenSuccess_2_list{list: &x.Members})
		if !f(fd_EventTssKeygenSuccess_members, value) {
			return
		}
	}
	if x.Height != int64(0) {
		value := protoreflect.ValueOfInt64(x.Height)
		if !f(fd_EventTssKeygenSuccess_height, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTssKeygenSuccess) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTssKeygenSuccess.pub_key":
		return x.PubKey != ""
	case "types.EventTssKeygenSuccess.members":
		return len(x.Members) != 0
	case "types.EventTssKeygenSuccess.height":
		return x.Height != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenSuccess) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTssKeygenSuccess.pub_key":
		x.PubKey = ""
	case "types.EventTssKeygenSuccess.members":
		x.Members = nil
	case "types.EventTssKeygenSuccess.height":
		x.Height = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTssKeygenSuccess) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTssKeygenSuccess.pub_key":
		value := x.PubKey
		return protoreflect.ValueOfString(value)
	case "types.EventTssKeygenSuccess.members":
		if len(x.Members) == 0 {
			return protoreflect.ValueOfList(&_EventTssKeygenSuccess_2_list{})
		}
		listValue := &_EventTssKeygenSuccess_2_list{list: &x.Members}
		return protoreflect.ValueOfList(listValue)
	case "types.EventTssKeygenSuccess.height":
		value := x.Height
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenSuccess) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTssKeygenSuccess.pub_key":
		x.PubKey = value.Interface().(string)
	case "types.EventTssKeygenSuccess.members":
		lv := value.List()
		clv := lv.(*_EventTssKeygenSuccess_2_list)
		x.Members = *clv.list
	case "types.EventTssKeygenSuccess.height":
		x.Height = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenSuccess) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenSuccess.members":
		if x.Members == nil {
			x.Members = []string{}
		}
		value := &_EventTssKeygenSuccess_2_list{list: &x.Members}
		return protoreflect.ValueOfList(value)
	case "types.EventTssKeygenSuccess.pub_key":
		panic(fmt.Errorf("field pub_key of message types.EventTssKeygenSuccess is not mutable"))
	case "types.EventTssKeygenSuccess.height":
		panic(fmt.Errorf("field height of message types.EventTssKeygenSuccess is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTssKeygenSuccess) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenSuccess.pub_key":
		return protoreflect.ValueOfString("")
	case "types.EventTssKeygenSuccess.members":
		list := []string{}
		return protoreflect.ValueOfList(&_EventTssKeygenSuccess_2_list{list: &list})
	case "types.EventTssKeygenSuccess.height":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenSuccess"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenSuccess does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTssKeygenSuccess) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTssKeygenSuccess", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTssKeygenSuccess) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenSuccess) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTssKeygenSuccess) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTssKeygenSuccess) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTssKeygenSuccess)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if len(x.Members) > 0 {
			for _, s := range x.Members {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.Height != 0 {
			n += 1 + runtime.Sov(uint64(x.Height))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenSuccess)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Height != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Height))
			i--
			dAtA[i] = 0x18
		}
		if len(x.Members) > 0 {
			for iNdEx := len(x.Members) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.Members[iNdEx])
				copy(dAtA[i:], x.Members[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Members[iNdEx])))
				i--
				dAtA[i] = 0x12
			}
		}
		if len(x.PubKey) > 0 {
			i -= len(x.PubKey)
			copy(dAtA[i:], x.PubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKey)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenSuccess)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenSuccess: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Members = append(x.Members, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
				}
				x.Height = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Height |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EventTssKeygenFailure_3_list)(nil)

type _EventTssKeygenFailure_3_list struct {
	list *[]string
}

func (x *_EventTssKeygenFailure_3_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EventTssKeygenFailure_3_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_EventTssKeygenFailure_3_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EventTssKeygenFailure_3_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EventTssKeygenFailure_3_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EventTssKeygenFailure at list field BlameNodes as it is not of Message kind"))
}

func (x *_EventTssKeygenFailure_3_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EventTssKeygenFailure_3_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_EventTssKeygenFailure_3_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EventTssKeygenFailure             protoreflect.MessageDescriptor
	fd_EventTssKeygenFailure_fail_reason protoreflect.FieldDescriptor
	fd_EventTssKeygenFailure_is_unicast  protoreflect.FieldDescriptor
	fd_EventTssKeygenFailure_blame_nodes protoreflect.FieldDescriptor
	fd_EventTssKeygenFailure_round       protoreflect.FieldDescriptor
	fd_EventTssKeygenFailure_height      protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTssKeygenFailure = File_types_type_events_proto.Messages().ByName("EventTssKeygenFailure")
	fd_EventTssKeygenFailure_fail_reason = md_EventTssKeygenFailure.Fields().ByName("fail_reason")
	fd_EventTssKeygenFailure_is_unicast = md_EventTssKeygenFailure.Fields().ByName("is_unicast")
	fd_EventTssKeygenFailure_blame_nodes = md_EventTssKeygenFailure.Fields().ByName("blame_nodes")
	fd_EventTssKeygenFailure_round = md_EventTssKeygenFailure.Fields().ByName("round")
	fd_EventTssKeygenFailure_height = md_EventTssKeygenFailure.Fields().ByName("height")
}

var _ protoreflect.Message = (*fastReflection_EventTssKeygenFailure)(nil)

type fastReflection_EventTssKeygenFailure EventTssKeygenFailure

func (x *EventTssKeygenFailure) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTssKeygenFailure)(x)
}

func (x *EventTssKeygenFailure) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTssKeygenFailure_messageType fastReflection_EventTssKeygenFailure_messageType
var _ protoreflect.MessageType = fastReflection_EventTssKeygenFailure_messageType{}

type fastReflection_EventTssKeygenFailure_messageType struct{}

func (x fastReflection_EventTssKeygenFailure_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTssKeygenFailure)(nil)
}
func (x fastReflection_EventTssKeygenFailure_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenFailure)
}
func (x fastReflection_EventTssKeygenFailure_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenFailure
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTssKeygenFailure) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenFailure
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTssKeygenFailure) Type() protoreflect.MessageType {
	return _fastReflection_EventTssKeygenFailure_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTssKeygenFailure) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenFailure)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTssKeygenFailure) Interface() protoreflect.ProtoMessage {
	return (*EventTssKeygenFailure)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTssKeygenFailure) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.FailReason != "" {
		value := protoreflect.ValueOfString(x.FailReason)
		if !f(fd_EventTssKeygenFailure_fail_reason, value) {
			return
		}
	}
	if x.IsUnicast != false {
		value := protoreflect.ValueOfBool(x.IsUnicast)
		if !f(fd_EventTssKeygenFailure_is_unicast, value) {
			return
		}
	}
	if len(x.BlameNodes) != 0 {
		value := protoreflect.ValueOfList(&_EventTssKeygenFailure_3_list{list: &x.BlameNodes})
		if !f(fd_EventTssKeygenFailure_blame_nodes, value) {
			return
		}
	}
	if x.Round != "" {
		value := protoreflect.ValueOfString(x.Round)
		if !f(fd_EventTssKeygenFailure_round, value) {
			return
		}
	}
	if x.Height != int64(0) {
		value := protoreflect.ValueOfInt64(x.Height)
		if !f(fd_EventTssKeygenFailure_height, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTssKeygenFailure) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTssKeygenFailure.fail_reason":
		return x.FailReason != ""
	case "types.EventTssKeygenFailure.is_unicast":
		return x.IsUnicast != false
	case "types.EventTssKeygenFailure.blame_nodes":
		return len(x.BlameNodes) != 0
	case "types.EventTssKeygenFailure.round":
		return x.Round != ""
	case "types.EventTssKeygenFailure.height":
		return x.Height != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenFailure) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTssKeygenFailure.fail_reason":
		x.FailReason = ""
	case "types.EventTssKeygenFailure.is_unicast":
		x.IsUnicast = false
	case "types.EventTssKeygenFailure.blame_nodes":
		x.BlameNodes = nil
	case "types.EventTssKeygenFailure.round":
		x.Round = ""
	case "types.EventTssKeygenFailure.height":
		x.Height = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTssKeygenFailure) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTssKeygenFailure.fail_reason":
		value := x.FailReason
		return protoreflect.ValueOfString(value)
	case "types.EventTssKeygenFailure.is_unicast":
		value := x.IsUnicast
		return protoreflect.ValueOfBool(value)
	case "types.EventTssKeygenFailure.blame_nodes":
		if len(x.BlameNodes) == 0 {
			return protoreflect.ValueOfList(&_EventTssKeygenFailure_3_list{})
		}
		listValue := &_EventTssKeygenFailure_3_list{list: &x.BlameNodes}
		return protoreflect.ValueOfList(listValue)
	case "types.EventTssKeygenFailure.round":
		value := x.Round
		return protoreflect.ValueOfString(value)
	case "types.EventTssKeygenFailure.height":
		value := x.Height
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenFailure) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTssKeygenFailure.fail_reason":
		x.FailReason = value.Interface().(string)
	case "types.EventTssKeygenFailure.is_unicast":
		x.IsUnicast = value.Bool()
	case "types.EventTssKeygenFailure.blame_nodes":
		lv := value.List()
		clv := lv.(*_EventTssKeygenFailure_3_list)
		x.BlameNodes = *clv.list
	case "types.EventTssKeygenFailure.round":
		x.Round = value.Interface().(string)
	case "types.EventTssKeygenFailure.height":
		x.Height = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenFailure) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenFailure.blame_nodes":
		if x.BlameNodes == nil {
			x.BlameNodes = []string{}
		}
		value := &_EventTssKeygenFailure_3_list{list: &x.BlameNodes}
		return protoreflect.ValueOfList(value)
	case "types.EventTssKeygenFailure.fail_reason":
		panic(fmt.Errorf("field fail_reason of message types.EventTssKeygenFailure is not mutable"))
	case "types.EventTssKeygenFailure.is_unicast":
		panic(fmt.Errorf("field is_unicast of message types.EventTssKeygenFailure is not mutable"))
	case "types.EventTssKeygenFailure.round":
		panic(fmt.Errorf("field round of message types.EventTssKeygenFailure is not mutable"))
	case "types.EventTssKeygenFailure.height":
		panic(fmt.Errorf("field height of message types.EventTssKeygenFailure is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTssKeygenFailure) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenFailure.fail_reason":
		return protoreflect.ValueOfString("")
	case "types.EventTssKeygenFailure.is_unicast":
		return protoreflect.ValueOfBool(false)
	case "types.EventTssKeygenFailure.blame_nodes":
		list := []string{}
		return protoreflect.ValueOfList(&_EventTssKeygenFailure_3_list{list: &list})
	case "types.EventTssKeygenFailure.round":
		return protoreflect.ValueOfString("")
	case "types.EventTssKeygenFailure.height":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenFailure"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenFailure does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTssKeygenFailure) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTssKeygenFailure", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTssKeygenFailure) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenFailure) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTssKeygenFailure) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTssKeygenFailure) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTssKeygenFailure)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.FailReason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.IsUnicast {
			n += 2
		}
		if len(x.BlameNodes) > 0 {
			for _, s := range x.BlameNodes {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		l = len(x.Round)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Height != 0 {
			n += 1 + runtime.Sov(uint64(x.Height))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenFailure)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Height != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Height))
			i--
			dAtA[i] = 0x28
		}
		if len(x.Round) > 0 {
			i -= len(x.Round)
			copy(dAtA[i:], x.Round)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Round)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.BlameNodes) > 0 {
			for iNdEx := len(x.BlameNodes) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.BlameNodes[iNdEx])
				copy(dAtA[i:], x.BlameNodes[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BlameNodes[iNdEx])))
				i--
				dAtA[i] = 0x1a
			}
		}
		if x.IsUnicast {
			i--
			if x.IsUnicast {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
		}
		if len(x.FailReason) > 0 {
			i -= len(x.FailReason)
			copy(dAtA[i:], x.FailReason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FailReason)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenFailure)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenFailure: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenFailure: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FailReason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FailReason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field IsUnicast", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.IsUnicast = bool(v != 0)
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BlameNodes", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BlameNodes = append(x.BlameNodes, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Round = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
				}
				x.Height = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Height |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTssKeygenMetric                    protoreflect.MessageDescriptor
	fd_EventTssKeygenMetric_pub_key            protoreflect.FieldDescriptor
	fd_EventTssKeygenMetric_median_duration_ms protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTssKeygenMetric = File_types_type_events_proto.Messages().ByName("EventTssKeygenMetric")
	fd_EventTssKeygenMetric_pub_key = md_EventTssKeygenMetric.Fields().ByName("pub_key")
	fd_EventTssKeygenMetric_median_duration_ms = md_EventTssKeygenMetric.Fields().ByName("median_duration_ms")
}

var _ protoreflect.Message = (*fastReflection_EventTssKeygenMetric)(nil)

type fastReflection_EventTssKeygenMetric EventTssKeygenMetric

func (x *EventTssKeygenMetric) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTssKeygenMetric)(x)
}

func (x *EventTssKeygenMetric) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTssKeygenMetric_messageType fastReflection_EventTssKeygenMetric_messageType
var _ protoreflect.MessageType = fastReflection_EventTssKeygenMetric_messageType{}

type fastReflection_EventTssKeygenMetric_messageType struct{}

func (x fastReflection_EventTssKeygenMetric_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTssKeygenMetric)(nil)
}
func (x fastReflection_EventTssKeygenMetric_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenMetric)
}
func (x fastReflection_EventTssKeygenMetric_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenMetric
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTssKeygenMetric) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeygenMetric
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTssKeygenMetric) Type() protoreflect.MessageType {
	return _fastReflection_EventTssKeygenMetric_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTssKeygenMetric) New() protoreflect.Message {
	return new(fastReflection_EventTssKeygenMetric)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTssKeygenMetric) Interface() protoreflect.ProtoMessage {
	return (*EventTssKeygenMetric)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTssKeygenMetric) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PubKey != "" {
		value := protoreflect.ValueOfString(x.PubKey)
		if !f(fd_EventTssKeygenMetric_pub_key, value) {
			return
		}
	}
	if x.MedianDurationMs != int64(0) {
		value := protoreflect.ValueOfInt64(x.MedianDurationMs)
		if !f(fd_EventTssKeygenMetric_median_duration_ms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTssKeygenMetric) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		return x.PubKey != ""
	case "types.EventTssKeygenMetric.median_duration_ms":
		return x.MedianDurationMs != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenMetric) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		x.PubKey = ""
	case "types.EventTssKeygenMetric.median_duration_ms":
		x.MedianDurationMs = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTssKeygenMetric) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		value := x.PubKey
		return protoreflect.ValueOfString(value)
	case "types.EventTssKeygenMetric.median_duration_ms":
		value := x.MedianDurationMs
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenMetric) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		x.PubKey = value.Interface().(string)
	case "types.EventTssKeygenMetric.median_duration_ms":
		x.MedianDurationMs = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenMetric) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		panic(fmt.Errorf("field pub_key of message types.EventTssKeygenMetric is not mutable"))
	case "types.EventTssKeygenMetric.median_duration_ms":
		panic(fmt.Errorf("field median_duration_ms of message types.EventTssKeygenMetric is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTssKeygenMetric) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeygenMetric.pub_key":
		return protoreflect.ValueOfString("")
	case "types.EventTssKeygenMetric.median_duration_ms":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeygenMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeygenMetric does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTssKeygenMetric) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTssKeygenMetric", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTssKeygenMetric) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeygenMetric) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTssKeygenMetric) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTssKeygenMetric) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTssKeygenMetric)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PubKey)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MedianDurationMs != 0 {
			n += 1 + runtime.Sov(uint64(x.MedianDurationMs))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenMetric)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MedianDurationMs != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MedianDurationMs))
			i--
			dAtA[i] = 0x10
		}
		if len(x.PubKey) > 0 {
			i -= len(x.PubKey)
			copy(dAtA[i:], x.PubKey)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKey)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeygenMetric)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenMetric: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeygenMetric: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKey = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
				}
				x.MedianDurationMs = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MedianDurationMs |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTssKeysignMetric                    protoreflect.MessageDescriptor
	fd_EventTssKeysignMetric_tx_id              protoreflect.FieldDescriptor
	fd_EventTssKeysignMetric_median_duration_ms protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTssKeysignMetric = File_types_type_events_proto.Messages().ByName("EventTssKeysignMetric")
	fd_EventTssKeysignMetric_tx_id = md_EventTssKeysignMetric.Fields().ByName("tx_id")
	fd_EventTssKeysignMetric_median_duration_ms = md_EventTssKeysignMetric.Fields().ByName("median_duration_ms")
}

var _ protoreflect.Message = (*fastReflection_EventTssKeysignMetric)(nil)

type fastReflection_EventTssKeysignMetric EventTssKeysignMetric

func (x *EventTssKeysignMetric) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTssKeysignMetric)(x)
}

func (x *EventTssKeysignMetric) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTssKeysignMetric_messageType fastReflection_EventTssKeysignMetric_messageType
var _ protoreflect.MessageType = fastReflection_EventTssKeysignMetric_messageType{}

type fastReflection_EventTssKeysignMetric_messageType struct{}

func (x fastReflection_EventTssKeysignMetric_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTssKeysignMetric)(nil)
}
func (x fastReflection_EventTssKeysignMetric_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTssKeysignMetric)
}
func (x fastReflection_EventTssKeysignMetric_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeysignMetric
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTssKeysignMetric) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTssKeysignMetric
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTssKeysignMetric) Type() protoreflect.MessageType {
	return _fastReflection_EventTssKeysignMetric_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTssKeysignMetric) New() protoreflect.Message {
	return new(fastReflection_EventTssKeysignMetric)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTssKeysignMetric) Interface() protoreflect.ProtoMessage {
	return (*EventTssKeysignMetric)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTssKeysignMetric) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventTssKeysignMetric_tx_id, value) {
			return
		}
	}
	if x.MedianDurationMs != int64(0) {
		value := protoreflect.ValueOfInt64(x.MedianDurationMs)
		if !f(fd_EventTssKeysignMetric_median_duration_ms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTssKeysignMetric) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		return x.TxId != ""
	case "types.EventTssKeysignMetric.median_duration_ms":
		return x.MedianDurationMs != int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeysignMetric) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		x.TxId = ""
	case "types.EventTssKeysignMetric.median_duration_ms":
		x.MedianDurationMs = int64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTssKeysignMetric) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventTssKeysignMetric.median_duration_ms":
		value := x.MedianDurationMs
		return protoreflect.ValueOfInt64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeysignMetric) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventTssKeysignMetric.median_duration_ms":
		x.MedianDurationMs = value.Int()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeysignMetric) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventTssKeysignMetric is not mutable"))
	case "types.EventTssKeysignMetric.median_duration_ms":
		panic(fmt.Errorf("field median_duration_ms of message types.EventTssKeysignMetric is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTssKeysignMetric) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTssKeysignMetric.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventTssKeysignMetric.median_duration_ms":
		return protoreflect.ValueOfInt64(int64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTssKeysignMetric"))
		}
		panic(fmt.Errorf("message types.EventTssKeysignMetric does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTssKeysignMetric) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTssKeysignMetric", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTssKeysignMetric) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTssKeysignMetric) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTssKeysignMetric) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTssKeysignMetric) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTssKeysignMetric)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.MedianDurationMs != 0 {
			n += 1 + runtime.Sov(uint64(x.MedianDurationMs))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeysignMetric)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.MedianDurationMs != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.MedianDurationMs))
			i--
			dAtA[i] = 0x10
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTssKeysignMetric)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeysignMetric: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTssKeysignMetric: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MedianDurationMs", wireType)
				}
				x.MedianDurationMs = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.MedianDurationMs |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSlashPoint              protoreflect.MessageDescriptor
	fd_EventSlashPoint_node_address protoreflect.FieldDescriptor
	fd_EventSlashPoint_slash_points protoreflect.FieldDescriptor
	fd_EventSlashPoint_reason       protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSlashPoint = File_types_type_events_proto.Messages().ByName("EventSlashPoint")
	fd_EventSlashPoint_node_address = md_EventSlashPoint.Fields().ByName("node_address")
	fd_EventSlashPoint_slash_points = md_EventSlashPoint.Fields().ByName("slash_points")
	fd_EventSlashPoint_reason = md_EventSlashPoint.Fields().ByName("reason")
}

var _ protoreflect.Message = (*fastReflection_EventSlashPoint)(nil)

type fastReflection_EventSlashPoint EventSlashPoint

func (x *EventSlashPoint) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSlashPoint)(x)
}

func (x *EventSlashPoint) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSlashPoint_messageType fastReflection_EventSlashPoint_messageType
var _ protoreflect.MessageType = fastReflection_EventSlashPoint_messageType{}

type fastReflection_EventSlashPoint_messageType struct{}

func (x fastReflection_EventSlashPoint_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSlashPoint)(nil)
}
func (x fastReflection_EventSlashPoint_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSlashPoint)
}
func (x fastReflection_EventSlashPoint_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSlashPoint
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSlashPoint) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSlashPoint
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSlashPoint) Type() protoreflect.MessageType {
	return _fastReflection_EventSlashPoint_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSlashPoint) New() protoreflect.Message {
	return new(fastReflection_EventSlashPoint)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSlashPoint) Interface() protoreflect.ProtoMessage {
	return (*EventSlashPoint)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSlashPoint) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NodeAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.NodeAddress)
		if !f(fd_EventSlashPoint_node_address, value) {
			return
		}
	}
	if x.SlashPoints != int64(0) {
		value := protoreflect.ValueOfInt64(x.SlashPoints)
		if !f(fd_EventSlashPoint_slash_points, value) {
			return
		}
	}
	if x.Reason != "" {
		value := protoreflect.ValueOfString(x.Reason)
		if !f(fd_EventSlashPoint_reason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSlashPoint) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSlashPoint.node_address":
		return len(x.NodeAddress) != 0
	case "types.EventSlashPoint.slash_points":
		return x.SlashPoints != int64(0)
	case "types.EventSlashPoint.reason":
		return x.Reason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlashPoint) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSlashPoint.node_address":
		x.NodeAddress = nil
	case "types.EventSlashPoint.slash_points":
		x.SlashPoints = int64(0)
	case "types.EventSlashPoint.reason":
		x.Reason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSlashPoint) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSlashPoint.node_address":
		value := x.NodeAddress
		return protoreflect.ValueOfBytes(value)
	case "types.EventSlashPoint.slash_points":
		value := x.SlashPoints
		return protoreflect.ValueOfInt64(value)
	case "types.EventSlashPoint.reason":
		value := x.Reason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlashPoint) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSlashPoint.node_address":
		x.NodeAddress = value.Bytes()
	case "types.EventSlashPoint.slash_points":
		x.SlashPoints = value.Int()
	case "types.EventSlashPoint.reason":
		x.Reason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlashPoint) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSlashPoint.node_address":
		panic(fmt.Errorf("field node_address of message types.EventSlashPoint is not mutable"))
	case "types.EventSlashPoint.slash_points":
		panic(fmt.Errorf("field slash_points of message types.EventSlashPoint is not mutable"))
	case "types.EventSlashPoint.reason":
		panic(fmt.Errorf("field reason of message types.EventSlashPoint is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSlashPoint) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSlashPoint.node_address":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventSlashPoint.slash_points":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventSlashPoint.reason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSlashPoint"))
		}
		panic(fmt.Errorf("message types.EventSlashPoint does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSlashPoint) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSlashPoint", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSlashPoint) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSlashPoint) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSlashPoint) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSlashPoint) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSlashPoint)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NodeAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.SlashPoints != 0 {
			n += 1 + runtime.Sov(uint64(x.SlashPoints))
		}
		l = len(x.Reason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSlashPoint)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Reason) > 0 {
			i -= len(x.Reason)
			copy(dAtA[i:], x.Reason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Reason)))
			i--
			dAtA[i] = 0x1a
		}
		if x.SlashPoints != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SlashPoints))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NodeAddress) > 0 {
			i -= len(x.NodeAddress)
			copy(dAtA[i:], x.NodeAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NodeAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSlashPoint)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSlashPoint: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSlashPoint: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NodeAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NodeAddress = append(x.NodeAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.NodeAddress == nil {
					x.NodeAddress = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SlashPoints", wireType)
				}
				x.SlashPoints = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SlashPoints |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Reason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventPoolBalanceChanged             protoreflect.MessageDescriptor
	fd_EventPoolBalanceChanged_pool_change protoreflect.FieldDescriptor
	fd_EventPoolBalanceChanged_reason      protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventPoolBalanceChanged = File_types_type_events_proto.Messages().ByName("EventPoolBalanceChanged")
	fd_EventPoolBalanceChanged_pool_change = md_EventPoolBalanceChanged.Fields().ByName("pool_change")
	fd_EventPoolBalanceChanged_reason = md_EventPoolBalanceChanged.Fields().ByName("reason")
}

var _ protoreflect.Message = (*fastReflection_EventPoolBalanceChanged)(nil)

type fastReflection_EventPoolBalanceChanged EventPoolBalanceChanged

func (x *EventPoolBalanceChanged) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventPoolBalanceChanged)(x)
}

func (x *EventPoolBalanceChanged) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventPoolBalanceChanged_messageType fastReflection_EventPoolBalanceChanged_messageType
var _ protoreflect.MessageType = fastReflection_EventPoolBalanceChanged_messageType{}

type fastReflection_EventPoolBalanceChanged_messageType struct{}

func (x fastReflection_EventPoolBalanceChanged_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventPoolBalanceChanged)(nil)
}
func (x fastReflection_EventPoolBalanceChanged_messageType) New() protoreflect.Message {
	return new(fastReflection_EventPoolBalanceChanged)
}
func (x fastReflection_EventPoolBalanceChanged_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolBalanceChanged
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventPoolBalanceChanged) Descriptor() protoreflect.MessageDescriptor {
	return md_EventPoolBalanceChanged
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventPoolBalanceChanged) Type() protoreflect.MessageType {
	return _fastReflection_EventPoolBalanceChanged_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventPoolBalanceChanged) New() protoreflect.Message {
	return new(fastReflection_EventPoolBalanceChanged)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventPoolBalanceChanged) Interface() protoreflect.ProtoMessage {
	return (*EventPoolBalanceChanged)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventPoolBalanceChanged) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PoolChange != nil {
		value := protoreflect.ValueOfMessage(x.PoolChange.ProtoReflect())
		if !f(fd_EventPoolBalanceChanged_pool_change, value) {
			return
		}
	}
	if x.Reason != "" {
		value := protoreflect.ValueOfString(x.Reason)
		if !f(fd_EventPoolBalanceChanged_reason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventPoolBalanceChanged) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		return x.PoolChange != nil
	case "types.EventPoolBalanceChanged.reason":
		return x.Reason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolBalanceChanged) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		x.PoolChange = nil
	case "types.EventPoolBalanceChanged.reason":
		x.Reason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventPoolBalanceChanged) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		value := x.PoolChange
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventPoolBalanceChanged.reason":
		value := x.Reason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolBalanceChanged) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		x.PoolChange = value.Message().Interface().(*PoolMod)
	case "types.EventPoolBalanceChanged.reason":
		x.Reason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolBalanceChanged) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		if x.PoolChange == nil {
			x.PoolChange = new(PoolMod)
		}
		return protoreflect.ValueOfMessage(x.PoolChange.ProtoReflect())
	case "types.EventPoolBalanceChanged.reason":
		panic(fmt.Errorf("field reason of message types.EventPoolBalanceChanged is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventPoolBalanceChanged) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventPoolBalanceChanged.pool_change":
		m := new(PoolMod)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventPoolBalanceChanged.reason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventPoolBalanceChanged"))
		}
		panic(fmt.Errorf("message types.EventPoolBalanceChanged does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventPoolBalanceChanged) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventPoolBalanceChanged", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventPoolBalanceChanged) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventPoolBalanceChanged) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventPoolBalanceChanged) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventPoolBalanceChanged) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventPoolBalanceChanged)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.PoolChange != nil {
			l = options.Size(x.PoolChange)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Reason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolBalanceChanged)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Reason) > 0 {
			i -= len(x.Reason)
			copy(dAtA[i:], x.Reason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Reason)))
			i--
			dAtA[i] = 0x12
		}
		if x.PoolChange != nil {
			encoded, err := options.Marshal(x.PoolChange)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventPoolBalanceChanged)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolBalanceChanged: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventPoolBalanceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PoolChange", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PoolChange == nil {
					x.PoolChange = &PoolMod{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PoolChange); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Reason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventMintBurn        protoreflect.MessageDescriptor
	fd_EventMintBurn_supply protoreflect.FieldDescriptor
	fd_EventMintBurn_denom  protoreflect.FieldDescriptor
	fd_EventMintBurn_amount protoreflect.FieldDescriptor
	fd_EventMintBurn_reason protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventMintBurn = File_types_type_events_proto.Messages().ByName("EventMintBurn")
	fd_EventMintBurn_supply = md_EventMintBurn.Fields().ByName("supply")
	fd_EventMintBurn_denom = md_EventMintBurn.Fields().ByName("denom")
	fd_EventMintBurn_amount = md_EventMintBurn.Fields().ByName("amount")
	fd_EventMintBurn_reason = md_EventMintBurn.Fields().ByName("reason")
}

var _ protoreflect.Message = (*fastReflection_EventMintBurn)(nil)

type fastReflection_EventMintBurn EventMintBurn

func (x *EventMintBurn) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventMintBurn)(x)
}

func (x *EventMintBurn) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventMintBurn_messageType fastReflection_EventMintBurn_messageType
var _ protoreflect.MessageType = fastReflection_EventMintBurn_messageType{}

type fastReflection_EventMintBurn_messageType struct{}

func (x fastReflection_EventMintBurn_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventMintBurn)(nil)
}
func (x fastReflection_EventMintBurn_messageType) New() protoreflect.Message {
	return new(fastReflection_EventMintBurn)
}
func (x fastReflection_EventMintBurn_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventMintBurn
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventMintBurn) Descriptor() protoreflect.MessageDescriptor {
	return md_EventMintBurn
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventMintBurn) Type() protoreflect.MessageType {
	return _fastReflection_EventMintBurn_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventMintBurn) New() protoreflect.Message {
	return new(fastReflection_EventMintBurn)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventMintBurn) Interface() protoreflect.ProtoMessage {
	return (*EventMintBurn)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventMintBurn) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Supply != 0 {
		value := protoreflect.ValueOfEnum((protoreflect.EnumNumber)(x.Supply))
		if !f(fd_EventMintBurn_supply, value) {
			return
		}
	}
	if x.Denom != "" {
		value := protoreflect.ValueOfString(x.Denom)
		if !f(fd_EventMintBurn_denom, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventMintBurn_amount, value) {
			return
		}
	}
	if x.Reason != "" {
		value := protoreflect.ValueOfString(x.Reason)
		if !f(fd_EventMintBurn_reason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventMintBurn) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventMintBurn.supply":
		return x.Supply != 0
	case "types.EventMintBurn.denom":
		return x.Denom != ""
	case "types.EventMintBurn.amount":
		return x.Amount != ""
	case "types.EventMintBurn.reason":
		return x.Reason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventMintBurn) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventMintBurn.supply":
		x.Supply = 0
	case "types.EventMintBurn.denom":
		x.Denom = ""
	case "types.EventMintBurn.amount":
		x.Amount = ""
	case "types.EventMintBurn.reason":
		x.Reason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventMintBurn) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventMintBurn.supply":
		value := x.Supply
		return protoreflect.ValueOfEnum((protoreflect.EnumNumber)(value))
	case "types.EventMintBurn.denom":
		value := x.Denom
		return protoreflect.ValueOfString(value)
	case "types.EventMintBurn.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventMintBurn.reason":
		value := x.Reason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventMintBurn) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventMintBurn.supply":
		x.Supply = (MintBurnSupplyType)(value.Enum())
	case "types.EventMintBurn.denom":
		x.Denom = value.Interface().(string)
	case "types.EventMintBurn.amount":
		x.Amount = value.Interface().(string)
	case "types.EventMintBurn.reason":
		x.Reason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventMintBurn) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventMintBurn.supply":
		panic(fmt.Errorf("field supply of message types.EventMintBurn is not mutable"))
	case "types.EventMintBurn.denom":
		panic(fmt.Errorf("field denom of message types.EventMintBurn is not mutable"))
	case "types.EventMintBurn.amount":
		panic(fmt.Errorf("field amount of message types.EventMintBurn is not mutable"))
	case "types.EventMintBurn.reason":
		panic(fmt.Errorf("field reason of message types.EventMintBurn is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventMintBurn) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventMintBurn.supply":
		return protoreflect.ValueOfEnum(0)
	case "types.EventMintBurn.denom":
		return protoreflect.ValueOfString("")
	case "types.EventMintBurn.amount":
		return protoreflect.ValueOfString("")
	case "types.EventMintBurn.reason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventMintBurn"))
		}
		panic(fmt.Errorf("message types.EventMintBurn does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventMintBurn) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventMintBurn", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventMintBurn) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventMintBurn) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventMintBurn) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventMintBurn) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventMintBurn)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Supply != 0 {
			n += 1 + runtime.Sov(uint64(x.Supply))
		}
		l = len(x.Denom)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Reason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventMintBurn)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Reason) > 0 {
			i -= len(x.Reason)
			copy(dAtA[i:], x.Reason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Reason)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Denom) > 0 {
			i -= len(x.Denom)
			copy(dAtA[i:], x.Denom)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Denom)))
			i--
			dAtA[i] = 0x12
		}
		if x.Supply != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Supply))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventMintBurn)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventMintBurn: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventMintBurn: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
				}
				x.Supply = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Supply |= MintBurnSupplyType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Denom = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Reason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTradeAccountDeposit               protoreflect.MessageDescriptor
	fd_EventTradeAccountDeposit_amount        protoreflect.FieldDescriptor
	fd_EventTradeAccountDeposit_asset         protoreflect.FieldDescriptor
	fd_EventTradeAccountDeposit_asset_address protoreflect.FieldDescriptor
	fd_EventTradeAccountDeposit_rune_address  protoreflect.FieldDescriptor
	fd_EventTradeAccountDeposit_tx_id         protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTradeAccountDeposit = File_types_type_events_proto.Messages().ByName("EventTradeAccountDeposit")
	fd_EventTradeAccountDeposit_amount = md_EventTradeAccountDeposit.Fields().ByName("amount")
	fd_EventTradeAccountDeposit_asset = md_EventTradeAccountDeposit.Fields().ByName("asset")
	fd_EventTradeAccountDeposit_asset_address = md_EventTradeAccountDeposit.Fields().ByName("asset_address")
	fd_EventTradeAccountDeposit_rune_address = md_EventTradeAccountDeposit.Fields().ByName("rune_address")
	fd_EventTradeAccountDeposit_tx_id = md_EventTradeAccountDeposit.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventTradeAccountDeposit)(nil)

type fastReflection_EventTradeAccountDeposit EventTradeAccountDeposit

func (x *EventTradeAccountDeposit) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTradeAccountDeposit)(x)
}

func (x *EventTradeAccountDeposit) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTradeAccountDeposit_messageType fastReflection_EventTradeAccountDeposit_messageType
var _ protoreflect.MessageType = fastReflection_EventTradeAccountDeposit_messageType{}

type fastReflection_EventTradeAccountDeposit_messageType struct{}

func (x fastReflection_EventTradeAccountDeposit_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTradeAccountDeposit)(nil)
}
func (x fastReflection_EventTradeAccountDeposit_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTradeAccountDeposit)
}
func (x fastReflection_EventTradeAccountDeposit_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTradeAccountDeposit
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTradeAccountDeposit) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTradeAccountDeposit
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTradeAccountDeposit) Type() protoreflect.MessageType {
	return _fastReflection_EventTradeAccountDeposit_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTradeAccountDeposit) New() protoreflect.Message {
	return new(fastReflection_EventTradeAccountDeposit)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTradeAccountDeposit) Interface() protoreflect.ProtoMessage {
	return (*EventTradeAccountDeposit)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTradeAccountDeposit) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventTradeAccountDeposit_amount, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventTradeAccountDeposit_asset, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventTradeAccountDeposit_asset_address, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventTradeAccountDeposit_rune_address, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventTradeAccountDeposit_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTradeAccountDeposit) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTradeAccountDeposit.amount":
		return x.Amount != ""
	case "types.EventTradeAccountDeposit.asset":
		return x.Asset != nil
	case "types.EventTradeAccountDeposit.asset_address":
		return x.AssetAddress != ""
	case "types.EventTradeAccountDeposit.rune_address":
		return x.RuneAddress != ""
	case "types.EventTradeAccountDeposit.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountDeposit) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTradeAccountDeposit.amount":
		x.Amount = ""
	case "types.EventTradeAccountDeposit.asset":
		x.Asset = nil
	case "types.EventTradeAccountDeposit.asset_address":
		x.AssetAddress = ""
	case "types.EventTradeAccountDeposit.rune_address":
		x.RuneAddress = ""
	case "types.EventTradeAccountDeposit.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTradeAccountDeposit) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTradeAccountDeposit.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountDeposit.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventTradeAccountDeposit.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountDeposit.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountDeposit.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountDeposit) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTradeAccountDeposit.amount":
		x.Amount = value.Interface().(string)
	case "types.EventTradeAccountDeposit.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventTradeAccountDeposit.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventTradeAccountDeposit.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventTradeAccountDeposit.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountDeposit) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTradeAccountDeposit.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventTradeAccountDeposit.amount":
		panic(fmt.Errorf("field amount of message types.EventTradeAccountDeposit is not mutable"))
	case "types.EventTradeAccountDeposit.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventTradeAccountDeposit is not mutable"))
	case "types.EventTradeAccountDeposit.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventTradeAccountDeposit is not mutable"))
	case "types.EventTradeAccountDeposit.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventTradeAccountDeposit is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTradeAccountDeposit) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTradeAccountDeposit.amount":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountDeposit.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventTradeAccountDeposit.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountDeposit.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountDeposit.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountDeposit"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountDeposit does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTradeAccountDeposit) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTradeAccountDeposit", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTradeAccountDeposit) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountDeposit) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTradeAccountDeposit) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTradeAccountDeposit) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTradeAccountDeposit)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTradeAccountDeposit)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTradeAccountDeposit)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTradeAccountDeposit: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTradeAccountDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTradeAccountWithdraw               protoreflect.MessageDescriptor
	fd_EventTradeAccountWithdraw_amount        protoreflect.FieldDescriptor
	fd_EventTradeAccountWithdraw_asset         protoreflect.FieldDescriptor
	fd_EventTradeAccountWithdraw_asset_address protoreflect.FieldDescriptor
	fd_EventTradeAccountWithdraw_rune_address  protoreflect.FieldDescriptor
	fd_EventTradeAccountWithdraw_tx_id         protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTradeAccountWithdraw = File_types_type_events_proto.Messages().ByName("EventTradeAccountWithdraw")
	fd_EventTradeAccountWithdraw_amount = md_EventTradeAccountWithdraw.Fields().ByName("amount")
	fd_EventTradeAccountWithdraw_asset = md_EventTradeAccountWithdraw.Fields().ByName("asset")
	fd_EventTradeAccountWithdraw_asset_address = md_EventTradeAccountWithdraw.Fields().ByName("asset_address")
	fd_EventTradeAccountWithdraw_rune_address = md_EventTradeAccountWithdraw.Fields().ByName("rune_address")
	fd_EventTradeAccountWithdraw_tx_id = md_EventTradeAccountWithdraw.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventTradeAccountWithdraw)(nil)

type fastReflection_EventTradeAccountWithdraw EventTradeAccountWithdraw

func (x *EventTradeAccountWithdraw) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTradeAccountWithdraw)(x)
}

func (x *EventTradeAccountWithdraw) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTradeAccountWithdraw_messageType fastReflection_EventTradeAccountWithdraw_messageType
var _ protoreflect.MessageType = fastReflection_EventTradeAccountWithdraw_messageType{}

type fastReflection_EventTradeAccountWithdraw_messageType struct{}

func (x fastReflection_EventTradeAccountWithdraw_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTradeAccountWithdraw)(nil)
}
func (x fastReflection_EventTradeAccountWithdraw_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTradeAccountWithdraw)
}
func (x fastReflection_EventTradeAccountWithdraw_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTradeAccountWithdraw
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTradeAccountWithdraw) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTradeAccountWithdraw
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTradeAccountWithdraw) Type() protoreflect.MessageType {
	return _fastReflection_EventTradeAccountWithdraw_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTradeAccountWithdraw) New() protoreflect.Message {
	return new(fastReflection_EventTradeAccountWithdraw)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTradeAccountWithdraw) Interface() protoreflect.ProtoMessage {
	return (*EventTradeAccountWithdraw)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTradeAccountWithdraw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventTradeAccountWithdraw_amount, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventTradeAccountWithdraw_asset, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventTradeAccountWithdraw_asset_address, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventTradeAccountWithdraw_rune_address, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventTradeAccountWithdraw_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTradeAccountWithdraw) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTradeAccountWithdraw.amount":
		return x.Amount != ""
	case "types.EventTradeAccountWithdraw.asset":
		return x.Asset != nil
	case "types.EventTradeAccountWithdraw.asset_address":
		return x.AssetAddress != ""
	case "types.EventTradeAccountWithdraw.rune_address":
		return x.RuneAddress != ""
	case "types.EventTradeAccountWithdraw.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountWithdraw) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTradeAccountWithdraw.amount":
		x.Amount = ""
	case "types.EventTradeAccountWithdraw.asset":
		x.Asset = nil
	case "types.EventTradeAccountWithdraw.asset_address":
		x.AssetAddress = ""
	case "types.EventTradeAccountWithdraw.rune_address":
		x.RuneAddress = ""
	case "types.EventTradeAccountWithdraw.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTradeAccountWithdraw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTradeAccountWithdraw.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountWithdraw.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventTradeAccountWithdraw.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountWithdraw.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventTradeAccountWithdraw.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountWithdraw) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTradeAccountWithdraw.amount":
		x.Amount = value.Interface().(string)
	case "types.EventTradeAccountWithdraw.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventTradeAccountWithdraw.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventTradeAccountWithdraw.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventTradeAccountWithdraw.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountWithdraw) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTradeAccountWithdraw.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventTradeAccountWithdraw.amount":
		panic(fmt.Errorf("field amount of message types.EventTradeAccountWithdraw is not mutable"))
	case "types.EventTradeAccountWithdraw.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventTradeAccountWithdraw is not mutable"))
	case "types.EventTradeAccountWithdraw.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventTradeAccountWithdraw is not mutable"))
	case "types.EventTradeAccountWithdraw.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventTradeAccountWithdraw is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTradeAccountWithdraw) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTradeAccountWithdraw.amount":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountWithdraw.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventTradeAccountWithdraw.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountWithdraw.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventTradeAccountWithdraw.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTradeAccountWithdraw"))
		}
		panic(fmt.Errorf("message types.EventTradeAccountWithdraw does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTradeAccountWithdraw) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTradeAccountWithdraw", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTradeAccountWithdraw) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTradeAccountWithdraw) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTradeAccountWithdraw) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTradeAccountWithdraw) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTradeAccountWithdraw)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTradeAccountWithdraw)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTradeAccountWithdraw)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTradeAccountWithdraw: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTradeAccountWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSecuredAssetDeposit               protoreflect.MessageDescriptor
	fd_EventSecuredAssetDeposit_amount        protoreflect.FieldDescriptor
	fd_EventSecuredAssetDeposit_asset         protoreflect.FieldDescriptor
	fd_EventSecuredAssetDeposit_asset_address protoreflect.FieldDescriptor
	fd_EventSecuredAssetDeposit_rune_address  protoreflect.FieldDescriptor
	fd_EventSecuredAssetDeposit_tx_id         protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSecuredAssetDeposit = File_types_type_events_proto.Messages().ByName("EventSecuredAssetDeposit")
	fd_EventSecuredAssetDeposit_amount = md_EventSecuredAssetDeposit.Fields().ByName("amount")
	fd_EventSecuredAssetDeposit_asset = md_EventSecuredAssetDeposit.Fields().ByName("asset")
	fd_EventSecuredAssetDeposit_asset_address = md_EventSecuredAssetDeposit.Fields().ByName("asset_address")
	fd_EventSecuredAssetDeposit_rune_address = md_EventSecuredAssetDeposit.Fields().ByName("rune_address")
	fd_EventSecuredAssetDeposit_tx_id = md_EventSecuredAssetDeposit.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventSecuredAssetDeposit)(nil)

type fastReflection_EventSecuredAssetDeposit EventSecuredAssetDeposit

func (x *EventSecuredAssetDeposit) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSecuredAssetDeposit)(x)
}

func (x *EventSecuredAssetDeposit) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSecuredAssetDeposit_messageType fastReflection_EventSecuredAssetDeposit_messageType
var _ protoreflect.MessageType = fastReflection_EventSecuredAssetDeposit_messageType{}

type fastReflection_EventSecuredAssetDeposit_messageType struct{}

func (x fastReflection_EventSecuredAssetDeposit_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSecuredAssetDeposit)(nil)
}
func (x fastReflection_EventSecuredAssetDeposit_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSecuredAssetDeposit)
}
func (x fastReflection_EventSecuredAssetDeposit_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecuredAssetDeposit
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSecuredAssetDeposit) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecuredAssetDeposit
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSecuredAssetDeposit) Type() protoreflect.MessageType {
	return _fastReflection_EventSecuredAssetDeposit_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSecuredAssetDeposit) New() protoreflect.Message {
	return new(fastReflection_EventSecuredAssetDeposit)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSecuredAssetDeposit) Interface() protoreflect.ProtoMessage {
	return (*EventSecuredAssetDeposit)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSecuredAssetDeposit) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventSecuredAssetDeposit_amount, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventSecuredAssetDeposit_asset, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventSecuredAssetDeposit_asset_address, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventSecuredAssetDeposit_rune_address, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventSecuredAssetDeposit_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSecuredAssetDeposit) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSecuredAssetDeposit.amount":
		return x.Amount != ""
	case "types.EventSecuredAssetDeposit.asset":
		return x.Asset != nil
	case "types.EventSecuredAssetDeposit.asset_address":
		return x.AssetAddress != ""
	case "types.EventSecuredAssetDeposit.rune_address":
		return x.RuneAddress != ""
	case "types.EventSecuredAssetDeposit.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetDeposit) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSecuredAssetDeposit.amount":
		x.Amount = ""
	case "types.EventSecuredAssetDeposit.asset":
		x.Asset = nil
	case "types.EventSecuredAssetDeposit.asset_address":
		x.AssetAddress = ""
	case "types.EventSecuredAssetDeposit.rune_address":
		x.RuneAddress = ""
	case "types.EventSecuredAssetDeposit.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSecuredAssetDeposit) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSecuredAssetDeposit.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetDeposit.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSecuredAssetDeposit.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetDeposit.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetDeposit.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetDeposit) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSecuredAssetDeposit.amount":
		x.Amount = value.Interface().(string)
	case "types.EventSecuredAssetDeposit.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventSecuredAssetDeposit.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventSecuredAssetDeposit.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventSecuredAssetDeposit.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetDeposit) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecuredAssetDeposit.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventSecuredAssetDeposit.amount":
		panic(fmt.Errorf("field amount of message types.EventSecuredAssetDeposit is not mutable"))
	case "types.EventSecuredAssetDeposit.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventSecuredAssetDeposit is not mutable"))
	case "types.EventSecuredAssetDeposit.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventSecuredAssetDeposit is not mutable"))
	case "types.EventSecuredAssetDeposit.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventSecuredAssetDeposit is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSecuredAssetDeposit) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecuredAssetDeposit.amount":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetDeposit.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSecuredAssetDeposit.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetDeposit.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetDeposit.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetDeposit"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetDeposit does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSecuredAssetDeposit) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSecuredAssetDeposit", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSecuredAssetDeposit) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetDeposit) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSecuredAssetDeposit) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSecuredAssetDeposit) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSecuredAssetDeposit)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSecuredAssetDeposit)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSecuredAssetDeposit)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecuredAssetDeposit: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecuredAssetDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSecuredAssetWithdraw               protoreflect.MessageDescriptor
	fd_EventSecuredAssetWithdraw_amount        protoreflect.FieldDescriptor
	fd_EventSecuredAssetWithdraw_asset         protoreflect.FieldDescriptor
	fd_EventSecuredAssetWithdraw_asset_address protoreflect.FieldDescriptor
	fd_EventSecuredAssetWithdraw_rune_address  protoreflect.FieldDescriptor
	fd_EventSecuredAssetWithdraw_tx_id         protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSecuredAssetWithdraw = File_types_type_events_proto.Messages().ByName("EventSecuredAssetWithdraw")
	fd_EventSecuredAssetWithdraw_amount = md_EventSecuredAssetWithdraw.Fields().ByName("amount")
	fd_EventSecuredAssetWithdraw_asset = md_EventSecuredAssetWithdraw.Fields().ByName("asset")
	fd_EventSecuredAssetWithdraw_asset_address = md_EventSecuredAssetWithdraw.Fields().ByName("asset_address")
	fd_EventSecuredAssetWithdraw_rune_address = md_EventSecuredAssetWithdraw.Fields().ByName("rune_address")
	fd_EventSecuredAssetWithdraw_tx_id = md_EventSecuredAssetWithdraw.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventSecuredAssetWithdraw)(nil)

type fastReflection_EventSecuredAssetWithdraw EventSecuredAssetWithdraw

func (x *EventSecuredAssetWithdraw) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSecuredAssetWithdraw)(x)
}

func (x *EventSecuredAssetWithdraw) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSecuredAssetWithdraw_messageType fastReflection_EventSecuredAssetWithdraw_messageType
var _ protoreflect.MessageType = fastReflection_EventSecuredAssetWithdraw_messageType{}

type fastReflection_EventSecuredAssetWithdraw_messageType struct{}

func (x fastReflection_EventSecuredAssetWithdraw_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSecuredAssetWithdraw)(nil)
}
func (x fastReflection_EventSecuredAssetWithdraw_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSecuredAssetWithdraw)
}
func (x fastReflection_EventSecuredAssetWithdraw_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecuredAssetWithdraw
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSecuredAssetWithdraw) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSecuredAssetWithdraw
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSecuredAssetWithdraw) Type() protoreflect.MessageType {
	return _fastReflection_EventSecuredAssetWithdraw_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSecuredAssetWithdraw) New() protoreflect.Message {
	return new(fastReflection_EventSecuredAssetWithdraw)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSecuredAssetWithdraw) Interface() protoreflect.ProtoMessage {
	return (*EventSecuredAssetWithdraw)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSecuredAssetWithdraw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventSecuredAssetWithdraw_amount, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventSecuredAssetWithdraw_asset, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventSecuredAssetWithdraw_asset_address, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventSecuredAssetWithdraw_rune_address, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventSecuredAssetWithdraw_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSecuredAssetWithdraw) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSecuredAssetWithdraw.amount":
		return x.Amount != ""
	case "types.EventSecuredAssetWithdraw.asset":
		return x.Asset != nil
	case "types.EventSecuredAssetWithdraw.asset_address":
		return x.AssetAddress != ""
	case "types.EventSecuredAssetWithdraw.rune_address":
		return x.RuneAddress != ""
	case "types.EventSecuredAssetWithdraw.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetWithdraw) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSecuredAssetWithdraw.amount":
		x.Amount = ""
	case "types.EventSecuredAssetWithdraw.asset":
		x.Asset = nil
	case "types.EventSecuredAssetWithdraw.asset_address":
		x.AssetAddress = ""
	case "types.EventSecuredAssetWithdraw.rune_address":
		x.RuneAddress = ""
	case "types.EventSecuredAssetWithdraw.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSecuredAssetWithdraw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSecuredAssetWithdraw.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetWithdraw.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSecuredAssetWithdraw.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetWithdraw.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSecuredAssetWithdraw.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetWithdraw) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSecuredAssetWithdraw.amount":
		x.Amount = value.Interface().(string)
	case "types.EventSecuredAssetWithdraw.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventSecuredAssetWithdraw.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventSecuredAssetWithdraw.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventSecuredAssetWithdraw.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetWithdraw) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecuredAssetWithdraw.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventSecuredAssetWithdraw.amount":
		panic(fmt.Errorf("field amount of message types.EventSecuredAssetWithdraw is not mutable"))
	case "types.EventSecuredAssetWithdraw.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventSecuredAssetWithdraw is not mutable"))
	case "types.EventSecuredAssetWithdraw.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventSecuredAssetWithdraw is not mutable"))
	case "types.EventSecuredAssetWithdraw.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventSecuredAssetWithdraw is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSecuredAssetWithdraw) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSecuredAssetWithdraw.amount":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetWithdraw.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSecuredAssetWithdraw.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetWithdraw.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventSecuredAssetWithdraw.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSecuredAssetWithdraw"))
		}
		panic(fmt.Errorf("message types.EventSecuredAssetWithdraw does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSecuredAssetWithdraw) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSecuredAssetWithdraw", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSecuredAssetWithdraw) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSecuredAssetWithdraw) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSecuredAssetWithdraw) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSecuredAssetWithdraw) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSecuredAssetWithdraw)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSecuredAssetWithdraw)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSecuredAssetWithdraw)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecuredAssetWithdraw: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSecuredAssetWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventRUNEPoolDeposit              protoreflect.MessageDescriptor
	fd_EventRUNEPoolDeposit_rune_address protoreflect.FieldDescriptor
	fd_EventRUNEPoolDeposit_rune_amount  protoreflect.FieldDescriptor
	fd_EventRUNEPoolDeposit_units        protoreflect.FieldDescriptor
	fd_EventRUNEPoolDeposit_tx_id        protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventRUNEPoolDeposit = File_types_type_events_proto.Messages().ByName("EventRUNEPoolDeposit")
	fd_EventRUNEPoolDeposit_rune_address = md_EventRUNEPoolDeposit.Fields().ByName("rune_address")
	fd_EventRUNEPoolDeposit_rune_amount = md_EventRUNEPoolDeposit.Fields().ByName("rune_amount")
	fd_EventRUNEPoolDeposit_units = md_EventRUNEPoolDeposit.Fields().ByName("units")
	fd_EventRUNEPoolDeposit_tx_id = md_EventRUNEPoolDeposit.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventRUNEPoolDeposit)(nil)

type fastReflection_EventRUNEPoolDeposit EventRUNEPoolDeposit

func (x *EventRUNEPoolDeposit) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRUNEPoolDeposit)(x)
}

func (x *EventRUNEPoolDeposit) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRUNEPoolDeposit_messageType fastReflection_EventRUNEPoolDeposit_messageType
var _ protoreflect.MessageType = fastReflection_EventRUNEPoolDeposit_messageType{}

type fastReflection_EventRUNEPoolDeposit_messageType struct{}

func (x fastReflection_EventRUNEPoolDeposit_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRUNEPoolDeposit)(nil)
}
func (x fastReflection_EventRUNEPoolDeposit_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRUNEPoolDeposit)
}
func (x fastReflection_EventRUNEPoolDeposit_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRUNEPoolDeposit
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRUNEPoolDeposit) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRUNEPoolDeposit
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRUNEPoolDeposit) Type() protoreflect.MessageType {
	return _fastReflection_EventRUNEPoolDeposit_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRUNEPoolDeposit) New() protoreflect.Message {
	return new(fastReflection_EventRUNEPoolDeposit)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRUNEPoolDeposit) Interface() protoreflect.ProtoMessage {
	return (*EventRUNEPoolDeposit)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRUNEPoolDeposit) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.RuneAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.RuneAddress)
		if !f(fd_EventRUNEPoolDeposit_rune_address, value) {
			return
		}
	}
	if x.RuneAmount != "" {
		value := protoreflect.ValueOfString(x.RuneAmount)
		if !f(fd_EventRUNEPoolDeposit_rune_amount, value) {
			return
		}
	}
	if x.Units != "" {
		value := protoreflect.ValueOfString(x.Units)
		if !f(fd_EventRUNEPoolDeposit_units, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventRUNEPoolDeposit_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRUNEPoolDeposit) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		return len(x.RuneAddress) != 0
	case "types.EventRUNEPoolDeposit.rune_amount":
		return x.RuneAmount != ""
	case "types.EventRUNEPoolDeposit.units":
		return x.Units != ""
	case "types.EventRUNEPoolDeposit.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolDeposit) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		x.RuneAddress = nil
	case "types.EventRUNEPoolDeposit.rune_amount":
		x.RuneAmount = ""
	case "types.EventRUNEPoolDeposit.units":
		x.Units = ""
	case "types.EventRUNEPoolDeposit.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRUNEPoolDeposit) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfBytes(value)
	case "types.EventRUNEPoolDeposit.rune_amount":
		value := x.RuneAmount
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolDeposit.units":
		value := x.Units
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolDeposit.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolDeposit) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		x.RuneAddress = value.Bytes()
	case "types.EventRUNEPoolDeposit.rune_amount":
		x.RuneAmount = value.Interface().(string)
	case "types.EventRUNEPoolDeposit.units":
		x.Units = value.Interface().(string)
	case "types.EventRUNEPoolDeposit.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolDeposit) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventRUNEPoolDeposit is not mutable"))
	case "types.EventRUNEPoolDeposit.rune_amount":
		panic(fmt.Errorf("field rune_amount of message types.EventRUNEPoolDeposit is not mutable"))
	case "types.EventRUNEPoolDeposit.units":
		panic(fmt.Errorf("field units of message types.EventRUNEPoolDeposit is not mutable"))
	case "types.EventRUNEPoolDeposit.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventRUNEPoolDeposit is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRUNEPoolDeposit) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRUNEPoolDeposit.rune_address":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventRUNEPoolDeposit.rune_amount":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolDeposit.units":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolDeposit.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolDeposit"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolDeposit does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRUNEPoolDeposit) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventRUNEPoolDeposit", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRUNEPoolDeposit) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolDeposit) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRUNEPoolDeposit) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRUNEPoolDeposit) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRUNEPoolDeposit)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Units)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRUNEPoolDeposit)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Units) > 0 {
			i -= len(x.Units)
			copy(dAtA[i:], x.Units)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Units)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.RuneAmount) > 0 {
			i -= len(x.RuneAmount)
			copy(dAtA[i:], x.RuneAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRUNEPoolDeposit)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRUNEPoolDeposit: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRUNEPoolDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = append(x.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.RuneAddress == nil {
					x.RuneAddress = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Units = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventRUNEPoolWithdraw                     protoreflect.MessageDescriptor
	fd_EventRUNEPoolWithdraw_rune_address        protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_basis_points        protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_rune_amount         protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_units               protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_tx_id               protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_affiliate_basis_pts protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_affiliate_amount    protoreflect.FieldDescriptor
	fd_EventRUNEPoolWithdraw_affiliate_address   protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventRUNEPoolWithdraw = File_types_type_events_proto.Messages().ByName("EventRUNEPoolWithdraw")
	fd_EventRUNEPoolWithdraw_rune_address = md_EventRUNEPoolWithdraw.Fields().ByName("rune_address")
	fd_EventRUNEPoolWithdraw_basis_points = md_EventRUNEPoolWithdraw.Fields().ByName("basis_points")
	fd_EventRUNEPoolWithdraw_rune_amount = md_EventRUNEPoolWithdraw.Fields().ByName("rune_amount")
	fd_EventRUNEPoolWithdraw_units = md_EventRUNEPoolWithdraw.Fields().ByName("units")
	fd_EventRUNEPoolWithdraw_tx_id = md_EventRUNEPoolWithdraw.Fields().ByName("tx_id")
	fd_EventRUNEPoolWithdraw_affiliate_basis_pts = md_EventRUNEPoolWithdraw.Fields().ByName("affiliate_basis_pts")
	fd_EventRUNEPoolWithdraw_affiliate_amount = md_EventRUNEPoolWithdraw.Fields().ByName("affiliate_amount")
	fd_EventRUNEPoolWithdraw_affiliate_address = md_EventRUNEPoolWithdraw.Fields().ByName("affiliate_address")
}

var _ protoreflect.Message = (*fastReflection_EventRUNEPoolWithdraw)(nil)

type fastReflection_EventRUNEPoolWithdraw EventRUNEPoolWithdraw

func (x *EventRUNEPoolWithdraw) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventRUNEPoolWithdraw)(x)
}

func (x *EventRUNEPoolWithdraw) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventRUNEPoolWithdraw_messageType fastReflection_EventRUNEPoolWithdraw_messageType
var _ protoreflect.MessageType = fastReflection_EventRUNEPoolWithdraw_messageType{}

type fastReflection_EventRUNEPoolWithdraw_messageType struct{}

func (x fastReflection_EventRUNEPoolWithdraw_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventRUNEPoolWithdraw)(nil)
}
func (x fastReflection_EventRUNEPoolWithdraw_messageType) New() protoreflect.Message {
	return new(fastReflection_EventRUNEPoolWithdraw)
}
func (x fastReflection_EventRUNEPoolWithdraw_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRUNEPoolWithdraw
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventRUNEPoolWithdraw) Descriptor() protoreflect.MessageDescriptor {
	return md_EventRUNEPoolWithdraw
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventRUNEPoolWithdraw) Type() protoreflect.MessageType {
	return _fastReflection_EventRUNEPoolWithdraw_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventRUNEPoolWithdraw) New() protoreflect.Message {
	return new(fastReflection_EventRUNEPoolWithdraw)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventRUNEPoolWithdraw) Interface() protoreflect.ProtoMessage {
	return (*EventRUNEPoolWithdraw)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventRUNEPoolWithdraw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.RuneAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.RuneAddress)
		if !f(fd_EventRUNEPoolWithdraw_rune_address, value) {
			return
		}
	}
	if x.BasisPoints != int64(0) {
		value := protoreflect.ValueOfInt64(x.BasisPoints)
		if !f(fd_EventRUNEPoolWithdraw_basis_points, value) {
			return
		}
	}
	if x.RuneAmount != "" {
		value := protoreflect.ValueOfString(x.RuneAmount)
		if !f(fd_EventRUNEPoolWithdraw_rune_amount, value) {
			return
		}
	}
	if x.Units != "" {
		value := protoreflect.ValueOfString(x.Units)
		if !f(fd_EventRUNEPoolWithdraw_units, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventRUNEPoolWithdraw_tx_id, value) {
			return
		}
	}
	if x.AffiliateBasisPts != int64(0) {
		value := protoreflect.ValueOfInt64(x.AffiliateBasisPts)
		if !f(fd_EventRUNEPoolWithdraw_affiliate_basis_pts, value) {
			return
		}
	}
	if x.AffiliateAmount != "" {
		value := protoreflect.ValueOfString(x.AffiliateAmount)
		if !f(fd_EventRUNEPoolWithdraw_affiliate_amount, value) {
			return
		}
	}
	if x.AffiliateAddress != "" {
		value := protoreflect.ValueOfString(x.AffiliateAddress)
		if !f(fd_EventRUNEPoolWithdraw_affiliate_address, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventRUNEPoolWithdraw) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		return len(x.RuneAddress) != 0
	case "types.EventRUNEPoolWithdraw.basis_points":
		return x.BasisPoints != int64(0)
	case "types.EventRUNEPoolWithdraw.rune_amount":
		return x.RuneAmount != ""
	case "types.EventRUNEPoolWithdraw.units":
		return x.Units != ""
	case "types.EventRUNEPoolWithdraw.tx_id":
		return x.TxId != ""
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		return x.AffiliateBasisPts != int64(0)
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		return x.AffiliateAmount != ""
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		return x.AffiliateAddress != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolWithdraw) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		x.RuneAddress = nil
	case "types.EventRUNEPoolWithdraw.basis_points":
		x.BasisPoints = int64(0)
	case "types.EventRUNEPoolWithdraw.rune_amount":
		x.RuneAmount = ""
	case "types.EventRUNEPoolWithdraw.units":
		x.Units = ""
	case "types.EventRUNEPoolWithdraw.tx_id":
		x.TxId = ""
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		x.AffiliateBasisPts = int64(0)
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		x.AffiliateAmount = ""
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		x.AffiliateAddress = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventRUNEPoolWithdraw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfBytes(value)
	case "types.EventRUNEPoolWithdraw.basis_points":
		value := x.BasisPoints
		return protoreflect.ValueOfInt64(value)
	case "types.EventRUNEPoolWithdraw.rune_amount":
		value := x.RuneAmount
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolWithdraw.units":
		value := x.Units
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolWithdraw.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		value := x.AffiliateBasisPts
		return protoreflect.ValueOfInt64(value)
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		value := x.AffiliateAmount
		return protoreflect.ValueOfString(value)
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		value := x.AffiliateAddress
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolWithdraw) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		x.RuneAddress = value.Bytes()
	case "types.EventRUNEPoolWithdraw.basis_points":
		x.BasisPoints = value.Int()
	case "types.EventRUNEPoolWithdraw.rune_amount":
		x.RuneAmount = value.Interface().(string)
	case "types.EventRUNEPoolWithdraw.units":
		x.Units = value.Interface().(string)
	case "types.EventRUNEPoolWithdraw.tx_id":
		x.TxId = value.Interface().(string)
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		x.AffiliateBasisPts = value.Int()
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		x.AffiliateAmount = value.Interface().(string)
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		x.AffiliateAddress = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolWithdraw) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.basis_points":
		panic(fmt.Errorf("field basis_points of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.rune_amount":
		panic(fmt.Errorf("field rune_amount of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.units":
		panic(fmt.Errorf("field units of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		panic(fmt.Errorf("field affiliate_basis_pts of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		panic(fmt.Errorf("field affiliate_amount of message types.EventRUNEPoolWithdraw is not mutable"))
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		panic(fmt.Errorf("field affiliate_address of message types.EventRUNEPoolWithdraw is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventRUNEPoolWithdraw) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventRUNEPoolWithdraw.rune_address":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventRUNEPoolWithdraw.basis_points":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventRUNEPoolWithdraw.rune_amount":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolWithdraw.units":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolWithdraw.tx_id":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolWithdraw.affiliate_basis_pts":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventRUNEPoolWithdraw.affiliate_amount":
		return protoreflect.ValueOfString("")
	case "types.EventRUNEPoolWithdraw.affiliate_address":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventRUNEPoolWithdraw"))
		}
		panic(fmt.Errorf("message types.EventRUNEPoolWithdraw does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventRUNEPoolWithdraw) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventRUNEPoolWithdraw", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventRUNEPoolWithdraw) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventRUNEPoolWithdraw) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventRUNEPoolWithdraw) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventRUNEPoolWithdraw) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventRUNEPoolWithdraw)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.BasisPoints != 0 {
			n += 1 + runtime.Sov(uint64(x.BasisPoints))
		}
		l = len(x.RuneAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Units)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.AffiliateBasisPts != 0 {
			n += 1 + runtime.Sov(uint64(x.AffiliateBasisPts))
		}
		l = len(x.AffiliateAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AffiliateAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventRUNEPoolWithdraw)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.AffiliateAddress) > 0 {
			i -= len(x.AffiliateAddress)
			copy(dAtA[i:], x.AffiliateAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AffiliateAddress)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.AffiliateAmount) > 0 {
			i -= len(x.AffiliateAmount)
			copy(dAtA[i:], x.AffiliateAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AffiliateAmount)))
			i--
			dAtA[i] = 0x3a
		}
		if x.AffiliateBasisPts != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.AffiliateBasisPts))
			i--
			dAtA[i] = 0x30
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Units) > 0 {
			i -= len(x.Units)
			copy(dAtA[i:], x.Units)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Units)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.RuneAmount) > 0 {
			i -= len(x.RuneAmount)
			copy(dAtA[i:], x.RuneAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmount)))
			i--
			dAtA[i] = 0x1a
		}
		if x.BasisPoints != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.BasisPoints))
			i--
			dAtA[i] = 0x10
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventRUNEPoolWithdraw)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRUNEPoolWithdraw: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventRUNEPoolWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = append(x.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.RuneAddress == nil {
					x.RuneAddress = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BasisPoints", wireType)
				}
				x.BasisPoints = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.BasisPoints |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Units = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AffiliateBasisPts", wireType)
				}
				x.AffiliateBasisPts = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.AffiliateBasisPts |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AffiliateAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AffiliateAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AffiliateAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AffiliateAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventLoanOpen                         protoreflect.MessageDescriptor
	fd_EventLoanOpen_collateral_deposited    protoreflect.FieldDescriptor
	fd_EventLoanOpen_collateral_asset        protoreflect.FieldDescriptor
	fd_EventLoanOpen_collateralization_ratio protoreflect.FieldDescriptor
	fd_EventLoanOpen_debt_issued             protoreflect.FieldDescriptor
	fd_EventLoanOpen_owner                   protoreflect.FieldDescriptor
	fd_EventLoanOpen_target_asset            protoreflect.FieldDescriptor
	fd_EventLoanOpen_tx_id                   protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventLoanOpen = File_types_type_events_proto.Messages().ByName("EventLoanOpen")
	fd_EventLoanOpen_collateral_deposited = md_EventLoanOpen.Fields().ByName("collateral_deposited")
	fd_EventLoanOpen_collateral_asset = md_EventLoanOpen.Fields().ByName("collateral_asset")
	fd_EventLoanOpen_collateralization_ratio = md_EventLoanOpen.Fields().ByName("collateralization_ratio")
	fd_EventLoanOpen_debt_issued = md_EventLoanOpen.Fields().ByName("debt_issued")
	fd_EventLoanOpen_owner = md_EventLoanOpen.Fields().ByName("owner")
	fd_EventLoanOpen_target_asset = md_EventLoanOpen.Fields().ByName("target_asset")
	fd_EventLoanOpen_tx_id = md_EventLoanOpen.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventLoanOpen)(nil)

type fastReflection_EventLoanOpen EventLoanOpen

func (x *EventLoanOpen) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventLoanOpen)(x)
}

func (x *EventLoanOpen) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventLoanOpen_messageType fastReflection_EventLoanOpen_messageType
var _ protoreflect.MessageType = fastReflection_EventLoanOpen_messageType{}

type fastReflection_EventLoanOpen_messageType struct{}

func (x fastReflection_EventLoanOpen_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventLoanOpen)(nil)
}
func (x fastReflection_EventLoanOpen_messageType) New() protoreflect.Message {
	return new(fastReflection_EventLoanOpen)
}
func (x fastReflection_EventLoanOpen_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLoanOpen
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventLoanOpen) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLoanOpen
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventLoanOpen) Type() protoreflect.MessageType {
	return _fastReflection_EventLoanOpen_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventLoanOpen) New() protoreflect.Message {
	return new(fastReflection_EventLoanOpen)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventLoanOpen) Interface() protoreflect.ProtoMessage {
	return (*EventLoanOpen)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventLoanOpen) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CollateralDeposited != "" {
		value := protoreflect.ValueOfString(x.CollateralDeposited)
		if !f(fd_EventLoanOpen_collateral_deposited, value) {
			return
		}
	}
	if x.CollateralAsset != nil {
		value := protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
		if !f(fd_EventLoanOpen_collateral_asset, value) {
			return
		}
	}
	if x.CollateralizationRatio != "" {
		value := protoreflect.ValueOfString(x.CollateralizationRatio)
		if !f(fd_EventLoanOpen_collateralization_ratio, value) {
			return
		}
	}
	if x.DebtIssued != "" {
		value := protoreflect.ValueOfString(x.DebtIssued)
		if !f(fd_EventLoanOpen_debt_issued, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_EventLoanOpen_owner, value) {
			return
		}
	}
	if x.TargetAsset != nil {
		value := protoreflect.ValueOfMessage(x.TargetAsset.ProtoReflect())
		if !f(fd_EventLoanOpen_target_asset, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventLoanOpen_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventLoanOpen) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventLoanOpen.collateral_deposited":
		return x.CollateralDeposited != ""
	case "types.EventLoanOpen.collateral_asset":
		return x.CollateralAsset != nil
	case "types.EventLoanOpen.collateralization_ratio":
		return x.CollateralizationRatio != ""
	case "types.EventLoanOpen.debt_issued":
		return x.DebtIssued != ""
	case "types.EventLoanOpen.owner":
		return x.Owner != ""
	case "types.EventLoanOpen.target_asset":
		return x.TargetAsset != nil
	case "types.EventLoanOpen.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanOpen) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventLoanOpen.collateral_deposited":
		x.CollateralDeposited = ""
	case "types.EventLoanOpen.collateral_asset":
		x.CollateralAsset = nil
	case "types.EventLoanOpen.collateralization_ratio":
		x.CollateralizationRatio = ""
	case "types.EventLoanOpen.debt_issued":
		x.DebtIssued = ""
	case "types.EventLoanOpen.owner":
		x.Owner = ""
	case "types.EventLoanOpen.target_asset":
		x.TargetAsset = nil
	case "types.EventLoanOpen.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventLoanOpen) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventLoanOpen.collateral_deposited":
		value := x.CollateralDeposited
		return protoreflect.ValueOfString(value)
	case "types.EventLoanOpen.collateral_asset":
		value := x.CollateralAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventLoanOpen.collateralization_ratio":
		value := x.CollateralizationRatio
		return protoreflect.ValueOfString(value)
	case "types.EventLoanOpen.debt_issued":
		value := x.DebtIssued
		return protoreflect.ValueOfString(value)
	case "types.EventLoanOpen.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "types.EventLoanOpen.target_asset":
		value := x.TargetAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventLoanOpen.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanOpen) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventLoanOpen.collateral_deposited":
		x.CollateralDeposited = value.Interface().(string)
	case "types.EventLoanOpen.collateral_asset":
		x.CollateralAsset = value.Message().Interface().(*common.Asset)
	case "types.EventLoanOpen.collateralization_ratio":
		x.CollateralizationRatio = value.Interface().(string)
	case "types.EventLoanOpen.debt_issued":
		x.DebtIssued = value.Interface().(string)
	case "types.EventLoanOpen.owner":
		x.Owner = value.Interface().(string)
	case "types.EventLoanOpen.target_asset":
		x.TargetAsset = value.Message().Interface().(*common.Asset)
	case "types.EventLoanOpen.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanOpen) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLoanOpen.collateral_asset":
		if x.CollateralAsset == nil {
			x.CollateralAsset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
	case "types.EventLoanOpen.target_asset":
		if x.TargetAsset == nil {
			x.TargetAsset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.TargetAsset.ProtoReflect())
	case "types.EventLoanOpen.collateral_deposited":
		panic(fmt.Errorf("field collateral_deposited of message types.EventLoanOpen is not mutable"))
	case "types.EventLoanOpen.collateralization_ratio":
		panic(fmt.Errorf("field collateralization_ratio of message types.EventLoanOpen is not mutable"))
	case "types.EventLoanOpen.debt_issued":
		panic(fmt.Errorf("field debt_issued of message types.EventLoanOpen is not mutable"))
	case "types.EventLoanOpen.owner":
		panic(fmt.Errorf("field owner of message types.EventLoanOpen is not mutable"))
	case "types.EventLoanOpen.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventLoanOpen is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventLoanOpen) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLoanOpen.collateral_deposited":
		return protoreflect.ValueOfString("")
	case "types.EventLoanOpen.collateral_asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventLoanOpen.collateralization_ratio":
		return protoreflect.ValueOfString("")
	case "types.EventLoanOpen.debt_issued":
		return protoreflect.ValueOfString("")
	case "types.EventLoanOpen.owner":
		return protoreflect.ValueOfString("")
	case "types.EventLoanOpen.target_asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventLoanOpen.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanOpen"))
		}
		panic(fmt.Errorf("message types.EventLoanOpen does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventLoanOpen) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventLoanOpen", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventLoanOpen) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanOpen) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventLoanOpen) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventLoanOpen) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventLoanOpen)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.CollateralDeposited)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CollateralAsset != nil {
			l = options.Size(x.CollateralAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollateralizationRatio)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DebtIssued)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TargetAsset != nil {
			l = options.Size(x.TargetAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventLoanOpen)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x3a
		}
		if x.TargetAsset != nil {
			encoded, err := options.Marshal(x.TargetAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.DebtIssued) > 0 {
			i -= len(x.DebtIssued)
			copy(dAtA[i:], x.DebtIssued)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DebtIssued)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollateralizationRatio) > 0 {
			i -= len(x.CollateralizationRatio)
			copy(dAtA[i:], x.CollateralizationRatio)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollateralizationRatio)))
			i--
			dAtA[i] = 0x1a
		}
		if x.CollateralAsset != nil {
			encoded, err := options.Marshal(x.CollateralAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.CollateralDeposited) > 0 {
			i -= len(x.CollateralDeposited)
			copy(dAtA[i:], x.CollateralDeposited)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollateralDeposited)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventLoanOpen)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLoanOpen: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLoanOpen: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralDeposited", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollateralDeposited = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CollateralAsset == nil {
					x.CollateralAsset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CollateralAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralizationRatio", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollateralizationRatio = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DebtIssued", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DebtIssued = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TargetAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TargetAsset == nil {
					x.TargetAsset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TargetAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventLoanRepayment                      protoreflect.MessageDescriptor
	fd_EventLoanRepayment_collateral_withdrawn protoreflect.FieldDescriptor
	fd_EventLoanRepayment_collateral_asset     protoreflect.FieldDescriptor
	fd_EventLoanRepayment_debt_repaid          protoreflect.FieldDescriptor
	fd_EventLoanRepayment_owner                protoreflect.FieldDescriptor
	fd_EventLoanRepayment_tx_id                protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventLoanRepayment = File_types_type_events_proto.Messages().ByName("EventLoanRepayment")
	fd_EventLoanRepayment_collateral_withdrawn = md_EventLoanRepayment.Fields().ByName("collateral_withdrawn")
	fd_EventLoanRepayment_collateral_asset = md_EventLoanRepayment.Fields().ByName("collateral_asset")
	fd_EventLoanRepayment_debt_repaid = md_EventLoanRepayment.Fields().ByName("debt_repaid")
	fd_EventLoanRepayment_owner = md_EventLoanRepayment.Fields().ByName("owner")
	fd_EventLoanRepayment_tx_id = md_EventLoanRepayment.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventLoanRepayment)(nil)

type fastReflection_EventLoanRepayment EventLoanRepayment

func (x *EventLoanRepayment) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventLoanRepayment)(x)
}

func (x *EventLoanRepayment) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventLoanRepayment_messageType fastReflection_EventLoanRepayment_messageType
var _ protoreflect.MessageType = fastReflection_EventLoanRepayment_messageType{}

type fastReflection_EventLoanRepayment_messageType struct{}

func (x fastReflection_EventLoanRepayment_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventLoanRepayment)(nil)
}
func (x fastReflection_EventLoanRepayment_messageType) New() protoreflect.Message {
	return new(fastReflection_EventLoanRepayment)
}
func (x fastReflection_EventLoanRepayment_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLoanRepayment
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventLoanRepayment) Descriptor() protoreflect.MessageDescriptor {
	return md_EventLoanRepayment
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventLoanRepayment) Type() protoreflect.MessageType {
	return _fastReflection_EventLoanRepayment_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventLoanRepayment) New() protoreflect.Message {
	return new(fastReflection_EventLoanRepayment)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventLoanRepayment) Interface() protoreflect.ProtoMessage {
	return (*EventLoanRepayment)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventLoanRepayment) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CollateralWithdrawn != "" {
		value := protoreflect.ValueOfString(x.CollateralWithdrawn)
		if !f(fd_EventLoanRepayment_collateral_withdrawn, value) {
			return
		}
	}
	if x.CollateralAsset != nil {
		value := protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
		if !f(fd_EventLoanRepayment_collateral_asset, value) {
			return
		}
	}
	if x.DebtRepaid != "" {
		value := protoreflect.ValueOfString(x.DebtRepaid)
		if !f(fd_EventLoanRepayment_debt_repaid, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_EventLoanRepayment_owner, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventLoanRepayment_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventLoanRepayment) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventLoanRepayment.collateral_withdrawn":
		return x.CollateralWithdrawn != ""
	case "types.EventLoanRepayment.collateral_asset":
		return x.CollateralAsset != nil
	case "types.EventLoanRepayment.debt_repaid":
		return x.DebtRepaid != ""
	case "types.EventLoanRepayment.owner":
		return x.Owner != ""
	case "types.EventLoanRepayment.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanRepayment) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventLoanRepayment.collateral_withdrawn":
		x.CollateralWithdrawn = ""
	case "types.EventLoanRepayment.collateral_asset":
		x.CollateralAsset = nil
	case "types.EventLoanRepayment.debt_repaid":
		x.DebtRepaid = ""
	case "types.EventLoanRepayment.owner":
		x.Owner = ""
	case "types.EventLoanRepayment.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventLoanRepayment) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventLoanRepayment.collateral_withdrawn":
		value := x.CollateralWithdrawn
		return protoreflect.ValueOfString(value)
	case "types.EventLoanRepayment.collateral_asset":
		value := x.CollateralAsset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventLoanRepayment.debt_repaid":
		value := x.DebtRepaid
		return protoreflect.ValueOfString(value)
	case "types.EventLoanRepayment.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "types.EventLoanRepayment.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanRepayment) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventLoanRepayment.collateral_withdrawn":
		x.CollateralWithdrawn = value.Interface().(string)
	case "types.EventLoanRepayment.collateral_asset":
		x.CollateralAsset = value.Message().Interface().(*common.Asset)
	case "types.EventLoanRepayment.debt_repaid":
		x.DebtRepaid = value.Interface().(string)
	case "types.EventLoanRepayment.owner":
		x.Owner = value.Interface().(string)
	case "types.EventLoanRepayment.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanRepayment) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLoanRepayment.collateral_asset":
		if x.CollateralAsset == nil {
			x.CollateralAsset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.CollateralAsset.ProtoReflect())
	case "types.EventLoanRepayment.collateral_withdrawn":
		panic(fmt.Errorf("field collateral_withdrawn of message types.EventLoanRepayment is not mutable"))
	case "types.EventLoanRepayment.debt_repaid":
		panic(fmt.Errorf("field debt_repaid of message types.EventLoanRepayment is not mutable"))
	case "types.EventLoanRepayment.owner":
		panic(fmt.Errorf("field owner of message types.EventLoanRepayment is not mutable"))
	case "types.EventLoanRepayment.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventLoanRepayment is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventLoanRepayment) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventLoanRepayment.collateral_withdrawn":
		return protoreflect.ValueOfString("")
	case "types.EventLoanRepayment.collateral_asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventLoanRepayment.debt_repaid":
		return protoreflect.ValueOfString("")
	case "types.EventLoanRepayment.owner":
		return protoreflect.ValueOfString("")
	case "types.EventLoanRepayment.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventLoanRepayment"))
		}
		panic(fmt.Errorf("message types.EventLoanRepayment does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventLoanRepayment) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventLoanRepayment", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventLoanRepayment) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventLoanRepayment) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventLoanRepayment) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventLoanRepayment) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventLoanRepayment)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.CollateralWithdrawn)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CollateralAsset != nil {
			l = options.Size(x.CollateralAsset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DebtRepaid)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventLoanRepayment)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.DebtRepaid) > 0 {
			i -= len(x.DebtRepaid)
			copy(dAtA[i:], x.DebtRepaid)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DebtRepaid)))
			i--
			dAtA[i] = 0x1a
		}
		if x.CollateralAsset != nil {
			encoded, err := options.Marshal(x.CollateralAsset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.CollateralWithdrawn) > 0 {
			i -= len(x.CollateralWithdrawn)
			copy(dAtA[i:], x.CollateralWithdrawn)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollateralWithdrawn)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventLoanRepayment)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLoanRepayment: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventLoanRepayment: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralWithdrawn", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollateralWithdrawn = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollateralAsset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CollateralAsset == nil {
					x.CollateralAsset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CollateralAsset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DebtRepaid", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DebtRepaid = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTHORName                  protoreflect.MessageDescriptor
	fd_EventTHORName_name             protoreflect.FieldDescriptor
	fd_EventTHORName_chain            protoreflect.FieldDescriptor
	fd_EventTHORName_address          protoreflect.FieldDescriptor
	fd_EventTHORName_registration_fee protoreflect.FieldDescriptor
	fd_EventTHORName_fund_amt         protoreflect.FieldDescriptor
	fd_EventTHORName_expire           protoreflect.FieldDescriptor
	fd_EventTHORName_owner            protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTHORName = File_types_type_events_proto.Messages().ByName("EventTHORName")
	fd_EventTHORName_name = md_EventTHORName.Fields().ByName("name")
	fd_EventTHORName_chain = md_EventTHORName.Fields().ByName("chain")
	fd_EventTHORName_address = md_EventTHORName.Fields().ByName("address")
	fd_EventTHORName_registration_fee = md_EventTHORName.Fields().ByName("registration_fee")
	fd_EventTHORName_fund_amt = md_EventTHORName.Fields().ByName("fund_amt")
	fd_EventTHORName_expire = md_EventTHORName.Fields().ByName("expire")
	fd_EventTHORName_owner = md_EventTHORName.Fields().ByName("owner")
}

var _ protoreflect.Message = (*fastReflection_EventTHORName)(nil)

type fastReflection_EventTHORName EventTHORName

func (x *EventTHORName) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTHORName)(x)
}

func (x *EventTHORName) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTHORName_messageType fastReflection_EventTHORName_messageType
var _ protoreflect.MessageType = fastReflection_EventTHORName_messageType{}

type fastReflection_EventTHORName_messageType struct{}

func (x fastReflection_EventTHORName_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTHORName)(nil)
}
func (x fastReflection_EventTHORName_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTHORName)
}
func (x fastReflection_EventTHORName_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTHORName
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTHORName) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTHORName
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTHORName) Type() protoreflect.MessageType {
	return _fastReflection_EventTHORName_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTHORName) New() protoreflect.Message {
	return new(fastReflection_EventTHORName)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTHORName) Interface() protoreflect.ProtoMessage {
	return (*EventTHORName)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTHORName) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Name != "" {
		value := protoreflect.ValueOfString(x.Name)
		if !f(fd_EventTHORName_name, value) {
			return
		}
	}
	if x.Chain != "" {
		value := protoreflect.ValueOfString(x.Chain)
		if !f(fd_EventTHORName_chain, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventTHORName_address, value) {
			return
		}
	}
	if x.RegistrationFee != "" {
		value := protoreflect.ValueOfString(x.RegistrationFee)
		if !f(fd_EventTHORName_registration_fee, value) {
			return
		}
	}
	if x.FundAmt != "" {
		value := protoreflect.ValueOfString(x.FundAmt)
		if !f(fd_EventTHORName_fund_amt, value) {
			return
		}
	}
	if x.Expire != int64(0) {
		value := protoreflect.ValueOfInt64(x.Expire)
		if !f(fd_EventTHORName_expire, value) {
			return
		}
	}
	if len(x.Owner) != 0 {
		value := protoreflect.ValueOfBytes(x.Owner)
		if !f(fd_EventTHORName_owner, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTHORName) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTHORName.name":
		return x.Name != ""
	case "types.EventTHORName.chain":
		return x.Chain != ""
	case "types.EventTHORName.address":
		return x.Address != ""
	case "types.EventTHORName.registration_fee":
		return x.RegistrationFee != ""
	case "types.EventTHORName.fund_amt":
		return x.FundAmt != ""
	case "types.EventTHORName.expire":
		return x.Expire != int64(0)
	case "types.EventTHORName.owner":
		return len(x.Owner) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTHORName) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTHORName.name":
		x.Name = ""
	case "types.EventTHORName.chain":
		x.Chain = ""
	case "types.EventTHORName.address":
		x.Address = ""
	case "types.EventTHORName.registration_fee":
		x.RegistrationFee = ""
	case "types.EventTHORName.fund_amt":
		x.FundAmt = ""
	case "types.EventTHORName.expire":
		x.Expire = int64(0)
	case "types.EventTHORName.owner":
		x.Owner = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTHORName) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTHORName.name":
		value := x.Name
		return protoreflect.ValueOfString(value)
	case "types.EventTHORName.chain":
		value := x.Chain
		return protoreflect.ValueOfString(value)
	case "types.EventTHORName.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "types.EventTHORName.registration_fee":
		value := x.RegistrationFee
		return protoreflect.ValueOfString(value)
	case "types.EventTHORName.fund_amt":
		value := x.FundAmt
		return protoreflect.ValueOfString(value)
	case "types.EventTHORName.expire":
		value := x.Expire
		return protoreflect.ValueOfInt64(value)
	case "types.EventTHORName.owner":
		value := x.Owner
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTHORName) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTHORName.name":
		x.Name = value.Interface().(string)
	case "types.EventTHORName.chain":
		x.Chain = value.Interface().(string)
	case "types.EventTHORName.address":
		x.Address = value.Interface().(string)
	case "types.EventTHORName.registration_fee":
		x.RegistrationFee = value.Interface().(string)
	case "types.EventTHORName.fund_amt":
		x.FundAmt = value.Interface().(string)
	case "types.EventTHORName.expire":
		x.Expire = value.Int()
	case "types.EventTHORName.owner":
		x.Owner = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTHORName) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTHORName.name":
		panic(fmt.Errorf("field name of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.chain":
		panic(fmt.Errorf("field chain of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.address":
		panic(fmt.Errorf("field address of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.registration_fee":
		panic(fmt.Errorf("field registration_fee of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.fund_amt":
		panic(fmt.Errorf("field fund_amt of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.expire":
		panic(fmt.Errorf("field expire of message types.EventTHORName is not mutable"))
	case "types.EventTHORName.owner":
		panic(fmt.Errorf("field owner of message types.EventTHORName is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTHORName) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTHORName.name":
		return protoreflect.ValueOfString("")
	case "types.EventTHORName.chain":
		return protoreflect.ValueOfString("")
	case "types.EventTHORName.address":
		return protoreflect.ValueOfString("")
	case "types.EventTHORName.registration_fee":
		return protoreflect.ValueOfString("")
	case "types.EventTHORName.fund_amt":
		return protoreflect.ValueOfString("")
	case "types.EventTHORName.expire":
		return protoreflect.ValueOfInt64(int64(0))
	case "types.EventTHORName.owner":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTHORName"))
		}
		panic(fmt.Errorf("message types.EventTHORName does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTHORName) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTHORName", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTHORName) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTHORName) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTHORName) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTHORName) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTHORName)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Name)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Chain)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RegistrationFee)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.FundAmt)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Expire != 0 {
			n += 1 + runtime.Sov(uint64(x.Expire))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTHORName)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x3a
		}
		if x.Expire != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Expire))
			i--
			dAtA[i] = 0x30
		}
		if len(x.FundAmt) > 0 {
			i -= len(x.FundAmt)
			copy(dAtA[i:], x.FundAmt)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FundAmt)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RegistrationFee) > 0 {
			i -= len(x.RegistrationFee)
			copy(dAtA[i:], x.RegistrationFee)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RegistrationFee)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Chain) > 0 {
			i -= len(x.Chain)
			copy(dAtA[i:], x.Chain)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Chain)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Name) > 0 {
			i -= len(x.Name)
			copy(dAtA[i:], x.Name)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Name)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTHORName)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTHORName: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTHORName: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Name = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Chain = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RegistrationFee = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FundAmt", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FundAmt = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
				}
				x.Expire = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Expire |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = append(x.Owner[:0], dAtA[iNdEx:postIndex]...)
				if x.Owner == nil {
					x.Owner = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSetMimir       protoreflect.MessageDescriptor
	fd_EventSetMimir_key   protoreflect.FieldDescriptor
	fd_EventSetMimir_value protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSetMimir = File_types_type_events_proto.Messages().ByName("EventSetMimir")
	fd_EventSetMimir_key = md_EventSetMimir.Fields().ByName("key")
	fd_EventSetMimir_value = md_EventSetMimir.Fields().ByName("value")
}

var _ protoreflect.Message = (*fastReflection_EventSetMimir)(nil)

type fastReflection_EventSetMimir EventSetMimir

func (x *EventSetMimir) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSetMimir)(x)
}

func (x *EventSetMimir) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSetMimir_messageType fastReflection_EventSetMimir_messageType
var _ protoreflect.MessageType = fastReflection_EventSetMimir_messageType{}

type fastReflection_EventSetMimir_messageType struct{}

func (x fastReflection_EventSetMimir_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSetMimir)(nil)
}
func (x fastReflection_EventSetMimir_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSetMimir)
}
func (x fastReflection_EventSetMimir_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSetMimir
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSetMimir) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSetMimir
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSetMimir) Type() protoreflect.MessageType {
	return _fastReflection_EventSetMimir_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSetMimir) New() protoreflect.Message {
	return new(fastReflection_EventSetMimir)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSetMimir) Interface() protoreflect.ProtoMessage {
	return (*EventSetMimir)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSetMimir) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Key != "" {
		value := protoreflect.ValueOfString(x.Key)
		if !f(fd_EventSetMimir_key, value) {
			return
		}
	}
	if x.Value != "" {
		value := protoreflect.ValueOfString(x.Value)
		if !f(fd_EventSetMimir_value, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSetMimir) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSetMimir.key":
		return x.Key != ""
	case "types.EventSetMimir.value":
		return x.Value != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetMimir) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSetMimir.key":
		x.Key = ""
	case "types.EventSetMimir.value":
		x.Value = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSetMimir) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSetMimir.key":
		value := x.Key
		return protoreflect.ValueOfString(value)
	case "types.EventSetMimir.value":
		value := x.Value
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetMimir) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSetMimir.key":
		x.Key = value.Interface().(string)
	case "types.EventSetMimir.value":
		x.Value = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetMimir) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSetMimir.key":
		panic(fmt.Errorf("field key of message types.EventSetMimir is not mutable"))
	case "types.EventSetMimir.value":
		panic(fmt.Errorf("field value of message types.EventSetMimir is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSetMimir) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSetMimir.key":
		return protoreflect.ValueOfString("")
	case "types.EventSetMimir.value":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetMimir"))
		}
		panic(fmt.Errorf("message types.EventSetMimir does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSetMimir) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSetMimir", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSetMimir) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetMimir) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSetMimir) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSetMimir) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSetMimir)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSetMimir)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSetMimir)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSetMimir: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSetMimir: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSetNodeMimir         protoreflect.MessageDescriptor
	fd_EventSetNodeMimir_key     protoreflect.FieldDescriptor
	fd_EventSetNodeMimir_value   protoreflect.FieldDescriptor
	fd_EventSetNodeMimir_address protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSetNodeMimir = File_types_type_events_proto.Messages().ByName("EventSetNodeMimir")
	fd_EventSetNodeMimir_key = md_EventSetNodeMimir.Fields().ByName("key")
	fd_EventSetNodeMimir_value = md_EventSetNodeMimir.Fields().ByName("value")
	fd_EventSetNodeMimir_address = md_EventSetNodeMimir.Fields().ByName("address")
}

var _ protoreflect.Message = (*fastReflection_EventSetNodeMimir)(nil)

type fastReflection_EventSetNodeMimir EventSetNodeMimir

func (x *EventSetNodeMimir) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSetNodeMimir)(x)
}

func (x *EventSetNodeMimir) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSetNodeMimir_messageType fastReflection_EventSetNodeMimir_messageType
var _ protoreflect.MessageType = fastReflection_EventSetNodeMimir_messageType{}

type fastReflection_EventSetNodeMimir_messageType struct{}

func (x fastReflection_EventSetNodeMimir_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSetNodeMimir)(nil)
}
func (x fastReflection_EventSetNodeMimir_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSetNodeMimir)
}
func (x fastReflection_EventSetNodeMimir_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSetNodeMimir
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSetNodeMimir) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSetNodeMimir
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSetNodeMimir) Type() protoreflect.MessageType {
	return _fastReflection_EventSetNodeMimir_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSetNodeMimir) New() protoreflect.Message {
	return new(fastReflection_EventSetNodeMimir)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSetNodeMimir) Interface() protoreflect.ProtoMessage {
	return (*EventSetNodeMimir)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSetNodeMimir) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Key != "" {
		value := protoreflect.ValueOfString(x.Key)
		if !f(fd_EventSetNodeMimir_key, value) {
			return
		}
	}
	if x.Value != "" {
		value := protoreflect.ValueOfString(x.Value)
		if !f(fd_EventSetNodeMimir_value, value) {
			return
		}
	}
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventSetNodeMimir_address, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSetNodeMimir) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSetNodeMimir.key":
		return x.Key != ""
	case "types.EventSetNodeMimir.value":
		return x.Value != ""
	case "types.EventSetNodeMimir.address":
		return x.Address != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetNodeMimir) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSetNodeMimir.key":
		x.Key = ""
	case "types.EventSetNodeMimir.value":
		x.Value = ""
	case "types.EventSetNodeMimir.address":
		x.Address = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSetNodeMimir) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSetNodeMimir.key":
		value := x.Key
		return protoreflect.ValueOfString(value)
	case "types.EventSetNodeMimir.value":
		value := x.Value
		return protoreflect.ValueOfString(value)
	case "types.EventSetNodeMimir.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetNodeMimir) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSetNodeMimir.key":
		x.Key = value.Interface().(string)
	case "types.EventSetNodeMimir.value":
		x.Value = value.Interface().(string)
	case "types.EventSetNodeMimir.address":
		x.Address = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetNodeMimir) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSetNodeMimir.key":
		panic(fmt.Errorf("field key of message types.EventSetNodeMimir is not mutable"))
	case "types.EventSetNodeMimir.value":
		panic(fmt.Errorf("field value of message types.EventSetNodeMimir is not mutable"))
	case "types.EventSetNodeMimir.address":
		panic(fmt.Errorf("field address of message types.EventSetNodeMimir is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSetNodeMimir) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSetNodeMimir.key":
		return protoreflect.ValueOfString("")
	case "types.EventSetNodeMimir.value":
		return protoreflect.ValueOfString("")
	case "types.EventSetNodeMimir.address":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSetNodeMimir"))
		}
		panic(fmt.Errorf("message types.EventSetNodeMimir does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSetNodeMimir) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSetNodeMimir", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSetNodeMimir) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSetNodeMimir) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSetNodeMimir) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSetNodeMimir) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSetNodeMimir)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Key)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSetNodeMimir)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Key) > 0 {
			i -= len(x.Key)
			copy(dAtA[i:], x.Key)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Key)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSetNodeMimir)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSetNodeMimir: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSetNodeMimir: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Key = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventVersion         protoreflect.MessageDescriptor
	fd_EventVersion_version protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventVersion = File_types_type_events_proto.Messages().ByName("EventVersion")
	fd_EventVersion_version = md_EventVersion.Fields().ByName("version")
}

var _ protoreflect.Message = (*fastReflection_EventVersion)(nil)

type fastReflection_EventVersion EventVersion

func (x *EventVersion) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventVersion)(x)
}

func (x *EventVersion) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventVersion_messageType fastReflection_EventVersion_messageType
var _ protoreflect.MessageType = fastReflection_EventVersion_messageType{}

type fastReflection_EventVersion_messageType struct{}

func (x fastReflection_EventVersion_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventVersion)(nil)
}
func (x fastReflection_EventVersion_messageType) New() protoreflect.Message {
	return new(fastReflection_EventVersion)
}
func (x fastReflection_EventVersion_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventVersion
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventVersion) Descriptor() protoreflect.MessageDescriptor {
	return md_EventVersion
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventVersion) Type() protoreflect.MessageType {
	return _fastReflection_EventVersion_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventVersion) New() protoreflect.Message {
	return new(fastReflection_EventVersion)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventVersion) Interface() protoreflect.ProtoMessage {
	return (*EventVersion)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventVersion) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Version != "" {
		value := protoreflect.ValueOfString(x.Version)
		if !f(fd_EventVersion_version, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventVersion) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventVersion.version":
		return x.Version != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventVersion) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventVersion.version":
		x.Version = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventVersion) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventVersion.version":
		value := x.Version
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventVersion) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventVersion.version":
		x.Version = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventVersion) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventVersion.version":
		panic(fmt.Errorf("field version of message types.EventVersion is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventVersion) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventVersion.version":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventVersion"))
		}
		panic(fmt.Errorf("message types.EventVersion does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventVersion) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventVersion", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventVersion) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventVersion) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventVersion) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventVersion) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventVersion)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Version)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventVersion)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Version) > 0 {
			i -= len(x.Version)
			copy(dAtA[i:], x.Version)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Version)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventVersion)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventVersion: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventVersion: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Version = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventSwitch               protoreflect.MessageDescriptor
	fd_EventSwitch_amount        protoreflect.FieldDescriptor
	fd_EventSwitch_asset         protoreflect.FieldDescriptor
	fd_EventSwitch_asset_address protoreflect.FieldDescriptor
	fd_EventSwitch_rune_address  protoreflect.FieldDescriptor
	fd_EventSwitch_tx_id         protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventSwitch = File_types_type_events_proto.Messages().ByName("EventSwitch")
	fd_EventSwitch_amount = md_EventSwitch.Fields().ByName("amount")
	fd_EventSwitch_asset = md_EventSwitch.Fields().ByName("asset")
	fd_EventSwitch_asset_address = md_EventSwitch.Fields().ByName("asset_address")
	fd_EventSwitch_rune_address = md_EventSwitch.Fields().ByName("rune_address")
	fd_EventSwitch_tx_id = md_EventSwitch.Fields().ByName("tx_id")
}

var _ protoreflect.Message = (*fastReflection_EventSwitch)(nil)

type fastReflection_EventSwitch EventSwitch

func (x *EventSwitch) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventSwitch)(x)
}

func (x *EventSwitch) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventSwitch_messageType fastReflection_EventSwitch_messageType
var _ protoreflect.MessageType = fastReflection_EventSwitch_messageType{}

type fastReflection_EventSwitch_messageType struct{}

func (x fastReflection_EventSwitch_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventSwitch)(nil)
}
func (x fastReflection_EventSwitch_messageType) New() protoreflect.Message {
	return new(fastReflection_EventSwitch)
}
func (x fastReflection_EventSwitch_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSwitch
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventSwitch) Descriptor() protoreflect.MessageDescriptor {
	return md_EventSwitch
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventSwitch) Type() protoreflect.MessageType {
	return _fastReflection_EventSwitch_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventSwitch) New() protoreflect.Message {
	return new(fastReflection_EventSwitch)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventSwitch) Interface() protoreflect.ProtoMessage {
	return (*EventSwitch)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventSwitch) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventSwitch_amount, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventSwitch_asset, value) {
			return
		}
	}
	if x.AssetAddress != "" {
		value := protoreflect.ValueOfString(x.AssetAddress)
		if !f(fd_EventSwitch_asset_address, value) {
			return
		}
	}
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventSwitch_rune_address, value) {
			return
		}
	}
	if x.TxId != "" {
		value := protoreflect.ValueOfString(x.TxId)
		if !f(fd_EventSwitch_tx_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventSwitch) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventSwitch.amount":
		return x.Amount != ""
	case "types.EventSwitch.asset":
		return x.Asset != nil
	case "types.EventSwitch.asset_address":
		return x.AssetAddress != ""
	case "types.EventSwitch.rune_address":
		return x.RuneAddress != ""
	case "types.EventSwitch.tx_id":
		return x.TxId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwitch) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventSwitch.amount":
		x.Amount = ""
	case "types.EventSwitch.asset":
		x.Asset = nil
	case "types.EventSwitch.asset_address":
		x.AssetAddress = ""
	case "types.EventSwitch.rune_address":
		x.RuneAddress = ""
	case "types.EventSwitch.tx_id":
		x.TxId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventSwitch) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventSwitch.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "types.EventSwitch.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "types.EventSwitch.asset_address":
		value := x.AssetAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSwitch.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventSwitch.tx_id":
		value := x.TxId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwitch) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventSwitch.amount":
		x.Amount = value.Interface().(string)
	case "types.EventSwitch.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	case "types.EventSwitch.asset_address":
		x.AssetAddress = value.Interface().(string)
	case "types.EventSwitch.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventSwitch.tx_id":
		x.TxId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwitch) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSwitch.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventSwitch.amount":
		panic(fmt.Errorf("field amount of message types.EventSwitch is not mutable"))
	case "types.EventSwitch.asset_address":
		panic(fmt.Errorf("field asset_address of message types.EventSwitch is not mutable"))
	case "types.EventSwitch.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventSwitch is not mutable"))
	case "types.EventSwitch.tx_id":
		panic(fmt.Errorf("field tx_id of message types.EventSwitch is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventSwitch) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventSwitch.amount":
		return protoreflect.ValueOfString("")
	case "types.EventSwitch.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "types.EventSwitch.asset_address":
		return protoreflect.ValueOfString("")
	case "types.EventSwitch.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventSwitch.tx_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventSwitch"))
		}
		panic(fmt.Errorf("message types.EventSwitch does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventSwitch) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventSwitch", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventSwitch) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventSwitch) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventSwitch) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventSwitch) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventSwitch)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.AssetAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TxId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventSwitch)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.TxId) > 0 {
			i -= len(x.TxId)
			copy(dAtA[i:], x.TxId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TxId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.AssetAddress) > 0 {
			i -= len(x.AssetAddress)
			copy(dAtA[i:], x.AssetAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.AssetAddress)))
			i--
			dAtA[i] = 0x1a
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventSwitch)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSwitch: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AssetAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.AssetAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TxId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTCYDistribution              protoreflect.MessageDescriptor
	fd_EventTCYDistribution_rune_address protoreflect.FieldDescriptor
	fd_EventTCYDistribution_rune_amount  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTCYDistribution = File_types_type_events_proto.Messages().ByName("EventTCYDistribution")
	fd_EventTCYDistribution_rune_address = md_EventTCYDistribution.Fields().ByName("rune_address")
	fd_EventTCYDistribution_rune_amount = md_EventTCYDistribution.Fields().ByName("rune_amount")
}

var _ protoreflect.Message = (*fastReflection_EventTCYDistribution)(nil)

type fastReflection_EventTCYDistribution EventTCYDistribution

func (x *EventTCYDistribution) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTCYDistribution)(x)
}

func (x *EventTCYDistribution) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTCYDistribution_messageType fastReflection_EventTCYDistribution_messageType
var _ protoreflect.MessageType = fastReflection_EventTCYDistribution_messageType{}

type fastReflection_EventTCYDistribution_messageType struct{}

func (x fastReflection_EventTCYDistribution_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTCYDistribution)(nil)
}
func (x fastReflection_EventTCYDistribution_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTCYDistribution)
}
func (x fastReflection_EventTCYDistribution_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYDistribution
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTCYDistribution) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYDistribution
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTCYDistribution) Type() protoreflect.MessageType {
	return _fastReflection_EventTCYDistribution_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTCYDistribution) New() protoreflect.Message {
	return new(fastReflection_EventTCYDistribution)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTCYDistribution) Interface() protoreflect.ProtoMessage {
	return (*EventTCYDistribution)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTCYDistribution) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.RuneAddress) != 0 {
		value := protoreflect.ValueOfBytes(x.RuneAddress)
		if !f(fd_EventTCYDistribution_rune_address, value) {
			return
		}
	}
	if x.RuneAmount != "" {
		value := protoreflect.ValueOfString(x.RuneAmount)
		if !f(fd_EventTCYDistribution_rune_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTCYDistribution) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTCYDistribution.rune_address":
		return len(x.RuneAddress) != 0
	case "types.EventTCYDistribution.rune_amount":
		return x.RuneAmount != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYDistribution) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTCYDistribution.rune_address":
		x.RuneAddress = nil
	case "types.EventTCYDistribution.rune_amount":
		x.RuneAmount = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTCYDistribution) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTCYDistribution.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfBytes(value)
	case "types.EventTCYDistribution.rune_amount":
		value := x.RuneAmount
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYDistribution) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTCYDistribution.rune_address":
		x.RuneAddress = value.Bytes()
	case "types.EventTCYDistribution.rune_amount":
		x.RuneAmount = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYDistribution) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYDistribution.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventTCYDistribution is not mutable"))
	case "types.EventTCYDistribution.rune_amount":
		panic(fmt.Errorf("field rune_amount of message types.EventTCYDistribution is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTCYDistribution) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYDistribution.rune_address":
		return protoreflect.ValueOfBytes(nil)
	case "types.EventTCYDistribution.rune_amount":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYDistribution"))
		}
		panic(fmt.Errorf("message types.EventTCYDistribution does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTCYDistribution) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTCYDistribution", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTCYDistribution) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYDistribution) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTCYDistribution) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTCYDistribution) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTCYDistribution)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RuneAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYDistribution)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RuneAmount) > 0 {
			i -= len(x.RuneAmount)
			copy(dAtA[i:], x.RuneAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYDistribution)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYDistribution: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = append(x.RuneAddress[:0], dAtA[iNdEx:postIndex]...)
				if x.RuneAddress == nil {
					x.RuneAddress = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTCYClaim              protoreflect.MessageDescriptor
	fd_EventTCYClaim_rune_address protoreflect.FieldDescriptor
	fd_EventTCYClaim_tcy_amount   protoreflect.FieldDescriptor
	fd_EventTCYClaim_l1_address   protoreflect.FieldDescriptor
	fd_EventTCYClaim_asset        protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTCYClaim = File_types_type_events_proto.Messages().ByName("EventTCYClaim")
	fd_EventTCYClaim_rune_address = md_EventTCYClaim.Fields().ByName("rune_address")
	fd_EventTCYClaim_tcy_amount = md_EventTCYClaim.Fields().ByName("tcy_amount")
	fd_EventTCYClaim_l1_address = md_EventTCYClaim.Fields().ByName("l1_address")
	fd_EventTCYClaim_asset = md_EventTCYClaim.Fields().ByName("asset")
}

var _ protoreflect.Message = (*fastReflection_EventTCYClaim)(nil)

type fastReflection_EventTCYClaim EventTCYClaim

func (x *EventTCYClaim) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTCYClaim)(x)
}

func (x *EventTCYClaim) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTCYClaim_messageType fastReflection_EventTCYClaim_messageType
var _ protoreflect.MessageType = fastReflection_EventTCYClaim_messageType{}

type fastReflection_EventTCYClaim_messageType struct{}

func (x fastReflection_EventTCYClaim_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTCYClaim)(nil)
}
func (x fastReflection_EventTCYClaim_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTCYClaim)
}
func (x fastReflection_EventTCYClaim_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYClaim
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTCYClaim) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYClaim
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTCYClaim) Type() protoreflect.MessageType {
	return _fastReflection_EventTCYClaim_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTCYClaim) New() protoreflect.Message {
	return new(fastReflection_EventTCYClaim)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTCYClaim) Interface() protoreflect.ProtoMessage {
	return (*EventTCYClaim)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTCYClaim) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.RuneAddress != "" {
		value := protoreflect.ValueOfString(x.RuneAddress)
		if !f(fd_EventTCYClaim_rune_address, value) {
			return
		}
	}
	if x.TcyAmount != "" {
		value := protoreflect.ValueOfString(x.TcyAmount)
		if !f(fd_EventTCYClaim_tcy_amount, value) {
			return
		}
	}
	if x.L1Address != "" {
		value := protoreflect.ValueOfString(x.L1Address)
		if !f(fd_EventTCYClaim_l1_address, value) {
			return
		}
	}
	if x.Asset != nil {
		value := protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
		if !f(fd_EventTCYClaim_asset, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTCYClaim) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTCYClaim.rune_address":
		return x.RuneAddress != ""
	case "types.EventTCYClaim.tcy_amount":
		return x.TcyAmount != ""
	case "types.EventTCYClaim.l1_address":
		return x.L1Address != ""
	case "types.EventTCYClaim.asset":
		return x.Asset != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYClaim) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTCYClaim.rune_address":
		x.RuneAddress = ""
	case "types.EventTCYClaim.tcy_amount":
		x.TcyAmount = ""
	case "types.EventTCYClaim.l1_address":
		x.L1Address = ""
	case "types.EventTCYClaim.asset":
		x.Asset = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTCYClaim) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTCYClaim.rune_address":
		value := x.RuneAddress
		return protoreflect.ValueOfString(value)
	case "types.EventTCYClaim.tcy_amount":
		value := x.TcyAmount
		return protoreflect.ValueOfString(value)
	case "types.EventTCYClaim.l1_address":
		value := x.L1Address
		return protoreflect.ValueOfString(value)
	case "types.EventTCYClaim.asset":
		value := x.Asset
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYClaim) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTCYClaim.rune_address":
		x.RuneAddress = value.Interface().(string)
	case "types.EventTCYClaim.tcy_amount":
		x.TcyAmount = value.Interface().(string)
	case "types.EventTCYClaim.l1_address":
		x.L1Address = value.Interface().(string)
	case "types.EventTCYClaim.asset":
		x.Asset = value.Message().Interface().(*common.Asset)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYClaim) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYClaim.asset":
		if x.Asset == nil {
			x.Asset = new(common.Asset)
		}
		return protoreflect.ValueOfMessage(x.Asset.ProtoReflect())
	case "types.EventTCYClaim.rune_address":
		panic(fmt.Errorf("field rune_address of message types.EventTCYClaim is not mutable"))
	case "types.EventTCYClaim.tcy_amount":
		panic(fmt.Errorf("field tcy_amount of message types.EventTCYClaim is not mutable"))
	case "types.EventTCYClaim.l1_address":
		panic(fmt.Errorf("field l1_address of message types.EventTCYClaim is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTCYClaim) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYClaim.rune_address":
		return protoreflect.ValueOfString("")
	case "types.EventTCYClaim.tcy_amount":
		return protoreflect.ValueOfString("")
	case "types.EventTCYClaim.l1_address":
		return protoreflect.ValueOfString("")
	case "types.EventTCYClaim.asset":
		m := new(common.Asset)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYClaim"))
		}
		panic(fmt.Errorf("message types.EventTCYClaim does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTCYClaim) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTCYClaim", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTCYClaim) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYClaim) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTCYClaim) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTCYClaim) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTCYClaim)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.RuneAddress)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TcyAmount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.L1Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Asset != nil {
			l = options.Size(x.Asset)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYClaim)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Asset != nil {
			encoded, err := options.Marshal(x.Asset)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.L1Address) > 0 {
			i -= len(x.L1Address)
			copy(dAtA[i:], x.L1Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.L1Address)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TcyAmount) > 0 {
			i -= len(x.TcyAmount)
			copy(dAtA[i:], x.TcyAmount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TcyAmount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.RuneAddress) > 0 {
			i -= len(x.RuneAddress)
			copy(dAtA[i:], x.RuneAddress)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RuneAddress)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYClaim)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYClaim: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYClaim: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RuneAddress", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RuneAddress = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TcyAmount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TcyAmount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field L1Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.L1Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Asset == nil {
					x.Asset = &common.Asset{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Asset); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTCYStake         protoreflect.MessageDescriptor
	fd_EventTCYStake_address protoreflect.FieldDescriptor
	fd_EventTCYStake_amount  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTCYStake = File_types_type_events_proto.Messages().ByName("EventTCYStake")
	fd_EventTCYStake_address = md_EventTCYStake.Fields().ByName("address")
	fd_EventTCYStake_amount = md_EventTCYStake.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_EventTCYStake)(nil)

type fastReflection_EventTCYStake EventTCYStake

func (x *EventTCYStake) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTCYStake)(x)
}

func (x *EventTCYStake) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[45]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTCYStake_messageType fastReflection_EventTCYStake_messageType
var _ protoreflect.MessageType = fastReflection_EventTCYStake_messageType{}

type fastReflection_EventTCYStake_messageType struct{}

func (x fastReflection_EventTCYStake_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTCYStake)(nil)
}
func (x fastReflection_EventTCYStake_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTCYStake)
}
func (x fastReflection_EventTCYStake_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYStake
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTCYStake) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYStake
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTCYStake) Type() protoreflect.MessageType {
	return _fastReflection_EventTCYStake_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTCYStake) New() protoreflect.Message {
	return new(fastReflection_EventTCYStake)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTCYStake) Interface() protoreflect.ProtoMessage {
	return (*EventTCYStake)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTCYStake) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventTCYStake_address, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventTCYStake_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTCYStake) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTCYStake.address":
		return x.Address != ""
	case "types.EventTCYStake.amount":
		return x.Amount != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYStake) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTCYStake.address":
		x.Address = ""
	case "types.EventTCYStake.amount":
		x.Amount = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTCYStake) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTCYStake.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "types.EventTCYStake.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYStake) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTCYStake.address":
		x.Address = value.Interface().(string)
	case "types.EventTCYStake.amount":
		x.Amount = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYStake) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYStake.address":
		panic(fmt.Errorf("field address of message types.EventTCYStake is not mutable"))
	case "types.EventTCYStake.amount":
		panic(fmt.Errorf("field amount of message types.EventTCYStake is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTCYStake) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYStake.address":
		return protoreflect.ValueOfString("")
	case "types.EventTCYStake.amount":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYStake"))
		}
		panic(fmt.Errorf("message types.EventTCYStake does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTCYStake) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTCYStake", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTCYStake) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYStake) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTCYStake) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTCYStake) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTCYStake)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYStake)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYStake)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYStake: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYStake: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EventTCYUnstake         protoreflect.MessageDescriptor
	fd_EventTCYUnstake_address protoreflect.FieldDescriptor
	fd_EventTCYUnstake_amount  protoreflect.FieldDescriptor
)

func init() {
	file_types_type_events_proto_init()
	md_EventTCYUnstake = File_types_type_events_proto.Messages().ByName("EventTCYUnstake")
	fd_EventTCYUnstake_address = md_EventTCYUnstake.Fields().ByName("address")
	fd_EventTCYUnstake_amount = md_EventTCYUnstake.Fields().ByName("amount")
}

var _ protoreflect.Message = (*fastReflection_EventTCYUnstake)(nil)

type fastReflection_EventTCYUnstake EventTCYUnstake

func (x *EventTCYUnstake) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EventTCYUnstake)(x)
}

func (x *EventTCYUnstake) slowProtoReflect() protoreflect.Message {
	mi := &file_types_type_events_proto_msgTypes[46]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EventTCYUnstake_messageType fastReflection_EventTCYUnstake_messageType
var _ protoreflect.MessageType = fastReflection_EventTCYUnstake_messageType{}

type fastReflection_EventTCYUnstake_messageType struct{}

func (x fastReflection_EventTCYUnstake_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EventTCYUnstake)(nil)
}
func (x fastReflection_EventTCYUnstake_messageType) New() protoreflect.Message {
	return new(fastReflection_EventTCYUnstake)
}
func (x fastReflection_EventTCYUnstake_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYUnstake
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EventTCYUnstake) Descriptor() protoreflect.MessageDescriptor {
	return md_EventTCYUnstake
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EventTCYUnstake) Type() protoreflect.MessageType {
	return _fastReflection_EventTCYUnstake_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EventTCYUnstake) New() protoreflect.Message {
	return new(fastReflection_EventTCYUnstake)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EventTCYUnstake) Interface() protoreflect.ProtoMessage {
	return (*EventTCYUnstake)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EventTCYUnstake) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Address != "" {
		value := protoreflect.ValueOfString(x.Address)
		if !f(fd_EventTCYUnstake_address, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_EventTCYUnstake_amount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EventTCYUnstake) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "types.EventTCYUnstake.address":
		return x.Address != ""
	case "types.EventTCYUnstake.amount":
		return x.Amount != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYUnstake) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "types.EventTCYUnstake.address":
		x.Address = ""
	case "types.EventTCYUnstake.amount":
		x.Amount = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EventTCYUnstake) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "types.EventTCYUnstake.address":
		value := x.Address
		return protoreflect.ValueOfString(value)
	case "types.EventTCYUnstake.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYUnstake) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "types.EventTCYUnstake.address":
		x.Address = value.Interface().(string)
	case "types.EventTCYUnstake.amount":
		x.Amount = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYUnstake) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYUnstake.address":
		panic(fmt.Errorf("field address of message types.EventTCYUnstake is not mutable"))
	case "types.EventTCYUnstake.amount":
		panic(fmt.Errorf("field amount of message types.EventTCYUnstake is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EventTCYUnstake) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "types.EventTCYUnstake.address":
		return protoreflect.ValueOfString("")
	case "types.EventTCYUnstake.amount":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: types.EventTCYUnstake"))
		}
		panic(fmt.Errorf("message types.EventTCYUnstake does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EventTCYUnstake) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in types.EventTCYUnstake", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EventTCYUnstake) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EventTCYUnstake) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EventTCYUnstake) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EventTCYUnstake) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EventTCYUnstake)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Address)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYUnstake)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Address) > 0 {
			i -= len(x.Address)
			copy(dAtA[i:], x.Address)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Address)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EventTCYUnstake)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYUnstake: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EventTCYUnstake: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Address = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: types/type_events.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PendingLiquidityType int32

const (
	PendingLiquidityType_add      PendingLiquidityType = 0
	PendingLiquidityType_withdraw PendingLiquidityType = 1
)

// Enum value maps for PendingLiquidityType.
var (
	PendingLiquidityType_name = map[int32]string{
		0: "add",
		1: "withdraw",
	}
	PendingLiquidityType_value = map[string]int32{
		"add":      0,
		"withdraw": 1,
	}
)

func (x PendingLiquidityType) Enum() *PendingLiquidityType {
	p := new(PendingLiquidityType)
	*p = x
	return p
}

func (x PendingLiquidityType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PendingLiquidityType) Descriptor() protoreflect.EnumDescriptor {
	return file_types_type_events_proto_enumTypes[0].Descriptor()
}

func (PendingLiquidityType) Type() protoreflect.EnumType {
	return &file_types_type_events_proto_enumTypes[0]
}

func (x PendingLiquidityType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PendingLiquidityType.Descriptor instead.
func (PendingLiquidityType) EnumDescriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{0}
}

type BondType int32

const (
	BondType_bond_paid     BondType = 0
	BondType_bond_returned BondType = 1
	BondType_bond_reward   BondType = 2
	BondType_bond_cost     BondType = 3
)

// Enum value maps for BondType.
var (
	BondType_name = map[int32]string{
		0: "bond_paid",
		1: "bond_returned",
		2: "bond_reward",
		3: "bond_cost",
	}
	BondType_value = map[string]int32{
		"bond_paid":     0,
		"bond_returned": 1,
		"bond_reward":   2,
		"bond_cost":     3,
	}
)

func (x BondType) Enum() *BondType {
	p := new(BondType)
	*p = x
	return p
}

func (x BondType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BondType) Descriptor() protoreflect.EnumDescriptor {
	return file_types_type_events_proto_enumTypes[1].Descriptor()
}

func (BondType) Type() protoreflect.EnumType {
	return &file_types_type_events_proto_enumTypes[1]
}

func (x BondType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BondType.Descriptor instead.
func (BondType) EnumDescriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{1}
}

type MintBurnSupplyType int32

const (
	MintBurnSupplyType_mint MintBurnSupplyType = 0
	MintBurnSupplyType_burn MintBurnSupplyType = 1
)

// Enum value maps for MintBurnSupplyType.
var (
	MintBurnSupplyType_name = map[int32]string{
		0: "mint",
		1: "burn",
	}
	MintBurnSupplyType_value = map[string]int32{
		"mint": 0,
		"burn": 1,
	}
)

func (x MintBurnSupplyType) Enum() *MintBurnSupplyType {
	p := new(MintBurnSupplyType)
	*p = x
	return p
}

func (x MintBurnSupplyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MintBurnSupplyType) Descriptor() protoreflect.EnumDescriptor {
	return file_types_type_events_proto_enumTypes[2].Descriptor()
}

func (MintBurnSupplyType) Type() protoreflect.EnumType {
	return &file_types_type_events_proto_enumTypes[2]
}

func (x MintBurnSupplyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MintBurnSupplyType.Descriptor instead.
func (MintBurnSupplyType) EnumDescriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{2}
}

type PoolMod struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Asset    *common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	RuneAmt  string        `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3" json:"rune_amt,omitempty"`
	RuneAdd  bool          `protobuf:"varint,3,opt,name=rune_add,json=runeAdd,proto3" json:"rune_add,omitempty"`
	AssetAmt string        `protobuf:"bytes,4,opt,name=asset_amt,json=assetAmt,proto3" json:"asset_amt,omitempty"`
	AssetAdd bool          `protobuf:"varint,5,opt,name=asset_add,json=assetAdd,proto3" json:"asset_add,omitempty"`
}

func (x *PoolMod) Reset() {
	*x = PoolMod{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolMod) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolMod) ProtoMessage() {}

// Deprecated: Use PoolMod.ProtoReflect.Descriptor instead.
func (*PoolMod) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{0}
}

func (x *PoolMod) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *PoolMod) GetRuneAmt() string {
	if x != nil {
		return x.RuneAmt
	}
	return ""
}

func (x *PoolMod) GetRuneAdd() bool {
	if x != nil {
		return x.RuneAdd
	}
	return false
}

func (x *PoolMod) GetAssetAmt() string {
	if x != nil {
		return x.AssetAmt
	}
	return ""
}

func (x *PoolMod) GetAssetAdd() bool {
	if x != nil {
		return x.AssetAdd
	}
	return false
}

type EventLimitOrder struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Source *common.Coin `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Target *common.Coin `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	TxId   string       `protobuf:"bytes,3,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventLimitOrder) Reset() {
	*x = EventLimitOrder{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventLimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventLimitOrder) ProtoMessage() {}

// Deprecated: Use EventLimitOrder.ProtoReflect.Descriptor instead.
func (*EventLimitOrder) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{1}
}

func (x *EventLimitOrder) GetSource() *common.Coin {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *EventLimitOrder) GetTarget() *common.Coin {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *EventLimitOrder) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventStreamingSwap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxId              string       `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Interval          uint64       `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Quantity          uint64       `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Count             uint64       `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	LastHeight        int64        `protobuf:"varint,5,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
	TradeTarget       string       `protobuf:"bytes,6,opt,name=trade_target,json=tradeTarget,proto3" json:"trade_target,omitempty"`
	Deposit           *common.Coin `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit,omitempty"`
	In                *common.Coin `protobuf:"bytes,8,opt,name=in,proto3" json:"in,omitempty"`
	Out               *common.Coin `protobuf:"bytes,9,opt,name=out,proto3" json:"out,omitempty"`
	FailedSwaps       []uint64     `protobuf:"varint,10,rep,packed,name=failed_swaps,json=failedSwaps,proto3" json:"failed_swaps,omitempty"`
	FailedSwapReasons []string     `protobuf:"bytes,11,rep,name=failed_swap_reasons,json=failedSwapReasons,proto3" json:"failed_swap_reasons,omitempty"`
}

func (x *EventStreamingSwap) Reset() {
	*x = EventStreamingSwap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventStreamingSwap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventStreamingSwap) ProtoMessage() {}

// Deprecated: Use EventStreamingSwap.ProtoReflect.Descriptor instead.
func (*EventStreamingSwap) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{2}
}

func (x *EventStreamingSwap) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventStreamingSwap) GetInterval() uint64 {
	if x != nil {
		return x.Interval
	}
	return 0
}

func (x *EventStreamingSwap) GetQuantity() uint64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

func (x *EventStreamingSwap) GetCount() uint64 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *EventStreamingSwap) GetLastHeight() int64 {
	if x != nil {
		return x.LastHeight
	}
	return 0
}

func (x *EventStreamingSwap) GetTradeTarget() string {
	if x != nil {
		return x.TradeTarget
	}
	return ""
}

func (x *EventStreamingSwap) GetDeposit() *common.Coin {
	if x != nil {
		return x.Deposit
	}
	return nil
}

func (x *EventStreamingSwap) GetIn() *common.Coin {
	if x != nil {
		return x.In
	}
	return nil
}

func (x *EventStreamingSwap) GetOut() *common.Coin {
	if x != nil {
		return x.Out
	}
	return nil
}

func (x *EventStreamingSwap) GetFailedSwaps() []uint64 {
	if x != nil {
		return x.FailedSwaps
	}
	return nil
}

func (x *EventStreamingSwap) GetFailedSwapReasons() []string {
	if x != nil {
		return x.FailedSwapReasons
	}
	return nil
}

type EventSwap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool                  *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	SwapTarget            string        `protobuf:"bytes,2,opt,name=swap_target,json=swapTarget,proto3" json:"swap_target,omitempty"`
	SwapSlip              string        `protobuf:"bytes,3,opt,name=swap_slip,json=swapSlip,proto3" json:"swap_slip,omitempty"`
	LiquidityFee          string        `protobuf:"bytes,4,opt,name=liquidity_fee,json=liquidityFee,proto3" json:"liquidity_fee,omitempty"`
	LiquidityFeeInRune    string        `protobuf:"bytes,5,opt,name=liquidity_fee_in_rune,json=liquidityFeeInRune,proto3" json:"liquidity_fee_in_rune,omitempty"`
	InTx                  *common.Tx    `protobuf:"bytes,6,opt,name=in_tx,json=inTx,proto3" json:"in_tx,omitempty"`
	OutTxs                *common.Tx    `protobuf:"bytes,7,opt,name=out_txs,json=outTxs,proto3" json:"out_txs,omitempty"`
	EmitAsset             *common.Coin  `protobuf:"bytes,8,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset,omitempty"`
	SynthUnits            string        `protobuf:"bytes,9,opt,name=synth_units,json=synthUnits,proto3" json:"synth_units,omitempty"`
	StreamingSwapQuantity uint64        `protobuf:"varint,10,opt,name=streaming_swap_quantity,json=streamingSwapQuantity,proto3" json:"streaming_swap_quantity,omitempty"`
	StreamingSwapCount    uint64        `protobuf:"varint,11,opt,name=streaming_swap_count,json=streamingSwapCount,proto3" json:"streaming_swap_count,omitempty"`
	PoolSlip              string        `protobuf:"bytes,12,opt,name=pool_slip,json=poolSlip,proto3" json:"pool_slip,omitempty"`
}

func (x *EventSwap) Reset() {
	*x = EventSwap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSwap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSwap) ProtoMessage() {}

// Deprecated: Use EventSwap.ProtoReflect.Descriptor instead.
func (*EventSwap) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{3}
}

func (x *EventSwap) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventSwap) GetSwapTarget() string {
	if x != nil {
		return x.SwapTarget
	}
	return ""
}

func (x *EventSwap) GetSwapSlip() string {
	if x != nil {
		return x.SwapSlip
	}
	return ""
}

func (x *EventSwap) GetLiquidityFee() string {
	if x != nil {
		return x.LiquidityFee
	}
	return ""
}

func (x *EventSwap) GetLiquidityFeeInRune() string {
	if x != nil {
		return x.LiquidityFeeInRune
	}
	return ""
}

func (x *EventSwap) GetInTx() *common.Tx {
	if x != nil {
		return x.InTx
	}
	return nil
}

func (x *EventSwap) GetOutTxs() *common.Tx {
	if x != nil {
		return x.OutTxs
	}
	return nil
}

func (x *EventSwap) GetEmitAsset() *common.Coin {
	if x != nil {
		return x.EmitAsset
	}
	return nil
}

func (x *EventSwap) GetSynthUnits() string {
	if x != nil {
		return x.SynthUnits
	}
	return ""
}

func (x *EventSwap) GetStreamingSwapQuantity() uint64 {
	if x != nil {
		return x.StreamingSwapQuantity
	}
	return 0
}

func (x *EventSwap) GetStreamingSwapCount() uint64 {
	if x != nil {
		return x.StreamingSwapCount
	}
	return 0
}

func (x *EventSwap) GetPoolSlip() string {
	if x != nil {
		return x.PoolSlip
	}
	return ""
}

type EventAffiliateFee struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxId        string        `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Memo        string        `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	Thorname    string        `protobuf:"bytes,3,opt,name=thorname,proto3" json:"thorname,omitempty"`
	RuneAddress string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	Asset       *common.Asset `protobuf:"bytes,5,opt,name=asset,proto3" json:"asset,omitempty"`
	GrossAmount string        `protobuf:"bytes,6,opt,name=gross_amount,json=grossAmount,proto3" json:"gross_amount,omitempty"`
	FeeBps      uint64        `protobuf:"varint,7,opt,name=fee_bps,json=feeBps,proto3" json:"fee_bps,omitempty"`
	FeeAmount   string        `protobuf:"bytes,8,opt,name=fee_amount,json=feeAmount,proto3" json:"fee_amount,omitempty"`
}

func (x *EventAffiliateFee) Reset() {
	*x = EventAffiliateFee{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventAffiliateFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventAffiliateFee) ProtoMessage() {}

// Deprecated: Use EventAffiliateFee.ProtoReflect.Descriptor instead.
func (*EventAffiliateFee) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{4}
}

func (x *EventAffiliateFee) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventAffiliateFee) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *EventAffiliateFee) GetThorname() string {
	if x != nil {
		return x.Thorname
	}
	return ""
}

func (x *EventAffiliateFee) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventAffiliateFee) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventAffiliateFee) GetGrossAmount() string {
	if x != nil {
		return x.GrossAmount
	}
	return ""
}

func (x *EventAffiliateFee) GetFeeBps() uint64 {
	if x != nil {
		return x.FeeBps
	}
	return 0
}

func (x *EventAffiliateFee) GetFeeAmount() string {
	if x != nil {
		return x.FeeAmount
	}
	return ""
}

type EventAddLiquidity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool          *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	ProviderUnits string        `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3" json:"provider_units,omitempty"`
	RuneAddress   string        `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	RuneAmount    string        `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3" json:"rune_amount,omitempty"`
	AssetAmount   string        `protobuf:"bytes,5,opt,name=asset_amount,json=assetAmount,proto3" json:"asset_amount,omitempty"`
	RuneTxId      string        `protobuf:"bytes,6,opt,name=rune_tx_id,json=runeTxId,proto3" json:"rune_tx_id,omitempty"`
	AssetTxId     string        `protobuf:"bytes,7,opt,name=asset_tx_id,json=assetTxId,proto3" json:"asset_tx_id,omitempty"`
	AssetAddress  string        `protobuf:"bytes,8,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
}

func (x *EventAddLiquidity) Reset() {
	*x = EventAddLiquidity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventAddLiquidity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventAddLiquidity) ProtoMessage() {}

// Deprecated: Use EventAddLiquidity.ProtoReflect.Descriptor instead.
func (*EventAddLiquidity) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{5}
}

func (x *EventAddLiquidity) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventAddLiquidity) GetProviderUnits() string {
	if x != nil {
		return x.ProviderUnits
	}
	return ""
}

func (x *EventAddLiquidity) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventAddLiquidity) GetRuneAmount() string {
	if x != nil {
		return x.RuneAmount
	}
	return ""
}

func (x *EventAddLiquidity) GetAssetAmount() string {
	if x != nil {
		return x.AssetAmount
	}
	return ""
}

func (x *EventAddLiquidity) GetRuneTxId() string {
	if x != nil {
		return x.RuneTxId
	}
	return ""
}

func (x *EventAddLiquidity) GetAssetTxId() string {
	if x != nil {
		return x.AssetTxId
	}
	return ""
}

func (x *EventAddLiquidity) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

type EventWithdraw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool          *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	ProviderUnits string        `protobuf:"bytes,2,opt,name=provider_units,json=providerUnits,proto3" json:"provider_units,omitempty"`
	BasisPoints   int64         `protobuf:"varint,3,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	Asymmetry     []byte        `protobuf:"bytes,4,opt,name=asymmetry,proto3" json:"asymmetry,omitempty"`
	InTx          *common.Tx    `protobuf:"bytes,5,opt,name=in_tx,json=inTx,proto3" json:"in_tx,omitempty"`
	EmitAsset     string        `protobuf:"bytes,6,opt,name=emit_asset,json=emitAsset,proto3" json:"emit_asset,omitempty"`
	EmitRune      string        `protobuf:"bytes,7,opt,name=emit_rune,json=emitRune,proto3" json:"emit_rune,omitempty"`
}

func (x *EventWithdraw) Reset() {
	*x = EventWithdraw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventWithdraw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventWithdraw) ProtoMessage() {}

// Deprecated: Use EventWithdraw.ProtoReflect.Descriptor instead.
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{6}
}

func (x *EventWithdraw) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventWithdraw) GetProviderUnits() string {
	if x != nil {
		return x.ProviderUnits
	}
	return ""
}

func (x *EventWithdraw) GetBasisPoints() int64 {
	if x != nil {
		return x.BasisPoints
	}
	return 0
}

func (x *EventWithdraw) GetAsymmetry() []byte {
	if x != nil {
		return x.Asymmetry
	}
	return nil
}

func (x *EventWithdraw) GetInTx() *common.Tx {
	if x != nil {
		return x.InTx
	}
	return nil
}

func (x *EventWithdraw) GetEmitAsset() string {
	if x != nil {
		return x.EmitAsset
	}
	return ""
}

func (x *EventWithdraw) GetEmitRune() string {
	if x != nil {
		return x.EmitRune
	}
	return ""
}

type EventPendingLiquidity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool         *common.Asset        `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	PendingType  PendingLiquidityType `protobuf:"varint,2,opt,name=pending_type,json=pendingType,proto3,enum=types.PendingLiquidityType" json:"pending_type,omitempty"`
	RuneAddress  string               `protobuf:"bytes,3,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	RuneAmount   string               `protobuf:"bytes,4,opt,name=rune_amount,json=runeAmount,proto3" json:"rune_amount,omitempty"`
	AssetAddress string               `protobuf:"bytes,5,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	AssetAmount  string               `protobuf:"bytes,6,opt,name=asset_amount,json=assetAmount,proto3" json:"asset_amount,omitempty"`
	RuneTxId     string               `protobuf:"bytes,7,opt,name=rune_tx_id,json=runeTxId,proto3" json:"rune_tx_id,omitempty"`
	AssetTxId    string               `protobuf:"bytes,8,opt,name=asset_tx_id,json=assetTxId,proto3" json:"asset_tx_id,omitempty"`
}

func (x *EventPendingLiquidity) Reset() {
	*x = EventPendingLiquidity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPendingLiquidity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPendingLiquidity) ProtoMessage() {}

// Deprecated: Use EventPendingLiquidity.ProtoReflect.Descriptor instead.
func (*EventPendingLiquidity) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{7}
}

func (x *EventPendingLiquidity) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventPendingLiquidity) GetPendingType() PendingLiquidityType {
	if x != nil {
		return x.PendingType
	}
	return PendingLiquidityType_add
}

func (x *EventPendingLiquidity) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventPendingLiquidity) GetRuneAmount() string {
	if x != nil {
		return x.RuneAmount
	}
	return ""
}

func (x *EventPendingLiquidity) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventPendingLiquidity) GetAssetAmount() string {
	if x != nil {
		return x.AssetAmount
	}
	return ""
}

func (x *EventPendingLiquidity) GetRuneTxId() string {
	if x != nil {
		return x.RuneTxId
	}
	return ""
}

func (x *EventPendingLiquidity) GetAssetTxId() string {
	if x != nil {
		return x.AssetTxId
	}
	return ""
}

type EventDonate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	InTx *common.Tx    `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx,omitempty"`
}

func (x *EventDonate) Reset() {
	*x = EventDonate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventDonate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventDonate) ProtoMessage() {}

// Deprecated: Use EventDonate.ProtoReflect.Descriptor instead.
func (*EventDonate) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{8}
}

func (x *EventDonate) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventDonate) GetInTx() *common.Tx {
	if x != nil {
		return x.InTx
	}
	return nil
}

type EventPool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool   *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	Status PoolStatus    `protobuf:"varint,2,opt,name=Status,proto3,enum=types.PoolStatus" json:"Status,omitempty"`
}

func (x *EventPool) Reset() {
	*x = EventPool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPool) ProtoMessage() {}

// Deprecated: Use EventPool.ProtoReflect.Descriptor instead.
func (*EventPool) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{9}
}

func (x *EventPool) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventPool) GetStatus() PoolStatus {
	if x != nil {
		return x.Status
	}
	return PoolStatus_UnknownPoolStatus
}

type PoolAmt struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Asset  *common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	Amount int64         `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *PoolAmt) Reset() {
	*x = PoolAmt{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PoolAmt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PoolAmt) ProtoMessage() {}

// Deprecated: Use PoolAmt.ProtoReflect.Descriptor instead.
func (*PoolAmt) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{10}
}

func (x *PoolAmt) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *PoolAmt) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

type EventRewards struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BondReward     string     `protobuf:"bytes,1,opt,name=bond_reward,json=bondReward,proto3" json:"bond_reward,omitempty"`
	PoolRewards    []*PoolAmt `protobuf:"bytes,2,rep,name=pool_rewards,json=poolRewards,proto3" json:"pool_rewards,omitempty"`
	DevFundReward  string     `protobuf:"bytes,3,opt,name=dev_fund_reward,json=devFundReward,proto3" json:"dev_fund_reward,omitempty"`
	IncomeBurn     string     `protobuf:"bytes,4,opt,name=income_burn,json=incomeBurn,proto3" json:"income_burn,omitempty"`
	TcyStakeReward string     `protobuf:"bytes,5,opt,name=tcy_stake_reward,json=tcyStakeReward,proto3" json:"tcy_stake_reward,omitempty"`
}

func (x *EventRewards) Reset() {
	*x = EventRewards{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRewards) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRewards) ProtoMessage() {}

// Deprecated: Use EventRewards.ProtoReflect.Descriptor instead.
func (*EventRewards) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{11}
}

func (x *EventRewards) GetBondReward() string {
	if x != nil {
		return x.BondReward
	}
	return ""
}

func (x *EventRewards) GetPoolRewards() []*PoolAmt {
	if x != nil {
		return x.PoolRewards
	}
	return nil
}

func (x *EventRewards) GetDevFundReward() string {
	if x != nil {
		return x.DevFundReward
	}
	return ""
}

func (x *EventRewards) GetIncomeBurn() string {
	if x != nil {
		return x.IncomeBurn
	}
	return ""
}

func (x *EventRewards) GetTcyStakeReward() string {
	if x != nil {
		return x.TcyStakeReward
	}
	return ""
}

type EventRefund struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Code   uint32      `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Reason string      `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	InTx   *common.Tx  `protobuf:"bytes,3,opt,name=in_tx,json=inTx,proto3" json:"in_tx,omitempty"`
	Fee    *common.Fee `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (x *EventRefund) Reset() {
	*x = EventRefund{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRefund) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRefund) ProtoMessage() {}

// Deprecated: Use EventRefund.ProtoReflect.Descriptor instead.
func (*EventRefund) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{12}
}

func (x *EventRefund) GetCode() uint32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *EventRefund) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *EventRefund) GetInTx() *common.Tx {
	if x != nil {
		return x.InTx
	}
	return nil
}

func (x *EventRefund) GetFee() *common.Fee {
	if x != nil {
		return x.Fee
	}
	return nil
}

type EventBond struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount      string     `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	BondType    BondType   `protobuf:"varint,2,opt,name=bond_type,json=bondType,proto3,enum=types.BondType" json:"bond_type,omitempty"`
	TxIn        *common.Tx `protobuf:"bytes,3,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	NodeAddress []byte     `protobuf:"bytes,4,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	BondAddress []byte     `protobuf:"bytes,5,opt,name=bond_address,json=bondAddress,proto3" json:"bond_address,omitempty"`
}

func (x *EventBond) Reset() {
	*x = EventBond{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventBond) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventBond) ProtoMessage() {}

// Deprecated: Use EventBond.ProtoReflect.Descriptor instead.
func (*EventBond) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{13}
}

func (x *EventBond) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventBond) GetBondType() BondType {
	if x != nil {
		return x.BondType
	}
	return BondType_bond_paid
}

func (x *EventBond) GetTxIn() *common.Tx {
	if x != nil {
		return x.TxIn
	}
	return nil
}

func (x *EventBond) GetNodeAddress() []byte {
	if x != nil {
		return x.NodeAddress
	}
	return nil
}

func (x *EventBond) GetBondAddress() []byte {
	if x != nil {
		return x.BondAddress
	}
	return nil
}

type GasPool struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Asset    *common.Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	RuneAmt  string        `protobuf:"bytes,2,opt,name=rune_amt,json=runeAmt,proto3" json:"rune_amt,omitempty"`
	AssetAmt string        `protobuf:"bytes,3,opt,name=asset_amt,json=assetAmt,proto3" json:"asset_amt,omitempty"`
	Count    int64         `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (x *GasPool) Reset() {
	*x = GasPool{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GasPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GasPool) ProtoMessage() {}

// Deprecated: Use GasPool.ProtoReflect.Descriptor instead.
func (*GasPool) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{14}
}

func (x *GasPool) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *GasPool) GetRuneAmt() string {
	if x != nil {
		return x.RuneAmt
	}
	return ""
}

func (x *GasPool) GetAssetAmt() string {
	if x != nil {
		return x.AssetAmt
	}
	return ""
}

func (x *GasPool) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

type EventGas struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pools []*GasPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools,omitempty"`
}

func (x *EventGas) Reset() {
	*x = EventGas{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventGas) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventGas) ProtoMessage() {}

// Deprecated: Use EventGas.ProtoReflect.Descriptor instead.
func (*EventGas) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{15}
}

func (x *EventGas) GetPools() []*GasPool {
	if x != nil {
		return x.Pools
	}
	return nil
}

type EventReserve struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ReserveContributor *ReserveContributor `protobuf:"bytes,1,opt,name=reserve_contributor,json=reserveContributor,proto3" json:"reserve_contributor,omitempty"`
	InTx               *common.Tx          `protobuf:"bytes,2,opt,name=in_tx,json=inTx,proto3" json:"in_tx,omitempty"`
}

func (x *EventReserve) Reset() {
	*x = EventReserve{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventReserve) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventReserve) ProtoMessage() {}

// Deprecated: Use EventReserve.ProtoReflect.Descriptor instead.
func (*EventReserve) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{16}
}

func (x *EventReserve) GetReserveContributor() *ReserveContributor {
	if x != nil {
		return x.ReserveContributor
	}
	return nil
}

func (x *EventReserve) GetInTx() *common.Tx {
	if x != nil {
		return x.InTx
	}
	return nil
}

type EventScheduledOutbound struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OutTx *TxOutItem `protobuf:"bytes,1,opt,name=out_tx,json=outTx,proto3" json:"out_tx,omitempty"`
}

func (x *EventScheduledOutbound) Reset() {
	*x = EventScheduledOutbound{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventScheduledOutbound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventScheduledOutbound) ProtoMessage() {}

// Deprecated: Use EventScheduledOutbound.ProtoReflect.Descriptor instead.
func (*EventScheduledOutbound) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{17}
}

func (x *EventScheduledOutbound) GetOutTx() *TxOutItem {
	if x != nil {
		return x.OutTx
	}
	return nil
}

type EventSecurity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Msg string     `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Tx  *common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (x *EventSecurity) Reset() {
	*x = EventSecurity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSecurity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSecurity) ProtoMessage() {}

// Deprecated: Use EventSecurity.ProtoReflect.Descriptor instead.
func (*EventSecurity) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{18}
}

func (x *EventSecurity) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

func (x *EventSecurity) GetTx() *common.Tx {
	if x != nil {
		return x.Tx
	}
	return nil
}

type EventSlash struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pool        *common.Asset `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	SlashAmount []*PoolAmt    `protobuf:"bytes,2,rep,name=slash_amount,json=slashAmount,proto3" json:"slash_amount,omitempty"`
}

func (x *EventSlash) Reset() {
	*x = EventSlash{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSlash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSlash) ProtoMessage() {}

// Deprecated: Use EventSlash.ProtoReflect.Descriptor instead.
func (*EventSlash) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{19}
}

func (x *EventSlash) GetPool() *common.Asset {
	if x != nil {
		return x.Pool
	}
	return nil
}

func (x *EventSlash) GetSlashAmount() []*PoolAmt {
	if x != nil {
		return x.SlashAmount
	}
	return nil
}

type EventErrata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxId  string     `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Pools []*PoolMod `protobuf:"bytes,2,rep,name=pools,proto3" json:"pools,omitempty"`
}

func (x *EventErrata) Reset() {
	*x = EventErrata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventErrata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventErrata) ProtoMessage() {}

// Deprecated: Use EventErrata.ProtoReflect.Descriptor instead.
func (*EventErrata) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{20}
}

func (x *EventErrata) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventErrata) GetPools() []*PoolMod {
	if x != nil {
		return x.Pools
	}
	return nil
}

type EventFee struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxId       string      `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Fee        *common.Fee `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	SynthUnits string      `protobuf:"bytes,3,opt,name=synth_units,json=synthUnits,proto3" json:"synth_units,omitempty"`
}

func (x *EventFee) Reset() {
	*x = EventFee{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventFee) ProtoMessage() {}

// Deprecated: Use EventFee.ProtoReflect.Descriptor instead.
func (*EventFee) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{21}
}

func (x *EventFee) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventFee) GetFee() *common.Fee {
	if x != nil {
		return x.Fee
	}
	return nil
}

func (x *EventFee) GetSynthUnits() string {
	if x != nil {
		return x.SynthUnits
	}
	return ""
}

type EventOutbound struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	InTxId string     `protobuf:"bytes,1,opt,name=in_tx_id,json=inTxId,proto3" json:"in_tx_id,omitempty"`
	Tx     *common.Tx `protobuf:"bytes,2,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (x *EventOutbound) Reset() {
	*x = EventOutbound{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventOutbound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventOutbound) ProtoMessage() {}

// Deprecated: Use EventOutbound.ProtoReflect.Descriptor instead.
func (*EventOutbound) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{22}
}

func (x *EventOutbound) GetInTxId() string {
	if x != nil {
		return x.InTxId
	}
	return ""
}

func (x *EventOutbound) GetTx() *common.Tx {
	if x != nil {
		return x.Tx
	}
	return nil
}

type EventTssKeygenSuccess struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PubKey  string   `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Members []string `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Height  int64    `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (x *EventTssKeygenSuccess) Reset() {
	*x = EventTssKeygenSuccess{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTssKeygenSuccess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTssKeygenSuccess) ProtoMessage() {}

// Deprecated: Use EventTssKeygenSuccess.ProtoReflect.Descriptor instead.
func (*EventTssKeygenSuccess) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{23}
}

func (x *EventTssKeygenSuccess) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *EventTssKeygenSuccess) GetMembers() []string {
	if x != nil {
		return x.Members
	}
	return nil
}

func (x *EventTssKeygenSuccess) GetHeight() int64 {
	if x != nil {
		return x.Height
	}
	return 0
}

type EventTssKeygenFailure struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FailReason string   `protobuf:"bytes,1,opt,name=fail_reason,json=failReason,proto3" json:"fail_reason,omitempty"`
	IsUnicast  bool     `protobuf:"varint,2,opt,name=is_unicast,json=isUnicast,proto3" json:"is_unicast,omitempty"`
	BlameNodes []string `protobuf:"bytes,3,rep,name=blame_nodes,json=blameNodes,proto3" json:"blame_nodes,omitempty"`
	Round      string   `protobuf:"bytes,4,opt,name=round,proto3" json:"round,omitempty"`
	Height     int64    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (x *EventTssKeygenFailure) Reset() {
	*x = EventTssKeygenFailure{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTssKeygenFailure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTssKeygenFailure) ProtoMessage() {}

// Deprecated: Use EventTssKeygenFailure.ProtoReflect.Descriptor instead.
func (*EventTssKeygenFailure) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{24}
}

func (x *EventTssKeygenFailure) GetFailReason() string {
	if x != nil {
		return x.FailReason
	}
	return ""
}

func (x *EventTssKeygenFailure) GetIsUnicast() bool {
	if x != nil {
		return x.IsUnicast
	}
	return false
}

func (x *EventTssKeygenFailure) GetBlameNodes() []string {
	if x != nil {
		return x.BlameNodes
	}
	return nil
}

func (x *EventTssKeygenFailure) GetRound() string {
	if x != nil {
		return x.Round
	}
	return ""
}

func (x *EventTssKeygenFailure) GetHeight() int64 {
	if x != nil {
		return x.Height
	}
	return 0
}

type EventTssKeygenMetric struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PubKey           string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	MedianDurationMs int64  `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (x *EventTssKeygenMetric) Reset() {
	*x = EventTssKeygenMetric{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTssKeygenMetric) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTssKeygenMetric) ProtoMessage() {}

// Deprecated: Use EventTssKeygenMetric.ProtoReflect.Descriptor instead.
func (*EventTssKeygenMetric) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{25}
}

func (x *EventTssKeygenMetric) GetPubKey() string {
	if x != nil {
		return x.PubKey
	}
	return ""
}

func (x *EventTssKeygenMetric) GetMedianDurationMs() int64 {
	if x != nil {
		return x.MedianDurationMs
	}
	return 0
}

type EventTssKeysignMetric struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxId             string `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	MedianDurationMs int64  `protobuf:"varint,2,opt,name=median_duration_ms,json=medianDurationMs,proto3" json:"median_duration_ms,omitempty"`
}

func (x *EventTssKeysignMetric) Reset() {
	*x = EventTssKeysignMetric{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTssKeysignMetric) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTssKeysignMetric) ProtoMessage() {}

// Deprecated: Use EventTssKeysignMetric.ProtoReflect.Descriptor instead.
func (*EventTssKeysignMetric) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{26}
}

func (x *EventTssKeysignMetric) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventTssKeysignMetric) GetMedianDurationMs() int64 {
	if x != nil {
		return x.MedianDurationMs
	}
	return 0
}

type EventSlashPoint struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NodeAddress []byte `protobuf:"bytes,1,opt,name=node_address,json=nodeAddress,proto3" json:"node_address,omitempty"`
	SlashPoints int64  `protobuf:"varint,2,opt,name=slash_points,json=slashPoints,proto3" json:"slash_points,omitempty"`
	Reason      string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (x *EventSlashPoint) Reset() {
	*x = EventSlashPoint{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSlashPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSlashPoint) ProtoMessage() {}

// Deprecated: Use EventSlashPoint.ProtoReflect.Descriptor instead.
func (*EventSlashPoint) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{27}
}

func (x *EventSlashPoint) GetNodeAddress() []byte {
	if x != nil {
		return x.NodeAddress
	}
	return nil
}

func (x *EventSlashPoint) GetSlashPoints() int64 {
	if x != nil {
		return x.SlashPoints
	}
	return 0
}

func (x *EventSlashPoint) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type EventPoolBalanceChanged struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PoolChange *PoolMod `protobuf:"bytes,1,opt,name=pool_change,json=poolChange,proto3" json:"pool_change,omitempty"`
	Reason     string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (x *EventPoolBalanceChanged) Reset() {
	*x = EventPoolBalanceChanged{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventPoolBalanceChanged) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventPoolBalanceChanged) ProtoMessage() {}

// Deprecated: Use EventPoolBalanceChanged.ProtoReflect.Descriptor instead.
func (*EventPoolBalanceChanged) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{28}
}

func (x *EventPoolBalanceChanged) GetPoolChange() *PoolMod {
	if x != nil {
		return x.PoolChange
	}
	return nil
}

func (x *EventPoolBalanceChanged) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type EventMintBurn struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Supply MintBurnSupplyType `protobuf:"varint,1,opt,name=supply,proto3,enum=types.MintBurnSupplyType" json:"supply,omitempty"`
	Denom  string             `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Amount string             `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Reason string             `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (x *EventMintBurn) Reset() {
	*x = EventMintBurn{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventMintBurn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventMintBurn) ProtoMessage() {}

// Deprecated: Use EventMintBurn.ProtoReflect.Descriptor instead.
func (*EventMintBurn) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{29}
}

func (x *EventMintBurn) GetSupply() MintBurnSupplyType {
	if x != nil {
		return x.Supply
	}
	return MintBurnSupplyType_mint
}

func (x *EventMintBurn) GetDenom() string {
	if x != nil {
		return x.Denom
	}
	return ""
}

func (x *EventMintBurn) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventMintBurn) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type EventTradeAccountDeposit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount       string        `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Asset        *common.Asset `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	AssetAddress string        `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	RuneAddress  string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TxId         string        `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventTradeAccountDeposit) Reset() {
	*x = EventTradeAccountDeposit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTradeAccountDeposit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTradeAccountDeposit) ProtoMessage() {}

// Deprecated: Use EventTradeAccountDeposit.ProtoReflect.Descriptor instead.
func (*EventTradeAccountDeposit) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{30}
}

func (x *EventTradeAccountDeposit) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventTradeAccountDeposit) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventTradeAccountDeposit) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventTradeAccountDeposit) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventTradeAccountDeposit) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventTradeAccountWithdraw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount       string        `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Asset        *common.Asset `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	AssetAddress string        `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	RuneAddress  string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TxId         string        `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventTradeAccountWithdraw) Reset() {
	*x = EventTradeAccountWithdraw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTradeAccountWithdraw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTradeAccountWithdraw) ProtoMessage() {}

// Deprecated: Use EventTradeAccountWithdraw.ProtoReflect.Descriptor instead.
func (*EventTradeAccountWithdraw) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{31}
}

func (x *EventTradeAccountWithdraw) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventTradeAccountWithdraw) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventTradeAccountWithdraw) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventTradeAccountWithdraw) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventTradeAccountWithdraw) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventSecuredAssetDeposit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount       string        `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Asset        *common.Asset `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	AssetAddress string        `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	RuneAddress  string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TxId         string        `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventSecuredAssetDeposit) Reset() {
	*x = EventSecuredAssetDeposit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSecuredAssetDeposit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSecuredAssetDeposit) ProtoMessage() {}

// Deprecated: Use EventSecuredAssetDeposit.ProtoReflect.Descriptor instead.
func (*EventSecuredAssetDeposit) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{32}
}

func (x *EventSecuredAssetDeposit) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventSecuredAssetDeposit) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventSecuredAssetDeposit) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventSecuredAssetDeposit) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventSecuredAssetDeposit) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventSecuredAssetWithdraw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount       string        `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Asset        *common.Asset `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	AssetAddress string        `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	RuneAddress  string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TxId         string        `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventSecuredAssetWithdraw) Reset() {
	*x = EventSecuredAssetWithdraw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSecuredAssetWithdraw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSecuredAssetWithdraw) ProtoMessage() {}

// Deprecated: Use EventSecuredAssetWithdraw.ProtoReflect.Descriptor instead.
func (*EventSecuredAssetWithdraw) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{33}
}

func (x *EventSecuredAssetWithdraw) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventSecuredAssetWithdraw) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventSecuredAssetWithdraw) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventSecuredAssetWithdraw) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventSecuredAssetWithdraw) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventRUNEPoolDeposit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RuneAddress []byte `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	RuneAmount  string `protobuf:"bytes,2,opt,name=rune_amount,json=runeAmount,proto3" json:"rune_amount,omitempty"`
	Units       string `protobuf:"bytes,3,opt,name=units,proto3" json:"units,omitempty"`
	TxId        string `protobuf:"bytes,4,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventRUNEPoolDeposit) Reset() {
	*x = EventRUNEPoolDeposit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRUNEPoolDeposit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRUNEPoolDeposit) ProtoMessage() {}

// Deprecated: Use EventRUNEPoolDeposit.ProtoReflect.Descriptor instead.
func (*EventRUNEPoolDeposit) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{34}
}

func (x *EventRUNEPoolDeposit) GetRuneAddress() []byte {
	if x != nil {
		return x.RuneAddress
	}
	return nil
}

func (x *EventRUNEPoolDeposit) GetRuneAmount() string {
	if x != nil {
		return x.RuneAmount
	}
	return ""
}

func (x *EventRUNEPoolDeposit) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *EventRUNEPoolDeposit) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventRUNEPoolWithdraw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RuneAddress       []byte `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	BasisPoints       int64  `protobuf:"varint,2,opt,name=basis_points,json=basisPoints,proto3" json:"basis_points,omitempty"`
	RuneAmount        string `protobuf:"bytes,3,opt,name=rune_amount,json=runeAmount,proto3" json:"rune_amount,omitempty"`
	Units             string `protobuf:"bytes,4,opt,name=units,proto3" json:"units,omitempty"`
	TxId              string `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	AffiliateBasisPts int64  `protobuf:"varint,6,opt,name=affiliate_basis_pts,json=affiliateBasisPts,proto3" json:"affiliate_basis_pts,omitempty"`
	AffiliateAmount   string `protobuf:"bytes,7,opt,name=affiliate_amount,json=affiliateAmount,proto3" json:"affiliate_amount,omitempty"`
	AffiliateAddress  string `protobuf:"bytes,8,opt,name=affiliate_address,json=affiliateAddress,proto3" json:"affiliate_address,omitempty"`
}

func (x *EventRUNEPoolWithdraw) Reset() {
	*x = EventRUNEPoolWithdraw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventRUNEPoolWithdraw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventRUNEPoolWithdraw) ProtoMessage() {}

// Deprecated: Use EventRUNEPoolWithdraw.ProtoReflect.Descriptor instead.
func (*EventRUNEPoolWithdraw) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{35}
}

func (x *EventRUNEPoolWithdraw) GetRuneAddress() []byte {
	if x != nil {
		return x.RuneAddress
	}
	return nil
}

func (x *EventRUNEPoolWithdraw) GetBasisPoints() int64 {
	if x != nil {
		return x.BasisPoints
	}
	return 0
}

func (x *EventRUNEPoolWithdraw) GetRuneAmount() string {
	if x != nil {
		return x.RuneAmount
	}
	return ""
}

func (x *EventRUNEPoolWithdraw) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *EventRUNEPoolWithdraw) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

func (x *EventRUNEPoolWithdraw) GetAffiliateBasisPts() int64 {
	if x != nil {
		return x.AffiliateBasisPts
	}
	return 0
}

func (x *EventRUNEPoolWithdraw) GetAffiliateAmount() string {
	if x != nil {
		return x.AffiliateAmount
	}
	return ""
}

func (x *EventRUNEPoolWithdraw) GetAffiliateAddress() string {
	if x != nil {
		return x.AffiliateAddress
	}
	return ""
}

type EventLoanOpen struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CollateralDeposited    string        `protobuf:"bytes,1,opt,name=collateral_deposited,json=collateralDeposited,proto3" json:"collateral_deposited,omitempty"`
	CollateralAsset        *common.Asset `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset,omitempty"`
	CollateralizationRatio string        `protobuf:"bytes,3,opt,name=collateralization_ratio,json=collateralizationRatio,proto3" json:"collateralization_ratio,omitempty"`
	DebtIssued             string        `protobuf:"bytes,4,opt,name=debt_issued,json=debtIssued,proto3" json:"debt_issued,omitempty"`
	Owner                  string        `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	TargetAsset            *common.Asset `protobuf:"bytes,6,opt,name=target_asset,json=targetAsset,proto3" json:"target_asset,omitempty"`
	TxId                   string        `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventLoanOpen) Reset() {
	*x = EventLoanOpen{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventLoanOpen) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventLoanOpen) ProtoMessage() {}

// Deprecated: Use EventLoanOpen.ProtoReflect.Descriptor instead.
func (*EventLoanOpen) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{36}
}

func (x *EventLoanOpen) GetCollateralDeposited() string {
	if x != nil {
		return x.CollateralDeposited
	}
	return ""
}

func (x *EventLoanOpen) GetCollateralAsset() *common.Asset {
	if x != nil {
		return x.CollateralAsset
	}
	return nil
}

func (x *EventLoanOpen) GetCollateralizationRatio() string {
	if x != nil {
		return x.CollateralizationRatio
	}
	return ""
}

func (x *EventLoanOpen) GetDebtIssued() string {
	if x != nil {
		return x.DebtIssued
	}
	return ""
}

func (x *EventLoanOpen) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *EventLoanOpen) GetTargetAsset() *common.Asset {
	if x != nil {
		return x.TargetAsset
	}
	return nil
}

func (x *EventLoanOpen) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventLoanRepayment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CollateralWithdrawn string        `protobuf:"bytes,1,opt,name=collateral_withdrawn,json=collateralWithdrawn,proto3" json:"collateral_withdrawn,omitempty"`
	CollateralAsset     *common.Asset `protobuf:"bytes,2,opt,name=collateral_asset,json=collateralAsset,proto3" json:"collateral_asset,omitempty"`
	DebtRepaid          string        `protobuf:"bytes,3,opt,name=debt_repaid,json=debtRepaid,proto3" json:"debt_repaid,omitempty"`
	Owner               string        `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	TxId                string        `protobuf:"bytes,7,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventLoanRepayment) Reset() {
	*x = EventLoanRepayment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventLoanRepayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventLoanRepayment) ProtoMessage() {}

// Deprecated: Use EventLoanRepayment.ProtoReflect.Descriptor instead.
func (*EventLoanRepayment) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{37}
}

func (x *EventLoanRepayment) GetCollateralWithdrawn() string {
	if x != nil {
		return x.CollateralWithdrawn
	}
	return ""
}

func (x *EventLoanRepayment) GetCollateralAsset() *common.Asset {
	if x != nil {
		return x.CollateralAsset
	}
	return nil
}

func (x *EventLoanRepayment) GetDebtRepaid() string {
	if x != nil {
		return x.DebtRepaid
	}
	return ""
}

func (x *EventLoanRepayment) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *EventLoanRepayment) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventTHORName struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name            string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain           string `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Address         string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	RegistrationFee string `protobuf:"bytes,4,opt,name=registration_fee,json=registrationFee,proto3" json:"registration_fee,omitempty"`
	FundAmt         string `protobuf:"bytes,5,opt,name=fund_amt,json=fundAmt,proto3" json:"fund_amt,omitempty"`
	Expire          int64  `protobuf:"varint,6,opt,name=expire,proto3" json:"expire,omitempty"`
	Owner           []byte `protobuf:"bytes,7,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (x *EventTHORName) Reset() {
	*x = EventTHORName{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTHORName) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTHORName) ProtoMessage() {}

// Deprecated: Use EventTHORName.ProtoReflect.Descriptor instead.
func (*EventTHORName) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{38}
}

func (x *EventTHORName) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EventTHORName) GetChain() string {
	if x != nil {
		return x.Chain
	}
	return ""
}

func (x *EventTHORName) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventTHORName) GetRegistrationFee() string {
	if x != nil {
		return x.RegistrationFee
	}
	return ""
}

func (x *EventTHORName) GetFundAmt() string {
	if x != nil {
		return x.FundAmt
	}
	return ""
}

func (x *EventTHORName) GetExpire() int64 {
	if x != nil {
		return x.Expire
	}
	return 0
}

func (x *EventTHORName) GetOwner() []byte {
	if x != nil {
		return x.Owner
	}
	return nil
}

type EventSetMimir struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *EventSetMimir) Reset() {
	*x = EventSetMimir{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSetMimir) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSetMimir) ProtoMessage() {}

// Deprecated: Use EventSetMimir.ProtoReflect.Descriptor instead.
func (*EventSetMimir) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{39}
}

func (x *EventSetMimir) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *EventSetMimir) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type EventSetNodeMimir struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key     string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value   string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (x *EventSetNodeMimir) Reset() {
	*x = EventSetNodeMimir{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSetNodeMimir) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSetNodeMimir) ProtoMessage() {}

// Deprecated: Use EventSetNodeMimir.ProtoReflect.Descriptor instead.
func (*EventSetNodeMimir) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{40}
}

func (x *EventSetNodeMimir) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *EventSetNodeMimir) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *EventSetNodeMimir) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type EventVersion struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *EventVersion) Reset() {
	*x = EventVersion{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventVersion) ProtoMessage() {}

// Deprecated: Use EventVersion.ProtoReflect.Descriptor instead.
func (*EventVersion) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{41}
}

func (x *EventVersion) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

type EventSwitch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Amount       string        `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Asset        *common.Asset `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	AssetAddress string        `protobuf:"bytes,3,opt,name=asset_address,json=assetAddress,proto3" json:"asset_address,omitempty"`
	RuneAddress  string        `protobuf:"bytes,4,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TxId         string        `protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (x *EventSwitch) Reset() {
	*x = EventSwitch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventSwitch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventSwitch) ProtoMessage() {}

// Deprecated: Use EventSwitch.ProtoReflect.Descriptor instead.
func (*EventSwitch) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{42}
}

func (x *EventSwitch) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *EventSwitch) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *EventSwitch) GetAssetAddress() string {
	if x != nil {
		return x.AssetAddress
	}
	return ""
}

func (x *EventSwitch) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventSwitch) GetTxId() string {
	if x != nil {
		return x.TxId
	}
	return ""
}

type EventTCYDistribution struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RuneAddress []byte `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	RuneAmount  string `protobuf:"bytes,2,opt,name=rune_amount,json=runeAmount,proto3" json:"rune_amount,omitempty"`
}

func (x *EventTCYDistribution) Reset() {
	*x = EventTCYDistribution{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTCYDistribution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTCYDistribution) ProtoMessage() {}

// Deprecated: Use EventTCYDistribution.ProtoReflect.Descriptor instead.
func (*EventTCYDistribution) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{43}
}

func (x *EventTCYDistribution) GetRuneAddress() []byte {
	if x != nil {
		return x.RuneAddress
	}
	return nil
}

func (x *EventTCYDistribution) GetRuneAmount() string {
	if x != nil {
		return x.RuneAmount
	}
	return ""
}

type EventTCYClaim struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	RuneAddress string        `protobuf:"bytes,1,opt,name=rune_address,json=runeAddress,proto3" json:"rune_address,omitempty"`
	TcyAmount   string        `protobuf:"bytes,2,opt,name=tcy_amount,json=tcyAmount,proto3" json:"tcy_amount,omitempty"`
	L1Address   string        `protobuf:"bytes,3,opt,name=l1_address,json=l1Address,proto3" json:"l1_address,omitempty"`
	Asset       *common.Asset `protobuf:"bytes,4,opt,name=asset,proto3" json:"asset,omitempty"`
}

func (x *EventTCYClaim) Reset() {
	*x = EventTCYClaim{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTCYClaim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTCYClaim) ProtoMessage() {}

// Deprecated: Use EventTCYClaim.ProtoReflect.Descriptor instead.
func (*EventTCYClaim) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{44}
}

func (x *EventTCYClaim) GetRuneAddress() string {
	if x != nil {
		return x.RuneAddress
	}
	return ""
}

func (x *EventTCYClaim) GetTcyAmount() string {
	if x != nil {
		return x.TcyAmount
	}
	return ""
}

func (x *EventTCYClaim) GetL1Address() string {
	if x != nil {
		return x.L1Address
	}
	return ""
}

func (x *EventTCYClaim) GetAsset() *common.Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

type EventTCYStake struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Amount  string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *EventTCYStake) Reset() {
	*x = EventTCYStake{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[45]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTCYStake) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTCYStake) ProtoMessage() {}

// Deprecated: Use EventTCYStake.ProtoReflect.Descriptor instead.
func (*EventTCYStake) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{45}
}

func (x *EventTCYStake) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventTCYStake) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type EventTCYUnstake struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Amount  string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (x *EventTCYUnstake) Reset() {
	*x = EventTCYUnstake{}
	if protoimpl.UnsafeEnabled {
		mi := &file_types_type_events_proto_msgTypes[46]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EventTCYUnstake) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventTCYUnstake) ProtoMessage() {}

// Deprecated: Use EventTCYUnstake.ProtoReflect.Descriptor instead.
func (*EventTCYUnstake) Descriptor() ([]byte, []int) {
	return file_types_type_events_proto_rawDescGZIP(), []int{46}
}

func (x *EventTCYUnstake) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *EventTCYUnstake) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

var File_types_type_events_proto protoreflect.FileDescriptor

var file_types_type_events_proto_rawDesc = []byte{
	0x0a, 0x17, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x65, 0x76, 0x65,
	0x6e, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x1a, 0x13, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x15, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x74, 0x79, 0x70,
	0x65, 0x5f, 0x70, 0x6f, 0x6f, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x74, 0x79,
	0x70, 0x65, 0x73, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x17, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x74,
	0x78, 0x5f, 0x6f, 0x75, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f, 0x67,
	0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x22, 0x95, 0x02, 0x0a, 0x07, 0x50, 0x6f, 0x6f, 0x6c, 0x4d, 0x6f, 0x64, 0x12, 0x5a, 0x0a,
	0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x39, 0x0a, 0x08, 0x72, 0x75, 0x6e,
	0x65, 0x5f, 0x61, 0x6d, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x07, 0x72, 0x75, 0x6e,
	0x65, 0x41, 0x6d, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x12,
	0x3b, 0x0a, 0x09, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x6d, 0x74, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69,
	0x6e, 0x74, 0x52, 0x08, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x6d, 0x74, 0x12, 0x1b, 0x0a, 0x09,
	0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x64, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x08, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x22, 0xb8, 0x01, 0x0a, 0x0f, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x2a, 0x0a,
	0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x06, 0x74,
	0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde,
	0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f,
	0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x04,
	0x74, 0x78, 0x49, 0x64, 0x22, 0xe0, 0x03, 0x0a, 0x12, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x77, 0x61, 0x70, 0x12, 0x4d, 0x0a, 0x05, 0x74,
	0x78, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04,
	0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x54, 0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69,
	0x74, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x61, 0x73, 0x74,
	0x5f, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x6c,
	0x61, 0x73, 0x74, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x12, 0x41, 0x0a, 0x0c, 0x74, 0x72, 0x61,
	0x64, 0x65, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x0b, 0x74, 0x72, 0x61, 0x64, 0x65, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x2c, 0x0a, 0x07,
	0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x07, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x12, 0x22, 0x0a, 0x02, 0x69, 0x6e,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x24,
	0x0a, 0x03, 0x6f, 0x75, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x03, 0x6f, 0x75, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x5f, 0x73,
	0x77, 0x61, 0x70, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x04, 0x52, 0x0b, 0x66, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x53, 0x77, 0x61, 0x70, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x66, 0x61, 0x69, 0x6c, 0x65,
	0x64, 0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73, 0x18, 0x0b,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x53, 0x77, 0x61, 0x70,
	0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73, 0x22, 0xe8, 0x05, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x53, 0x77, 0x61, 0x70, 0x12, 0x58, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c,
	0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12,
	0x3f, 0x0a, 0x0b, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x73, 0x77, 0x61, 0x70, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74,
	0x12, 0x3b, 0x0a, 0x09, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x6c, 0x69, 0x70, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55,
	0x69, 0x6e, 0x74, 0x52, 0x08, 0x73, 0x77, 0x61, 0x70, 0x53, 0x6c, 0x69, 0x70, 0x12, 0x43, 0x0a,
	0x0d, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x5f, 0x66, 0x65, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x0c, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x46,
	0x65, 0x65, 0x12, 0x51, 0x0a, 0x15, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x5f,
	0x66, 0x65, 0x65, 0x5f, 0x69, 0x6e, 0x5f, 0x72, 0x75, 0x6e, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x12, 0x6c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x46, 0x65, 0x65, 0x49,
	0x6e, 0x52, 0x75, 0x6e, 0x65, 0x12, 0x25, 0x0a, 0x05, 0x69, 0x6e, 0x5f, 0x74, 0x78, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x04, 0x69, 0x6e, 0x54, 0x78, 0x12, 0x29, 0x0a, 0x07,
	0x6f, 0x75, 0x74, 0x5f, 0x74, 0x78, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x06, 0x6f, 0x75, 0x74, 0x54, 0x78, 0x73, 0x12, 0x31, 0x0a, 0x0a, 0x65, 0x6d, 0x69, 0x74, 0x5f,
	0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x69, 0x6e, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x09, 0x65, 0x6d, 0x69, 0x74, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x3f, 0x0a, 0x0b, 0x73, 0x79,
	0x6e, 0x74, 0x68, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52,
	0x0a, 0x73, 0x79, 0x6e, 0x74, 0x68, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12, 0x36, 0x0a, 0x17, 0x73,
	0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x71, 0x75,
	0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x52, 0x15, 0x73, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x77, 0x61, 0x70, 0x51, 0x75, 0x61, 0x6e, 0x74,
	0x69, 0x74, 0x79, 0x12, 0x30, 0x0a, 0x14, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67,
	0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x12, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x77, 0x61, 0x70,
	0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x3b, 0x0a, 0x09, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x73, 0x6c,
	0x69, 0x70, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x08, 0x70, 0x6f, 0x6f, 0x6c, 0x53, 0x6c,
	0x69, 0x70, 0x22, 0xe1, 0x03, 0x0a, 0x11, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x41, 0x66, 0x66, 0x69,
	0x6c, 0x69, 0x61, 0x74, 0x65, 0x46, 0x65, 0x65, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49,
	0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49,
	0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6d, 0x65, 0x6d, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x74,
	0x68, 0x6f, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74,
	0x68, 0x6f, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa,
	0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x5a, 0x0a, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x73, 0x73, 0x65, 0x74, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x41, 0x0a, 0x0c, 0x67,
	0x72, 0x6f, 0x73, 0x73, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x0b, 0x67, 0x72, 0x6f, 0x73, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x17,
	0x0a, 0x07, 0x66, 0x65, 0x65, 0x5f, 0x62, 0x70, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x06, 0x66, 0x65, 0x65, 0x42, 0x70, 0x73, 0x12, 0x3d, 0x0a, 0x0a, 0x66, 0x65, 0x65, 0x5f, 0x61,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x09, 0x66, 0x65, 0x65,
	0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0xa5, 0x05, 0x0a, 0x11, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x41, 0x64, 0x64, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x12, 0x58, 0x0a, 0x04,
	0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74,
	0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x45, 0x0a, 0x0e, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64,
	0x65, 0x72, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0d,
	0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12, 0x56, 0x0a,
	0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x72, 0x75, 0x6e, 0x65,
	0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x41, 0x0a, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0b, 0x61, 0x73,
	0x73, 0x65, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5a, 0x0a, 0x0a, 0x72, 0x75, 0x6e,
	0x65, 0x5f, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x3c, 0xe2,
	0xde, 0x1f, 0x08, 0x52, 0x75, 0x6e, 0x65, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67,
	0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x08, 0x72, 0x75, 0x6e,
	0x65, 0x54, 0x78, 0x49, 0x64, 0x12, 0x5d, 0x0a, 0x0b, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x74,
	0x78, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x3d, 0xe2, 0xde, 0x1f, 0x09,
	0x41, 0x73, 0x73, 0x65, 0x74, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74,
	0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x09, 0x61, 0x73, 0x73, 0x65, 0x74,
	0x54, 0x78, 0x49, 0x64, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f,
	0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76,
	0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x52, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0xb9,
	0x03, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x12, 0x58, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x73, 0x73, 0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x45, 0x0a, 0x0e, 0x70, 0x72,
	0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69,
	0x6e, 0x74, 0x52, 0x0d, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x55, 0x6e, 0x69, 0x74,
	0x73, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x61, 0x73, 0x69, 0x73, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74,
	0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x62, 0x61, 0x73, 0x69, 0x73, 0x50, 0x6f,
	0x69, 0x6e, 0x74, 0x73, 0x12, 0x41, 0x0a, 0x09, 0x61, 0x73, 0x79, 0x6d, 0x6d, 0x65, 0x74, 0x72,
	0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x23, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x1b, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79, 0x44, 0x65, 0x63, 0x52, 0x09, 0x61, 0x73,
	0x79, 0x6d, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x12, 0x25, 0x0a, 0x05, 0x69, 0x6e, 0x5f, 0x74, 0x78,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x04, 0x69, 0x6e, 0x54, 0x78, 0x12, 0x3d,
	0x0a, 0x0a, 0x65, 0x6d, 0x69, 0x74, 0x5f, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69,
	0x6e, 0x74, 0x52, 0x09, 0x65, 0x6d, 0x69, 0x74, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x3b, 0x0a,
	0x09, 0x65, 0x6d, 0x69, 0x74, 0x5f, 0x72, 0x75, 0x6e, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74,
	0x52, 0x08, 0x65, 0x6d, 0x69, 0x74, 0x52, 0x75, 0x6e, 0x65, 0x22, 0xa2, 0x05, 0x0a, 0x15, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x71, 0x75, 0x69,
	0x64, 0x69, 0x74, 0x79, 0x12, 0x58, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65,
	0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x3e,
	0x0a, 0x0c, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x50, 0x65, 0x6e,
	0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74, 0x79, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x0b, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x54, 0x79, 0x70, 0x65, 0x12, 0x56,
	0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61,
	0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x72, 0x75, 0x6e,
	0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74,
	0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33,
	0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x52, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x41, 0x0a, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e,
	0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0b, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5a, 0x0a, 0x0a, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x74, 0x78, 0x5f,
	0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x3c, 0xe2, 0xde, 0x1f, 0x08, 0x52, 0x75,
	0x6e, 0x65, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x08, 0x72, 0x75, 0x6e, 0x65, 0x54, 0x78, 0x49, 0x64,
	0x12, 0x5d, 0x0a, 0x0b, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x3d, 0xe2, 0xde, 0x1f, 0x09, 0x41, 0x73, 0x73, 0x65, 0x74,
	0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x54, 0x78, 0x49, 0x44, 0x52, 0x09, 0x61, 0x73, 0x73, 0x65, 0x74, 0x54, 0x78, 0x49, 0x64, 0x22,
	0x8e, 0x01, 0x0a, 0x0b, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x44, 0x6f, 0x6e, 0x61, 0x74, 0x65, 0x12,
	0x58, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e,
	0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73,
	0x73, 0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x25, 0x0a, 0x05, 0x69, 0x6e, 0x5f,
	0x74, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x04, 0x69, 0x6e, 0x54, 0x78,
	0x22, 0x90, 0x01, 0x0a, 0x09, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x58,
	0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x29, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x22, 0x7d, 0x0a, 0x07, 0x50, 0x6f, 0x6f, 0x6c, 0x41, 0x6d, 0x74, 0x12, 0x5a,
	0x0a, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e,
	0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73,
	0x73, 0x65, 0x74, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x22, 0xdb, 0x02, 0x0a, 0x0c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x77, 0x61,
	0x72, 0x64, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x62, 0x6f, 0x6e, 0x64, 0x5f, 0x72, 0x65, 0x77, 0x61,
	0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x62, 0x6f, 0x6e, 0x64, 0x52, 0x65,
	0x77, 0x61, 0x72, 0x64, 0x12, 0x37, 0x0a, 0x0c, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x72, 0x65, 0x77,
	0x61, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x74, 0x79, 0x70,
	0x65, 0x73, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x41, 0x6d, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00,
	0x52, 0x0b, 0x70, 0x6f, 0x6f, 0x6c, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x73, 0x12, 0x46, 0x0a,
	0x0f, 0x64, 0x65, 0x76, 0x5f, 0x66, 0x75, 0x6e, 0x64, 0x5f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0d, 0x64, 0x65, 0x76, 0x46, 0x75, 0x6e, 0x64, 0x52,
	0x65, 0x77, 0x61, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x0b, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x65, 0x5f,
	0x62, 0x75, 0x72, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x69, 0x6e, 0x63, 0x6f,
	0x6d, 0x65, 0x42, 0x75, 0x72, 0x6e, 0x12, 0x48, 0x0a, 0x10, 0x74, 0x63, 0x79, 0x5f, 0x73, 0x74,
	0x61, 0x6b, 0x65, 0x5f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74,
	0x52, 0x0e, 0x74, 0x63, 0x79, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64,
	0x22, 0x85, 0x01, 0x0a, 0x0b, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x66, 0x75, 0x6e, 0x64,
	0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04,
	0x63, 0x6f, 0x64, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x25, 0x0a, 0x05,
	0x69, 0x6e, 0x5f, 0x74, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x04, 0x69,
	0x6e, 0x54, 0x78, 0x12, 0x23, 0x0a, 0x03, 0x66, 0x65, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0b, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x46, 0x65, 0x65, 0x42, 0x04, 0xc8,
	0xde, 0x1f, 0x00, 0x52, 0x03, 0x66, 0x65, 0x65, 0x22, 0xc4, 0x02, 0x0a, 0x09, 0x45, 0x76, 0x65,
	0x6e, 0x74, 0x42, 0x6f, 0x6e, 0x64, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74,
	0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x2c,
	0x0a, 0x09, 0x62, 0x6f, 0x6e, 0x64, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x0f, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x42, 0x6f, 0x6e, 0x64, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x08, 0x62, 0x6f, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65, 0x12, 0x25, 0x0a, 0x05,
	0x74, 0x78, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x04, 0x74,
	0x78, 0x49, 0x6e, 0x12, 0x54, 0x0a, 0x0c, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64, 0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65,
	0x73, 0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x6e, 0x6f,
	0x64, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x54, 0x0a, 0x0c, 0x62, 0x6f, 0x6e,
	0x64, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64,
	0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x0b, 0x62, 0x6f, 0x6e, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22,
	0xf3, 0x01, 0x0a, 0x07, 0x47, 0x61, 0x73, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x5a, 0x0a, 0x05, 0x61,
	0x73, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74,
	0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x39, 0x0a, 0x08, 0x72, 0x75, 0x6e, 0x65, 0x5f,
	0x61, 0x6d, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x07, 0x72, 0x75, 0x6e, 0x65, 0x41,
	0x6d, 0x74, 0x12, 0x3b, 0x0a, 0x09, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x6d, 0x74, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x08, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x6d, 0x74, 0x12,
	0x14, 0x0a, 0x05, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x36, 0x0a, 0x08, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x47, 0x61,
	0x73, 0x12, 0x2a, 0x0a, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x0e, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x47, 0x61, 0x73, 0x50, 0x6f, 0x6f, 0x6c,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x22, 0x87, 0x01,
	0x0a, 0x0c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x50,
	0x0a, 0x13, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69,
	0x62, 0x75, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x74, 0x79,
	0x70, 0x65, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x72,
	0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x12, 0x72, 0x65,
	0x73, 0x65, 0x72, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x6f, 0x72,
	0x12, 0x25, 0x0a, 0x05, 0x69, 0x6e, 0x5f, 0x74, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x04, 0x69, 0x6e, 0x54, 0x78, 0x22, 0x47, 0x0a, 0x16, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x64, 0x4f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e,
	0x64, 0x12, 0x2d, 0x0a, 0x06, 0x6f, 0x75, 0x74, 0x5f, 0x74, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x10, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x54, 0x78, 0x4f, 0x75, 0x74, 0x49,
	0x74, 0x65, 0x6d, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x05, 0x6f, 0x75, 0x74, 0x54, 0x78,
	0x22, 0x43, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
	0x79, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x6d, 0x73, 0x67, 0x12, 0x20, 0x0a, 0x02, 0x74, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x02, 0x74, 0x78, 0x22, 0x9f, 0x01, 0x0a, 0x0a, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53,
	0x6c, 0x61, 0x73, 0x68, 0x12, 0x58, 0x0a, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65,
	0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x04, 0x70, 0x6f, 0x6f, 0x6c, 0x12, 0x37,
	0x0a, 0x0c, 0x73, 0x6c, 0x61, 0x73, 0x68, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x50, 0x6f, 0x6f,
	0x6c, 0x41, 0x6d, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x0b, 0x73, 0x6c, 0x61, 0x73,
	0x68, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x94, 0x01, 0x0a, 0x0b, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x45, 0x72, 0x72, 0x61, 0x74, 0x61, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44,
	0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44,
	0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x50, 0x6f,
	0x6f, 0x6c, 0x4d, 0x6f, 0x64, 0x42, 0x10, 0xc8, 0xde, 0x1f, 0x00, 0xaa, 0xdf, 0x1f, 0x08, 0x50,
	0x6f, 0x6f, 0x6c, 0x4d, 0x6f, 0x64, 0x73, 0x52, 0x05, 0x70, 0x6f, 0x6f, 0x6c, 0x73, 0x22, 0xbf,
	0x01, 0x0a, 0x08, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x46, 0x65, 0x65, 0x12, 0x4d, 0x0a, 0x05, 0x74,
	0x78, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04,
	0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x54, 0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x23, 0x0a, 0x03, 0x66, 0x65,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x46, 0x65, 0x65, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x03, 0x66, 0x65, 0x65, 0x12,
	0x3f, 0x0a, 0x0b, 0x73, 0x79, 0x6e, 0x74, 0x68, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x73, 0x79, 0x6e, 0x74, 0x68, 0x55, 0x6e, 0x69, 0x74, 0x73,
	0x22, 0x87, 0x01, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4f, 0x75, 0x74, 0x62, 0x6f, 0x75,
	0x6e, 0x64, 0x12, 0x54, 0x0a, 0x08, 0x69, 0x6e, 0x5f, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x3a, 0xe2, 0xde, 0x1f, 0x06, 0x49, 0x6e, 0x54, 0x78, 0x49, 0x44,
	0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44,
	0x52, 0x06, 0x69, 0x6e, 0x54, 0x78, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x02, 0x74, 0x78, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78,
	0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x02, 0x74, 0x78, 0x22, 0x96, 0x01, 0x0a, 0x15, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x54, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x67, 0x65, 0x6e, 0x53, 0x75, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x12, 0x4b, 0x0a, 0x07, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x6c, 0x61,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x52, 0x06, 0x70, 0x75, 0x62, 0x4b, 0x65,
	0x79, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x68,
	0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x68, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x22, 0xa6, 0x01, 0x0a, 0x15, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x73, 0x73,
	0x4b, 0x65, 0x79, 0x67, 0x65, 0x6e, 0x46, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x1f, 0x0a,
	0x0b, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x66, 0x61, 0x69, 0x6c, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x1d,
	0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x55, 0x6e, 0x69, 0x63, 0x61, 0x73, 0x74, 0x12, 0x1f, 0x0a,
	0x0b, 0x62, 0x6c, 0x61, 0x6d, 0x65, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x0a, 0x62, 0x6c, 0x61, 0x6d, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x72,
	0x6f, 0x75, 0x6e, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x91, 0x01, 0x0a,
	0x14, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x67, 0x65, 0x6e, 0x4d,
	0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x4b, 0x0a, 0x07, 0x70, 0x75, 0x62, 0x5f, 0x6b, 0x65, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x32, 0xfa, 0xde, 0x1f, 0x2e, 0x67, 0x69, 0x74, 0x6c,
	0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x50, 0x75, 0x62, 0x4b, 0x65, 0x79, 0x52, 0x06, 0x70, 0x75, 0x62, 0x4b,
	0x65, 0x79, 0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x6e, 0x5f, 0x64, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10,
	0x6d, 0x65, 0x64, 0x69, 0x61, 0x6e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x73,
	0x22, 0x94, 0x01, 0x0a, 0x15, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x73, 0x73, 0x4b, 0x65, 0x79,
	0x73, 0x69, 0x67, 0x6e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54,
	0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54,
	0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x65, 0x64,
	0x69, 0x61, 0x6e, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6d, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x6e, 0x44, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x73, 0x22, 0xa2, 0x01, 0x0a, 0x0f, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x53, 0x6c, 0x61, 0x73, 0x68, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x54, 0x0a, 0x0c, 0x6e,
	0x6f, 0x64, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d,
	0x73, 0x64, 0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x6e, 0x6f, 0x64, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x6c, 0x61, 0x73, 0x68, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x73, 0x6c, 0x61, 0x73, 0x68, 0x50, 0x6f,
	0x69, 0x6e, 0x74, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x22, 0x68, 0x0a, 0x17,
	0x45, 0x76, 0x65, 0x6e, 0x74, 0x50, 0x6f, 0x6f, 0x6c, 0x42, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65,
	0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x12, 0x35, 0x0a, 0x0b, 0x70, 0x6f, 0x6f, 0x6c, 0x5f,
	0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x74,
	0x79, 0x70, 0x65, 0x73, 0x2e, 0x50, 0x6f, 0x6f, 0x6c, 0x4d, 0x6f, 0x64, 0x42, 0x04, 0xc8, 0xde,
	0x1f, 0x00, 0x52, 0x0a, 0x70, 0x6f, 0x6f, 0x6c, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x16,
	0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x22, 0xa8, 0x01, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x4d, 0x69, 0x6e, 0x74, 0x42, 0x75, 0x72, 0x6e, 0x12, 0x31, 0x0a, 0x06, 0x73, 0x75, 0x70, 0x70,
	0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x19, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x2e, 0x4d, 0x69, 0x6e, 0x74, 0x42, 0x75, 0x72, 0x6e, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x06, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x64,
	0x65, 0x6e, 0x6f, 0x6d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x64, 0x65, 0x6e, 0x6f,
	0x6d, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x61,
	0x73, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f,
	0x6e, 0x22, 0xaf, 0x03, 0x0a, 0x18, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x72, 0x61, 0x64, 0x65,
	0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x12, 0x36,
	0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5a, 0x0a, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69,
	0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x05, 0x61, 0x73, 0x73,
	0x65, 0x74, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67,
	0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0c,
	0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x56, 0x0a, 0x0c,
	0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f,
	0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76,
	0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x04, 0x74,
	0x78, 0x49, 0x64, 0x22, 0xb0, 0x03, 0x0a, 0x19, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x72, 0x61,
	0x64, 0x65, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61,
	0x77, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x5a, 0x0a, 0x05, 0x61, 0x73, 0x73,
	0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76,
	0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x05,
	0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde,
	0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f,
	0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x52, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44,
	0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44,
	0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xfe, 0x02, 0x0a, 0x18, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x64, 0x41, 0x73, 0x73, 0x65, 0x74, 0x44, 0x65, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55,
	0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x05, 0x61,
	0x73, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52,
	0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa,
	0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x12, 0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c,
	0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e,
	0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69,
	0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49,
	0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49,
	0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xff, 0x02, 0x0a, 0x19, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x64, 0x41, 0x73, 0x73, 0x65, 0x74, 0x57, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x29, 0x0a,
	0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f,
	0x00, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12, 0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65,
	0x74, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x0c, 0x61, 0x73, 0x73, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69,
	0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72,
	0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78,
	0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54,
	0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f,
	0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72,
	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54,
	0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xaa, 0x02, 0x0a, 0x14, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x52, 0x55, 0x4e, 0x45, 0x50, 0x6f, 0x6f, 0x6c, 0x44, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x12, 0x54, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64, 0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e,
	0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x72, 0x75, 0x6e, 0x65,
	0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8,
	0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b,
	0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x72,
	0x75, 0x6e, 0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x34, 0x0a, 0x05, 0x75, 0x6e, 0x69,
	0x74, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x05, 0x75, 0x6e, 0x69, 0x74, 0x73, 0x12,
	0x45, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x30,
	0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44,
	0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xab, 0x04, 0x0a, 0x15, 0x45, 0x76, 0x65, 0x6e, 0x74,
	0x52, 0x55, 0x4e, 0x45, 0x50, 0x6f, 0x6f, 0x6c, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x12, 0x54, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64, 0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x41,
	0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x62, 0x61, 0x73, 0x69, 0x73, 0x5f,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x62, 0x61,
	0x73, 0x69, 0x73, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x3f, 0x0a, 0x0b, 0x72, 0x75, 0x6e,
	0x65, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a,
	0x72, 0x75, 0x6e, 0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x34, 0x0a, 0x05, 0x75, 0x6e,
	0x69, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda,
	0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f,
	0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x05, 0x75, 0x6e, 0x69, 0x74, 0x73,
	0x12, 0x45, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x30, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49,
	0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x12, 0x2e, 0x0a, 0x13, 0x61, 0x66, 0x66, 0x69, 0x6c,
	0x69, 0x61, 0x74, 0x65, 0x5f, 0x62, 0x61, 0x73, 0x69, 0x73, 0x5f, 0x70, 0x74, 0x73, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x11, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x42,
	0x61, 0x73, 0x69, 0x73, 0x50, 0x74, 0x73, 0x12, 0x49, 0x0a, 0x10, 0x61, 0x66, 0x66, 0x69, 0x6c,
	0x69, 0x61, 0x74, 0x65, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e,
	0x74, 0x52, 0x0f, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x12, 0x60, 0x0a, 0x11, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa,
	0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x10, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x22, 0xf0, 0x04, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4c, 0x6f,
	0x61, 0x6e, 0x4f, 0x70, 0x65, 0x6e, 0x12, 0x51, 0x0a, 0x14, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74,
	0x65, 0x72, 0x61, 0x6c, 0x5f, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x13, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x44, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x65, 0x64, 0x12, 0x6f, 0x0a, 0x10, 0x63, 0x6f, 0x6c,
	0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x5f, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c,
	0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x0f, 0x63, 0x6f, 0x6c, 0x6c, 0x61,
	0x74, 0x65, 0x72, 0x61, 0x6c, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x57, 0x0a, 0x17, 0x63, 0x6f,
	0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69,
	0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x16, 0x63, 0x6f, 0x6c,
	0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x61,
	0x74, 0x69, 0x6f, 0x12, 0x3f, 0x0a, 0x0b, 0x64, 0x65, 0x62, 0x74, 0x5f, 0x69, 0x73, 0x73, 0x75,
	0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x64, 0x65, 0x62, 0x74, 0x49, 0x73,
	0x73, 0x75, 0x65, 0x64, 0x12, 0x49, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12,
	0x67, 0x0a, 0x0c, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69,
	0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x52, 0x0b, 0x74, 0x61, 0x72,
	0x67, 0x65, 0x74, 0x41, 0x73, 0x73, 0x65, 0x74, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69,
	0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49,
	0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49,
	0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xb3, 0x03, 0x0a, 0x12, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x4c, 0x6f, 0x61, 0x6e, 0x52, 0x65, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x51,
	0x0a, 0x14, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x5f, 0x77, 0x69, 0x74,
	0x68, 0x64, 0x72, 0x61, 0x77, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x13, 0x63, 0x6f,
	0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77,
	0x6e, 0x12, 0x6f, 0x0a, 0x10, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x5f,
	0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74,
	0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64,
	0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65,
	0x74, 0x52, 0x0f, 0x63, 0x6f, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x12, 0x3f, 0x0a, 0x0b, 0x64, 0x65, 0x62, 0x74, 0x5f, 0x72, 0x65, 0x70, 0x61, 0x69,
	0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f,
	0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61,
	0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x64, 0x65, 0x62, 0x74, 0x52, 0x65, 0x70,
	0x61, 0x69, 0x64, 0x12, 0x49, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x4d,
	0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x42, 0x38, 0xe2,
	0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69, 0x74, 0x6c, 0x61,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64, 0x22, 0xa2, 0x03,
	0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x48, 0x4f, 0x52, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x12, 0x47, 0x0a, 0x05, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x43, 0x68, 0x61, 0x69, 0x6e, 0x52, 0x05, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x12, 0x4d, 0x0a, 0x07,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa,
	0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x49, 0x0a, 0x10, 0x72,
	0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x65, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x0f, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x46, 0x65, 0x65, 0x12, 0x39, 0x0a, 0x08, 0x66, 0x75, 0x6e, 0x64, 0x5f, 0x61,
	0x6d, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde,
	0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d,
	0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x07, 0x66, 0x75, 0x6e, 0x64, 0x41, 0x6d,
	0x74, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x47, 0x0a, 0x05, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x42, 0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69,
	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64, 0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x05, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x22, 0x37, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74, 0x4d, 0x69,
	0x6d, 0x69, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x55, 0x0a, 0x11, 0x45,
	0x76, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x4d, 0x69, 0x6d, 0x69, 0x72,
	0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
	0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x22, 0x28, 0x0a, 0x0c, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xf1, 0x02, 0x0a,
	0x0b, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x12, 0x36, 0x0a, 0x06,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde,
	0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e,
	0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x29, 0x0a, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x42, 0x04, 0xc8, 0xde, 0x1f, 0x00, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x12,
	0x58, 0x0a, 0x0d, 0x61, 0x73, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c,
	0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0c, 0x61, 0x73, 0x73,
	0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e,
	0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x12, 0x4d, 0x0a, 0x05, 0x74, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x38, 0xe2, 0xde, 0x1f, 0x04, 0x54, 0x78, 0x49, 0x44, 0xfa, 0xde, 0x1f, 0x2c, 0x67, 0x69,
	0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x54, 0x78, 0x49, 0x44, 0x52, 0x04, 0x74, 0x78, 0x49, 0x64,
	0x22, 0xad, 0x01, 0x0a, 0x14, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x43, 0x59, 0x44, 0x69, 0x73,
	0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x54, 0x0a, 0x0c, 0x72, 0x75, 0x6e,
	0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x42,
	0x31, 0xfa, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2d, 0x73, 0x64,
	0x6b, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x41, 0x63, 0x63, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
	0x3f, 0x0a, 0x0b, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x55, 0x69, 0x6e, 0x74, 0x52, 0x0a, 0x72, 0x75, 0x6e, 0x65, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x22, 0xd6, 0x02, 0x0a, 0x0d, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x43, 0x59, 0x43, 0x6c, 0x61,
	0x69, 0x6d, 0x12, 0x56, 0x0a, 0x0c, 0x72, 0x75, 0x6e, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69,
	0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0b, 0x72,
	0x75, 0x6e, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x3d, 0x0a, 0x0a, 0x74, 0x63,
	0x79, 0x5f, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e,
	0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x09,
	0x74, 0x63, 0x79, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x52, 0x0a, 0x0a, 0x6c, 0x31, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa,
	0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68,
	0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65,
	0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x52, 0x09, 0x6c, 0x31, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x5a, 0x0a,
	0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73, 0x65, 0x74, 0x42, 0x35, 0xc8, 0xde, 0x1f,
	0x00, 0xda, 0xde, 0x1f, 0x2d, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f,
	0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x73, 0x73,
	0x65, 0x74, 0x52, 0x05, 0x61, 0x73, 0x73, 0x65, 0x74, 0x22, 0x96, 0x01, 0x0a, 0x0d, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x54, 0x43, 0x59, 0x53, 0x74, 0x61, 0x6b, 0x65, 0x12, 0x4d, 0x0a, 0x07, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde,
	0x1f, 0x2f, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f,
	0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f,
	0x76, 0x33, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x52, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00,
	0xda, 0xde, 0x1f, 0x16, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f,
	0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x22, 0x98, 0x01, 0x0a, 0x0f, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x43, 0x59, 0x55,
	0x6e, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x12, 0x4d, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x33, 0xfa, 0xde, 0x1f, 0x2f, 0x67, 0x69, 0x74,
	0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x36, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x1e, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x16, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68,
	0x2e, 0x55, 0x69, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x2a, 0x2d, 0x0a,
	0x14, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x71, 0x75, 0x69, 0x64, 0x69, 0x74,
	0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x07, 0x0a, 0x03, 0x61, 0x64, 0x64, 0x10, 0x00, 0x12, 0x0c,
	0x0a, 0x08, 0x77, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x10, 0x01, 0x2a, 0x4c, 0x0a, 0x08,
	0x42, 0x6f, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0d, 0x0a, 0x09, 0x62, 0x6f, 0x6e, 0x64,
	0x5f, 0x70, 0x61, 0x69, 0x64, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x62, 0x6f, 0x6e, 0x64, 0x5f,
	0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b, 0x62, 0x6f,
	0x6e, 0x64, 0x5f, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x10, 0x02, 0x12, 0x0d, 0x0a, 0x09, 0x62,
	0x6f, 0x6e, 0x64, 0x5f, 0x63, 0x6f, 0x73, 0x74, 0x10, 0x03, 0x2a, 0x28, 0x0a, 0x12, 0x4d, 0x69,
	0x6e, 0x74, 0x42, 0x75, 0x72, 0x6e, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x08, 0x0a, 0x04, 0x6d, 0x69, 0x6e, 0x74, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x62, 0x75,
	0x72, 0x6e, 0x10, 0x01, 0x42, 0x7c, 0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x79, 0x70, 0x65,
	0x73, 0x42, 0x0f, 0x54, 0x79, 0x70, 0x65, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x50, 0x01, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x6c, 0x61, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
	0x2f, 0x74, 0x68, 0x6f, 0x72, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x68, 0x6f, 0x72, 0x6e,
	0x6f, 0x64, 0x65, 0x2f, 0x76, 0x33, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73,
	0xa2, 0x02, 0x03, 0x54, 0x58, 0x58, 0xaa, 0x02, 0x05, 0x54, 0x79, 0x70, 0x65, 0x73, 0xca, 0x02,
	0x05, 0x54, 0x79, 0x70, 0x65, 0x73, 0xe2, 0x02, 0x11, 0x54, 0x79, 0x70, 0x65, 0x73, 0x5c, 0x47,
	0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x05, 0x54, 0x79, 0x70,
	0x65, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_types_type_events_proto_rawDescOnce sync.Once
	file_types_type_events_proto_rawDescData = file_types_type_events_proto_rawDesc
)

func file_types_type_events_proto_rawDescGZIP() []byte {
	file_types_type_events_proto_rawDescOnce.Do(func() {
		file_types_type_events_proto_rawDescData = protoimpl.X.CompressGZIP(file_types_type_events_proto_rawDescData)
	})
	return file_types_type_events_proto_rawDescData
}

var file_types_type_events_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_types_type_events_proto_msgTypes = make([]protoimpl.MessageInfo, 47)
var file_types_type_events_proto_goTypes = []interface{}{
	(PendingLiquidityType)(0),         // 0: types.PendingLiquidityType
	(BondType)(0),                     // 1: types.BondType
	(MintBurnSupplyType)(0),           // 2: types.MintBurnSupplyType
	(*PoolMod)(nil),                   // 3: types.PoolMod
	(*EventLimitOrder)(nil),           // 4: types.EventLimitOrder
	(*EventStreamingSwap)(nil),        // 5: types.EventStreamingSwap
	(*EventSwap)(nil),                 // 6: types.EventSwap
	(*EventAffiliateFee)(nil),         // 7: types.EventAffiliateFee
	(*EventAddLiquidity)(nil),         // 8: types.EventAddLiquidity
	(*EventWithdraw)(nil),             // 9: types.EventWithdraw
	(*EventPendingLiquidity)(nil),     // 10: types.EventPendingLiquidity
	(*EventDonate)(nil),               // 11: types.EventDonate
	(*EventPool)(nil),                 // 12: types.EventPool
	(*PoolAmt)(nil),                   // 13: types.PoolAmt
	(*EventRewards)(nil),              // 14: types.EventRewards
	(*EventRefund)(nil),               // 15: types.EventRefund
	(*EventBond)(nil),                 // 16: types.EventBond
	(*GasPool)(nil),                   // 17: types.GasPool
	(*EventGas)(nil),                  // 18: types.EventGas
	(*EventReserve)(nil),              // 19: types.EventReserve
	(*EventScheduledOutbound)(nil),    // 20: types.EventScheduledOutbound
	(*EventSecurity)(nil),             // 21: types.EventSecurity
	(*EventSlash)(nil),                // 22: types.EventSlash
	(*EventErrata)(nil),               // 23: types.EventErrata
	(*EventFee)(nil),                  // 24: types.EventFee
	(*EventOutbound)(nil),             // 25: types.EventOutbound
	(*EventTssKeygenSuccess)(nil),     // 26: types.EventTssKeygenSuccess
	(*EventTssKeygenFailure)(nil),     // 27: types.EventTssKeygenFailure
	(*EventTssKeygenMetric)(nil),      // 28: types.EventTssKeygenMetric
	(*EventTssKeysignMetric)(nil),     // 29: types.EventTssKeysignMetric
	(*EventSlashPoint)(nil),           // 30: types.EventSlashPoint
	(*EventPoolBalanceChanged)(nil),   // 31: types.EventPoolBalanceChanged
	(*EventMintBurn)(nil),             // 32: types.EventMintBurn
	(*EventTradeAccountDeposit)(nil),  // 33: types.EventTradeAccountDeposit
	(*EventTradeAccountWithdraw)(nil), // 34: types.EventTradeAccountWithdraw
	(*EventSecuredAssetDeposit)(nil),  // 35: types.EventSecuredAssetDeposit
	(*EventSecuredAssetWithdraw)(nil), // 36: types.EventSecuredAssetWithdraw
	(*EventRUNEPoolDeposit)(nil),      // 37: types.EventRUNEPoolDeposit
	(*EventRUNEPoolWithdraw)(nil),     // 38: types.EventRUNEPoolWithdraw
	(*EventLoanOpen)(nil),             // 39: types.EventLoanOpen
	(*EventLoanRepayment)(nil),        // 40: types.EventLoanRepayment
	(*EventTHORName)(nil),             // 41: types.EventTHORName
	(*EventSetMimir)(nil),             // 42: types.EventSetMimir
	(*EventSetNodeMimir)(nil),         // 43: types.EventSetNodeMimir
	(*EventVersion)(nil),              // 44: types.EventVersion
	(*EventSwitch)(nil),               // 45: types.EventSwitch
	(*EventTCYDistribution)(nil),      // 46: types.EventTCYDistribution
	(*EventTCYClaim)(nil),             // 47: types.EventTCYClaim
	(*EventTCYStake)(nil),             // 48: types.EventTCYStake
	(*EventTCYUnstake)(nil),           // 49: types.EventTCYUnstake
	(*common.Asset)(nil),              // 50: common.Asset
	(*common.Coin)(nil),               // 51: common.Coin
	(*common.Tx)(nil),                 // 52: common.Tx
	(PoolStatus)(0),                   // 53: types.PoolStatus
	(*common.Fee)(nil),                // 54: common.Fee
	(*ReserveContributor)(nil),        // 55: types.ReserveContributor
	(*TxOutItem)(nil),                 // 56: types.TxOutItem
}
var file_types_type_events_proto_depIdxs = []int32{
	50, // 0: types.PoolMod.asset:type_name -> common.Asset
	51, // 1: types.EventLimitOrder.source:type_name -> common.Coin
	51, // 2: types.EventLimitOrder.target:type_name -> common.Coin
	51, // 3: types.EventStreamingSwap.deposit:type_name -> common.Coin
	51, // 4: types.EventStreamingSwap.in:type_name -> common.Coin
	51, // 5: types.EventStreamingSwap.out:type_name -> common.Coin
	50, // 6: types.EventSwap.pool:type_name -> common.Asset
	52, // 7: types.EventSwap.in_tx:type_name -> common.Tx
	52, // 8: types.EventSwap.out_txs:type_name -> common.Tx
	51, // 9: types.EventSwap.emit_asset:type_name -> common.Coin
	50, // 10: types.EventAffiliateFee.asset:type_name -> common.Asset
	50, // 11: types.EventAddLiquidity.pool:type_name -> common.Asset
	50, // 12: types.EventWithdraw.pool:type_name -> common.Asset
	52, // 13: types.EventWithdraw.in_tx:type_name -> common.Tx
	50, // 14: types.EventPendingLiquidity.pool:type_name -> common.Asset
	0,  // 15: types.EventPendingLiquidity.pending_type:type_name -> types.PendingLiquidityType
	50, // 16: types.EventDonate.pool:type_name -> common.Asset
	52, // 17: types.EventDonate.in_tx:type_name -> common.Tx
	50, // 18: types.EventPool.pool:type_name -> common.Asset
	53, // 19: types.EventPool.Status:type_name -> types.PoolStatus
	50, // 20: types.PoolAmt.asset:type_name -> common.Asset
	13, // 21: types.EventRewards.pool_rewards:type_name -> types.PoolAmt
	52, // 22: types.EventRefund.in_tx:type_name -> common.Tx
	54, // 23: types.EventRefund.fee:type_name -> common.Fee
	1,  // 24: types.EventBond.bond_type:type_name -> types.BondType
	52, // 25: types.EventBond.tx_in:type_name -> common.Tx
	50, // 26: types.GasPool.asset:type_name -> common.Asset
	17, // 27: types.EventGas.pools:type_name -> types.GasPool
	55, // 28: types.EventReserve.reserve_contributor:type_name -> types.ReserveContributor
	52, // 29: types.EventReserve.in_tx:type_name -> common.Tx
	56, // 30: types.EventScheduledOutbound.out_tx:type_name -> types.TxOutItem
	52, // 31: types.EventSecurity.tx:type_name -> common.Tx
	50, // 32: types.EventSlash.pool:type_name -> common.Asset
	13, // 33: types.EventSlash.slash_amount:type_name -> types.PoolAmt
	3,  // 34: types.EventErrata.pools:type_name -> types.PoolMod
	54, // 35: types.EventFee.fee:type_name -> common.Fee
	52, // 36: types.EventOutbound.tx:type_name -> common.Tx
	3,  // 37: types.EventPoolBalanceChanged.pool_change:type_name -> types.PoolMod
	2,  // 38: types.EventMintBurn.supply:type_name -> types.MintBurnSupplyType
	50, // 39: types.EventTradeAccountDeposit.asset:type_name -> common.Asset
	50, // 40: types.EventTradeAccountWithdraw.asset:type_name -> common.Asset
	50, // 41: types.EventSecuredAssetDeposit.asset:type_name -> common.Asset
	50, // 42: types.EventSecuredAssetWithdraw.asset:type_name -> common.Asset
	50, // 43: types.EventLoanOpen.collateral_asset:type_name -> common.Asset
	50, // 44: types.EventLoanOpen.target_asset:type_name -> common.Asset
	50, // 45: types.EventLoanRepayment.collateral_asset:type_name -> common.Asset
	50, // 46: types.EventSwitch.asset:type_name -> common.Asset
	50, // 47: types.EventTCYClaim.asset:type_name -> common.Asset
	48, // [48:48] is the sub-list for method output_type
	48, // [48:48] is the sub-list for method input_type
	48, // [48:48] is the sub-list for extension type_name
	48, // [48:48] is the sub-list for extension extendee
	0,  // [0:48] is the sub-list for field type_name
}

func init() { file_types_type_events_proto_init() }
func file_types_type_events_proto_init() {
	if File_types_type_events_proto != nil {
		return
	}
	file_types_type_pool_proto_init()
	file_types_type_reserve_contributor_proto_init()
	file_types_type_tx_out_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_types_type_events_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolMod); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventLimitOrder); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventStreamingSwap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSwap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventAffiliateFee); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventAddLiquidity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventWithdraw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPendingLiquidity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventDonate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PoolAmt); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRewards); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRefund); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventBond); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GasPool); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventGas); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventReserve); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventScheduledOutbound); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSecurity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSlash); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventErrata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventFee); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventOutbound); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTssKeygenSuccess); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTssKeygenFailure); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTssKeygenMetric); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTssKeysignMetric); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSlashPoint); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventPoolBalanceChanged); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventMintBurn); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTradeAccountDeposit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTradeAccountWithdraw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSecuredAssetDeposit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSecuredAssetWithdraw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRUNEPoolDeposit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventRUNEPoolWithdraw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventLoanOpen); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventLoanRepayment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTHORName); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSetMimir); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSetNodeMimir); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventVersion); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventSwitch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTCYDistribution); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTCYClaim); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTCYStake); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_types_type_events_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EventTCYUnstake); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_types_type_events_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   47,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_types_type_events_proto_goTypes,
		DependencyIndexes: file_types_type_events_proto_depIdxs,
		EnumInfos:         file_types_type_events_proto_enumTypes,
		MessageInfos:      file_types_type_events_proto_msgTypes,
	}.Build()
	File_types_type_events_proto = out.File
	file_types_type_events_proto_rawDesc = nil
	file_types_type_events_proto_goTypes = nil
	file_types_type_events_proto_depIdxs = nil
}
