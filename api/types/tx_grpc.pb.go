// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: types/tx.proto

package types

import (
	context "context"
	types "github.com/CosmWasm/wasmd/x/wasm/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_Ban_FullMethodName                  = "/types.Msg/Ban"
	Msg_Deposit_FullMethodName              = "/types.Msg/Deposit"
	Msg_ErrataTx_FullMethodName             = "/types.Msg/ErrataTx"
	Msg_ErrataTxQuorum_FullMethodName       = "/types.Msg/ErrataTxQuorum"
	Msg_Mimir_FullMethodName                = "/types.Msg/Mimir"
	Msg_NetworkFee_FullMethodName           = "/types.Msg/NetworkFee"
	Msg_NetworkFeeQuorum_FullMethodName     = "/types.Msg/NetworkFeeQuorum"
	Msg_NodePauseChain_FullMethodName       = "/types.Msg/NodePauseChain"
	Msg_ObservedTxIn_FullMethodName         = "/types.Msg/ObservedTxIn"
	Msg_ObservedTxOut_FullMethodName        = "/types.Msg/ObservedTxOut"
	Msg_ObservedTxQuorum_FullMethodName     = "/types.Msg/ObservedTxQuorum"
	Msg_ThorSend_FullMethodName             = "/types.Msg/ThorSend"
	Msg_SetIPAddress_FullMethodName         = "/types.Msg/SetIPAddress"
	Msg_SetNodeKeys_FullMethodName          = "/types.Msg/SetNodeKeys"
	Msg_Solvency_FullMethodName             = "/types.Msg/Solvency"
	Msg_SolvencyQuorum_FullMethodName       = "/types.Msg/SolvencyQuorum"
	Msg_TssKeysignFail_FullMethodName       = "/types.Msg/TssKeysignFail"
	Msg_TssPool_FullMethodName              = "/types.Msg/TssPool"
	Msg_SetVersion_FullMethodName           = "/types.Msg/SetVersion"
	Msg_ProposeUpgrade_FullMethodName       = "/types.Msg/ProposeUpgrade"
	Msg_ApproveUpgrade_FullMethodName       = "/types.Msg/ApproveUpgrade"
	Msg_RejectUpgrade_FullMethodName        = "/types.Msg/RejectUpgrade"
	Msg_StoreCode_FullMethodName            = "/types.Msg/StoreCode"
	Msg_InstantiateContract_FullMethodName  = "/types.Msg/InstantiateContract"
	Msg_InstantiateContract2_FullMethodName = "/types.Msg/InstantiateContract2"
	Msg_ExecuteContract_FullMethodName      = "/types.Msg/ExecuteContract"
	Msg_MigrateContract_FullMethodName      = "/types.Msg/MigrateContract"
	Msg_SudoContract_FullMethodName         = "/types.Msg/SudoContract"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error)
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error)
	ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error)
	ErrataTxQuorum(ctx context.Context, in *MsgErrataTxQuorum, opts ...grpc.CallOption) (*MsgEmpty, error)
	Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error)
	NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error)
	NetworkFeeQuorum(ctx context.Context, in *MsgNetworkFeeQuorum, opts ...grpc.CallOption) (*MsgEmpty, error)
	NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error)
	ObservedTxQuorum(ctx context.Context, in *MsgObservedTxQuorum, opts ...grpc.CallOption) (*MsgEmpty, error)
	ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error)
	Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error)
	SolvencyQuorum(ctx context.Context, in *MsgSolvencyQuorum, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error)
	TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error)
	SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error)
	ProposeUpgrade(ctx context.Context, in *MsgProposeUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error)
	ApproveUpgrade(ctx context.Context, in *MsgApproveUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error)
	RejectUpgrade(ctx context.Context, in *MsgRejectUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error)
	// CosmWasm interface cloned in order so that we can register the x/thorchain message server as the server for x/wasm messages, and route through version control
	StoreCode(ctx context.Context, in *types.MsgStoreCode, opts ...grpc.CallOption) (*types.MsgStoreCodeResponse, error)
	InstantiateContract(ctx context.Context, in *types.MsgInstantiateContract, opts ...grpc.CallOption) (*types.MsgInstantiateContractResponse, error)
	InstantiateContract2(ctx context.Context, in *types.MsgInstantiateContract2, opts ...grpc.CallOption) (*types.MsgInstantiateContract2Response, error)
	ExecuteContract(ctx context.Context, in *types.MsgExecuteContract, opts ...grpc.CallOption) (*types.MsgExecuteContractResponse, error)
	MigrateContract(ctx context.Context, in *types.MsgMigrateContract, opts ...grpc.CallOption) (*types.MsgMigrateContractResponse, error)
	SudoContract(ctx context.Context, in *types.MsgSudoContract, opts ...grpc.CallOption) (*types.MsgSudoContractResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Ban(ctx context.Context, in *MsgBan, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Ban_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Deposit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ErrataTx(ctx context.Context, in *MsgErrataTx, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ErrataTx_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ErrataTxQuorum(ctx context.Context, in *MsgErrataTxQuorum, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ErrataTxQuorum_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Mimir(ctx context.Context, in *MsgMimir, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Mimir_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NetworkFee(ctx context.Context, in *MsgNetworkFee, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NetworkFee_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NetworkFeeQuorum(ctx context.Context, in *MsgNetworkFeeQuorum, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NetworkFeeQuorum_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NodePauseChain(ctx context.Context, in *MsgNodePauseChain, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_NodePauseChain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxIn(ctx context.Context, in *MsgObservedTxIn, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxIn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxOut(ctx context.Context, in *MsgObservedTxOut, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxOut_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ObservedTxQuorum(ctx context.Context, in *MsgObservedTxQuorum, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ObservedTxQuorum_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ThorSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ThorSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetIPAddress(ctx context.Context, in *MsgSetIPAddress, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetIPAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetNodeKeys(ctx context.Context, in *MsgSetNodeKeys, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetNodeKeys_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Solvency(ctx context.Context, in *MsgSolvency, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_Solvency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SolvencyQuorum(ctx context.Context, in *MsgSolvencyQuorum, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SolvencyQuorum_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssKeysignFail(ctx context.Context, in *MsgTssKeysignFail, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssKeysignFail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TssPool(ctx context.Context, in *MsgTssPool, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_TssPool_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetVersion(ctx context.Context, in *MsgSetVersion, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_SetVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProposeUpgrade(ctx context.Context, in *MsgProposeUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ProposeUpgrade_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ApproveUpgrade(ctx context.Context, in *MsgApproveUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_ApproveUpgrade_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RejectUpgrade(ctx context.Context, in *MsgRejectUpgrade, opts ...grpc.CallOption) (*MsgEmpty, error) {
	out := new(MsgEmpty)
	err := c.cc.Invoke(ctx, Msg_RejectUpgrade_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) StoreCode(ctx context.Context, in *types.MsgStoreCode, opts ...grpc.CallOption) (*types.MsgStoreCodeResponse, error) {
	out := new(types.MsgStoreCodeResponse)
	err := c.cc.Invoke(ctx, Msg_StoreCode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantiateContract(ctx context.Context, in *types.MsgInstantiateContract, opts ...grpc.CallOption) (*types.MsgInstantiateContractResponse, error) {
	out := new(types.MsgInstantiateContractResponse)
	err := c.cc.Invoke(ctx, Msg_InstantiateContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantiateContract2(ctx context.Context, in *types.MsgInstantiateContract2, opts ...grpc.CallOption) (*types.MsgInstantiateContract2Response, error) {
	out := new(types.MsgInstantiateContract2Response)
	err := c.cc.Invoke(ctx, Msg_InstantiateContract2_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ExecuteContract(ctx context.Context, in *types.MsgExecuteContract, opts ...grpc.CallOption) (*types.MsgExecuteContractResponse, error) {
	out := new(types.MsgExecuteContractResponse)
	err := c.cc.Invoke(ctx, Msg_ExecuteContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MigrateContract(ctx context.Context, in *types.MsgMigrateContract, opts ...grpc.CallOption) (*types.MsgMigrateContractResponse, error) {
	out := new(types.MsgMigrateContractResponse)
	err := c.cc.Invoke(ctx, Msg_MigrateContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SudoContract(ctx context.Context, in *types.MsgSudoContract, opts ...grpc.CallOption) (*types.MsgSudoContractResponse, error) {
	out := new(types.MsgSudoContractResponse)
	err := c.cc.Invoke(ctx, Msg_SudoContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	Ban(context.Context, *MsgBan) (*MsgEmpty, error)
	Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error)
	ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error)
	ErrataTxQuorum(context.Context, *MsgErrataTxQuorum) (*MsgEmpty, error)
	Mimir(context.Context, *MsgMimir) (*MsgEmpty, error)
	NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error)
	NetworkFeeQuorum(context.Context, *MsgNetworkFeeQuorum) (*MsgEmpty, error)
	NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error)
	ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error)
	ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error)
	ObservedTxQuorum(context.Context, *MsgObservedTxQuorum) (*MsgEmpty, error)
	ThorSend(context.Context, *MsgSend) (*MsgEmpty, error)
	SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error)
	SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error)
	Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error)
	SolvencyQuorum(context.Context, *MsgSolvencyQuorum) (*MsgEmpty, error)
	TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error)
	TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error)
	SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error)
	ProposeUpgrade(context.Context, *MsgProposeUpgrade) (*MsgEmpty, error)
	ApproveUpgrade(context.Context, *MsgApproveUpgrade) (*MsgEmpty, error)
	RejectUpgrade(context.Context, *MsgRejectUpgrade) (*MsgEmpty, error)
	// CosmWasm interface cloned in order so that we can register the x/thorchain message server as the server for x/wasm messages, and route through version control
	StoreCode(context.Context, *types.MsgStoreCode) (*types.MsgStoreCodeResponse, error)
	InstantiateContract(context.Context, *types.MsgInstantiateContract) (*types.MsgInstantiateContractResponse, error)
	InstantiateContract2(context.Context, *types.MsgInstantiateContract2) (*types.MsgInstantiateContract2Response, error)
	ExecuteContract(context.Context, *types.MsgExecuteContract) (*types.MsgExecuteContractResponse, error)
	MigrateContract(context.Context, *types.MsgMigrateContract) (*types.MsgMigrateContractResponse, error)
	SudoContract(context.Context, *types.MsgSudoContract) (*types.MsgSudoContractResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) Ban(context.Context, *MsgBan) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ban not implemented")
}
func (UnimplementedMsgServer) Deposit(context.Context, *MsgDeposit) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedMsgServer) ErrataTx(context.Context, *MsgErrataTx) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrataTx not implemented")
}
func (UnimplementedMsgServer) ErrataTxQuorum(context.Context, *MsgErrataTxQuorum) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ErrataTxQuorum not implemented")
}
func (UnimplementedMsgServer) Mimir(context.Context, *MsgMimir) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mimir not implemented")
}
func (UnimplementedMsgServer) NetworkFee(context.Context, *MsgNetworkFee) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetworkFee not implemented")
}
func (UnimplementedMsgServer) NetworkFeeQuorum(context.Context, *MsgNetworkFeeQuorum) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NetworkFeeQuorum not implemented")
}
func (UnimplementedMsgServer) NodePauseChain(context.Context, *MsgNodePauseChain) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodePauseChain not implemented")
}
func (UnimplementedMsgServer) ObservedTxIn(context.Context, *MsgObservedTxIn) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxIn not implemented")
}
func (UnimplementedMsgServer) ObservedTxOut(context.Context, *MsgObservedTxOut) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxOut not implemented")
}
func (UnimplementedMsgServer) ObservedTxQuorum(context.Context, *MsgObservedTxQuorum) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObservedTxQuorum not implemented")
}
func (UnimplementedMsgServer) ThorSend(context.Context, *MsgSend) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThorSend not implemented")
}
func (UnimplementedMsgServer) SetIPAddress(context.Context, *MsgSetIPAddress) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIPAddress not implemented")
}
func (UnimplementedMsgServer) SetNodeKeys(context.Context, *MsgSetNodeKeys) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNodeKeys not implemented")
}
func (UnimplementedMsgServer) Solvency(context.Context, *MsgSolvency) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Solvency not implemented")
}
func (UnimplementedMsgServer) SolvencyQuorum(context.Context, *MsgSolvencyQuorum) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolvencyQuorum not implemented")
}
func (UnimplementedMsgServer) TssKeysignFail(context.Context, *MsgTssKeysignFail) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssKeysignFail not implemented")
}
func (UnimplementedMsgServer) TssPool(context.Context, *MsgTssPool) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TssPool not implemented")
}
func (UnimplementedMsgServer) SetVersion(context.Context, *MsgSetVersion) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVersion not implemented")
}
func (UnimplementedMsgServer) ProposeUpgrade(context.Context, *MsgProposeUpgrade) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeUpgrade not implemented")
}
func (UnimplementedMsgServer) ApproveUpgrade(context.Context, *MsgApproveUpgrade) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveUpgrade not implemented")
}
func (UnimplementedMsgServer) RejectUpgrade(context.Context, *MsgRejectUpgrade) (*MsgEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectUpgrade not implemented")
}
func (UnimplementedMsgServer) StoreCode(context.Context, *types.MsgStoreCode) (*types.MsgStoreCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreCode not implemented")
}
func (UnimplementedMsgServer) InstantiateContract(context.Context, *types.MsgInstantiateContract) (*types.MsgInstantiateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantiateContract not implemented")
}
func (UnimplementedMsgServer) InstantiateContract2(context.Context, *types.MsgInstantiateContract2) (*types.MsgInstantiateContract2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantiateContract2 not implemented")
}
func (UnimplementedMsgServer) ExecuteContract(context.Context, *types.MsgExecuteContract) (*types.MsgExecuteContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteContract not implemented")
}
func (UnimplementedMsgServer) MigrateContract(context.Context, *types.MsgMigrateContract) (*types.MsgMigrateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateContract not implemented")
}
func (UnimplementedMsgServer) SudoContract(context.Context, *types.MsgSudoContract) (*types.MsgSudoContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SudoContract not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Ban_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Ban(ctx, req.(*MsgBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Deposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ErrataTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgErrataTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ErrataTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ErrataTx_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ErrataTx(ctx, req.(*MsgErrataTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ErrataTxQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgErrataTxQuorum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ErrataTxQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ErrataTxQuorum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ErrataTxQuorum(ctx, req.(*MsgErrataTxQuorum))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Mimir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMimir)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Mimir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Mimir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Mimir(ctx, req.(*MsgMimir))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NetworkFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNetworkFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NetworkFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NetworkFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NetworkFee(ctx, req.(*MsgNetworkFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NetworkFeeQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNetworkFeeQuorum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NetworkFeeQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NetworkFeeQuorum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NetworkFeeQuorum(ctx, req.(*MsgNetworkFeeQuorum))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NodePauseChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNodePauseChain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NodePauseChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NodePauseChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NodePauseChain(ctx, req.(*MsgNodePauseChain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxIn(ctx, req.(*MsgObservedTxIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxOut(ctx, req.(*MsgObservedTxOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ObservedTxQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgObservedTxQuorum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ObservedTxQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ObservedTxQuorum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ObservedTxQuorum(ctx, req.(*MsgObservedTxQuorum))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ThorSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ThorSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ThorSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ThorSend(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetIPAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetIPAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetIPAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetIPAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetIPAddress(ctx, req.(*MsgSetIPAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetNodeKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetNodeKeys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetNodeKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetNodeKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetNodeKeys(ctx, req.(*MsgSetNodeKeys))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Solvency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSolvency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Solvency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Solvency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Solvency(ctx, req.(*MsgSolvency))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SolvencyQuorum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSolvencyQuorum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SolvencyQuorum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SolvencyQuorum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SolvencyQuorum(ctx, req.(*MsgSolvencyQuorum))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssKeysignFail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssKeysignFail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssKeysignFail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssKeysignFail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssKeysignFail(ctx, req.(*MsgTssKeysignFail))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TssPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTssPool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TssPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_TssPool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TssPool(ctx, req.(*MsgTssPool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetVersion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetVersion(ctx, req.(*MsgSetVersion))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProposeUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposeUpgrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposeUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ProposeUpgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposeUpgrade(ctx, req.(*MsgProposeUpgrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ApproveUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgApproveUpgrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ApproveUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ApproveUpgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ApproveUpgrade(ctx, req.(*MsgApproveUpgrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RejectUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRejectUpgrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RejectUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RejectUpgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RejectUpgrade(ctx, req.(*MsgRejectUpgrade))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_StoreCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgStoreCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).StoreCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_StoreCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).StoreCode(ctx, req.(*types.MsgStoreCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantiateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgInstantiateContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantiateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_InstantiateContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantiateContract(ctx, req.(*types.MsgInstantiateContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantiateContract2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgInstantiateContract2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantiateContract2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_InstantiateContract2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantiateContract2(ctx, req.(*types.MsgInstantiateContract2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ExecuteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgExecuteContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ExecuteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ExecuteContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ExecuteContract(ctx, req.(*types.MsgExecuteContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MigrateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgMigrateContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MigrateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MigrateContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MigrateContract(ctx, req.(*types.MsgMigrateContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SudoContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.MsgSudoContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SudoContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SudoContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SudoContract(ctx, req.(*types.MsgSudoContract))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "types.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ban",
			Handler:    _Msg_Ban_Handler,
		},
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "ErrataTx",
			Handler:    _Msg_ErrataTx_Handler,
		},
		{
			MethodName: "ErrataTxQuorum",
			Handler:    _Msg_ErrataTxQuorum_Handler,
		},
		{
			MethodName: "Mimir",
			Handler:    _Msg_Mimir_Handler,
		},
		{
			MethodName: "NetworkFee",
			Handler:    _Msg_NetworkFee_Handler,
		},
		{
			MethodName: "NetworkFeeQuorum",
			Handler:    _Msg_NetworkFeeQuorum_Handler,
		},
		{
			MethodName: "NodePauseChain",
			Handler:    _Msg_NodePauseChain_Handler,
		},
		{
			MethodName: "ObservedTxIn",
			Handler:    _Msg_ObservedTxIn_Handler,
		},
		{
			MethodName: "ObservedTxOut",
			Handler:    _Msg_ObservedTxOut_Handler,
		},
		{
			MethodName: "ObservedTxQuorum",
			Handler:    _Msg_ObservedTxQuorum_Handler,
		},
		{
			MethodName: "ThorSend",
			Handler:    _Msg_ThorSend_Handler,
		},
		{
			MethodName: "SetIPAddress",
			Handler:    _Msg_SetIPAddress_Handler,
		},
		{
			MethodName: "SetNodeKeys",
			Handler:    _Msg_SetNodeKeys_Handler,
		},
		{
			MethodName: "Solvency",
			Handler:    _Msg_Solvency_Handler,
		},
		{
			MethodName: "SolvencyQuorum",
			Handler:    _Msg_SolvencyQuorum_Handler,
		},
		{
			MethodName: "TssKeysignFail",
			Handler:    _Msg_TssKeysignFail_Handler,
		},
		{
			MethodName: "TssPool",
			Handler:    _Msg_TssPool_Handler,
		},
		{
			MethodName: "SetVersion",
			Handler:    _Msg_SetVersion_Handler,
		},
		{
			MethodName: "ProposeUpgrade",
			Handler:    _Msg_ProposeUpgrade_Handler,
		},
		{
			MethodName: "ApproveUpgrade",
			Handler:    _Msg_ApproveUpgrade_Handler,
		},
		{
			MethodName: "RejectUpgrade",
			Handler:    _Msg_RejectUpgrade_Handler,
		},
		{
			MethodName: "StoreCode",
			Handler:    _Msg_StoreCode_Handler,
		},
		{
			MethodName: "InstantiateContract",
			Handler:    _Msg_InstantiateContract_Handler,
		},
		{
			MethodName: "InstantiateContract2",
			Handler:    _Msg_InstantiateContract2_Handler,
		},
		{
			MethodName: "ExecuteContract",
			Handler:    _Msg_ExecuteContract_Handler,
		},
		{
			MethodName: "MigrateContract",
			Handler:    _Msg_MigrateContract_Handler,
		},
		{
			MethodName: "SudoContract",
			Handler:    _Msg_SudoContract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "types/tx.proto",
}
