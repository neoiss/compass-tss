// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/query_vault.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	common "github.com/mapprotocol/compass-tss/common"
	github_com_mapprotocol_compass_v3_common "github.com/mapprotocol/compass-tss/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryVaultRequest struct {
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Height string `protobuf:"bytes,2,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *QueryVaultRequest) Reset()         { *m = QueryVaultRequest{} }
func (m *QueryVaultRequest) String() string { return proto.CompactTextString(m) }
func (*QueryVaultRequest) ProtoMessage()    {}
func (*QueryVaultRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{0}
}
func (m *QueryVaultRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVaultRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVaultRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVaultRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVaultRequest.Merge(m, src)
}
func (m *QueryVaultRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryVaultRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVaultRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVaultRequest proto.InternalMessageInfo

func (m *QueryVaultRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *QueryVaultRequest) GetHeight() string {
	if m != nil {
		return m.Height
	}
	return ""
}

type QueryVaultResponse struct {
	BlockHeight int64                                          `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	PubKey      string                                         `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Coins       github_com_mapprotocol_compass_v3_common.Coins `protobuf:"bytes,3,rep,name=coins,proto3,castrepeated=github.com/mapprotocol/compass-tss/common.Coins" json:"coins"`
	Type        string                                         `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Status      string                                         `protobuf:"bytes,5,opt,name=status,proto3" json:"status"`
	StatusSince int64                                          `protobuf:"varint,6,opt,name=status_since,json=statusSince,proto3" json:"status_since,omitempty"`
	// the list of node public keys which are members of the vault
	Membership            []string        `protobuf:"bytes,7,rep,name=membership,proto3" json:"membership,omitempty"`
	Chains                []string        `protobuf:"bytes,8,rep,name=chains,proto3" json:"chains,omitempty"`
	InboundTxCount        int64           `protobuf:"varint,9,opt,name=inbound_tx_count,json=inboundTxCount,proto3" json:"inbound_tx_count,omitempty"`
	OutboundTxCount       int64           `protobuf:"varint,10,opt,name=outbound_tx_count,json=outboundTxCount,proto3" json:"outbound_tx_count,omitempty"`
	PendingTxBlockHeights []int64         `protobuf:"varint,11,rep,packed,name=pending_tx_block_heights,json=pendingTxBlockHeights,proto3" json:"pending_tx_block_heights,omitempty"`
	Routers               []*VaultRouter  `protobuf:"bytes,12,rep,name=routers,proto3" json:"routers"`
	Addresses             []*VaultAddress `protobuf:"bytes,13,rep,name=addresses,proto3" json:"addresses"`
	Frozen                []string        `protobuf:"bytes,14,rep,name=frozen,proto3" json:"frozen,omitempty"`
}

func (m *QueryVaultResponse) Reset()         { *m = QueryVaultResponse{} }
func (m *QueryVaultResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVaultResponse) ProtoMessage()    {}
func (*QueryVaultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{1}
}
func (m *QueryVaultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVaultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVaultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVaultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVaultResponse.Merge(m, src)
}
func (m *QueryVaultResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVaultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVaultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVaultResponse proto.InternalMessageInfo

func (m *QueryVaultResponse) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *QueryVaultResponse) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *QueryVaultResponse) GetCoins() github_com_mapprotocol_compass_v3_common.Coins {
	if m != nil {
		return m.Coins
	}
	return nil
}

func (m *QueryVaultResponse) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *QueryVaultResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *QueryVaultResponse) GetStatusSince() int64 {
	if m != nil {
		return m.StatusSince
	}
	return 0
}

func (m *QueryVaultResponse) GetMembership() []string {
	if m != nil {
		return m.Membership
	}
	return nil
}

func (m *QueryVaultResponse) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *QueryVaultResponse) GetInboundTxCount() int64 {
	if m != nil {
		return m.InboundTxCount
	}
	return 0
}

func (m *QueryVaultResponse) GetOutboundTxCount() int64 {
	if m != nil {
		return m.OutboundTxCount
	}
	return 0
}

func (m *QueryVaultResponse) GetPendingTxBlockHeights() []int64 {
	if m != nil {
		return m.PendingTxBlockHeights
	}
	return nil
}

func (m *QueryVaultResponse) GetRouters() []*VaultRouter {
	if m != nil {
		return m.Routers
	}
	return nil
}

func (m *QueryVaultResponse) GetAddresses() []*VaultAddress {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *QueryVaultResponse) GetFrozen() []string {
	if m != nil {
		return m.Frozen
	}
	return nil
}

type QueryAsgardVaultsRequest struct {
	Height string `protobuf:"bytes,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *QueryAsgardVaultsRequest) Reset()         { *m = QueryAsgardVaultsRequest{} }
func (m *QueryAsgardVaultsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAsgardVaultsRequest) ProtoMessage()    {}
func (*QueryAsgardVaultsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{2}
}
func (m *QueryAsgardVaultsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAsgardVaultsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAsgardVaultsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAsgardVaultsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAsgardVaultsRequest.Merge(m, src)
}
func (m *QueryAsgardVaultsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAsgardVaultsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAsgardVaultsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAsgardVaultsRequest proto.InternalMessageInfo

func (m *QueryAsgardVaultsRequest) GetHeight() string {
	if m != nil {
		return m.Height
	}
	return ""
}

type QueryAsgardVaultsResponse struct {
	AsgardVaults []*QueryVaultResponse `protobuf:"bytes,1,rep,name=asgard_vaults,json=asgardVaults,proto3" json:"asgard_vaults,omitempty"`
}

func (m *QueryAsgardVaultsResponse) Reset()         { *m = QueryAsgardVaultsResponse{} }
func (m *QueryAsgardVaultsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAsgardVaultsResponse) ProtoMessage()    {}
func (*QueryAsgardVaultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{3}
}
func (m *QueryAsgardVaultsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAsgardVaultsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAsgardVaultsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAsgardVaultsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAsgardVaultsResponse.Merge(m, src)
}
func (m *QueryAsgardVaultsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAsgardVaultsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAsgardVaultsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAsgardVaultsResponse proto.InternalMessageInfo

func (m *QueryAsgardVaultsResponse) GetAsgardVaults() []*QueryVaultResponse {
	if m != nil {
		return m.AsgardVaults
	}
	return nil
}

type QueryVaultsPubkeysRequest struct {
	Height string `protobuf:"bytes,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *QueryVaultsPubkeysRequest) Reset()         { *m = QueryVaultsPubkeysRequest{} }
func (m *QueryVaultsPubkeysRequest) String() string { return proto.CompactTextString(m) }
func (*QueryVaultsPubkeysRequest) ProtoMessage()    {}
func (*QueryVaultsPubkeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{4}
}
func (m *QueryVaultsPubkeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVaultsPubkeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVaultsPubkeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVaultsPubkeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVaultsPubkeysRequest.Merge(m, src)
}
func (m *QueryVaultsPubkeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryVaultsPubkeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVaultsPubkeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVaultsPubkeysRequest proto.InternalMessageInfo

func (m *QueryVaultsPubkeysRequest) GetHeight() string {
	if m != nil {
		return m.Height
	}
	return ""
}

type QueryVaultsPubkeysResponse struct {
	Asgard   []*VaultInfo `protobuf:"bytes,1,rep,name=asgard,proto3" json:"asgard"`
	Inactive []*VaultInfo `protobuf:"bytes,2,rep,name=inactive,proto3" json:"inactive"`
}

func (m *QueryVaultsPubkeysResponse) Reset()         { *m = QueryVaultsPubkeysResponse{} }
func (m *QueryVaultsPubkeysResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVaultsPubkeysResponse) ProtoMessage()    {}
func (*QueryVaultsPubkeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{5}
}
func (m *QueryVaultsPubkeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVaultsPubkeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVaultsPubkeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVaultsPubkeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVaultsPubkeysResponse.Merge(m, src)
}
func (m *QueryVaultsPubkeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVaultsPubkeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVaultsPubkeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVaultsPubkeysResponse proto.InternalMessageInfo

func (m *QueryVaultsPubkeysResponse) GetAsgard() []*VaultInfo {
	if m != nil {
		return m.Asgard
	}
	return nil
}

func (m *QueryVaultsPubkeysResponse) GetInactive() []*VaultInfo {
	if m != nil {
		return m.Inactive
	}
	return nil
}

type VaultInfo struct {
	PubKey  string         `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key"`
	Routers []*VaultRouter `protobuf:"bytes,2,rep,name=routers,proto3" json:"routers"`
}

func (m *VaultInfo) Reset()         { *m = VaultInfo{} }
func (m *VaultInfo) String() string { return proto.CompactTextString(m) }
func (*VaultInfo) ProtoMessage()    {}
func (*VaultInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{6}
}
func (m *VaultInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultInfo.Merge(m, src)
}
func (m *VaultInfo) XXX_Size() int {
	return m.Size()
}
func (m *VaultInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VaultInfo proto.InternalMessageInfo

func (m *VaultInfo) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *VaultInfo) GetRouters() []*VaultRouter {
	if m != nil {
		return m.Routers
	}
	return nil
}

type VaultRouter struct {
	Chain  string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Router string `protobuf:"bytes,2,opt,name=router,proto3" json:"router,omitempty"`
}

func (m *VaultRouter) Reset()         { *m = VaultRouter{} }
func (m *VaultRouter) String() string { return proto.CompactTextString(m) }
func (*VaultRouter) ProtoMessage()    {}
func (*VaultRouter) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{7}
}
func (m *VaultRouter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultRouter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultRouter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultRouter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultRouter.Merge(m, src)
}
func (m *VaultRouter) XXX_Size() int {
	return m.Size()
}
func (m *VaultRouter) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultRouter.DiscardUnknown(m)
}

var xxx_messageInfo_VaultRouter proto.InternalMessageInfo

func (m *VaultRouter) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *VaultRouter) GetRouter() string {
	if m != nil {
		return m.Router
	}
	return ""
}

type VaultAddress struct {
	Chain   string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
}

func (m *VaultAddress) Reset()         { *m = VaultAddress{} }
func (m *VaultAddress) String() string { return proto.CompactTextString(m) }
func (*VaultAddress) ProtoMessage()    {}
func (*VaultAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_941f4868303210e7, []int{8}
}
func (m *VaultAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VaultAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VaultAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultAddress.Merge(m, src)
}
func (m *VaultAddress) XXX_Size() int {
	return m.Size()
}
func (m *VaultAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultAddress.DiscardUnknown(m)
}

var xxx_messageInfo_VaultAddress proto.InternalMessageInfo

func (m *VaultAddress) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *VaultAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterType((*QueryVaultRequest)(nil), "types.QueryVaultRequest")
	proto.RegisterType((*QueryVaultResponse)(nil), "types.QueryVaultResponse")
	proto.RegisterType((*QueryAsgardVaultsRequest)(nil), "types.QueryAsgardVaultsRequest")
	proto.RegisterType((*QueryAsgardVaultsResponse)(nil), "types.QueryAsgardVaultsResponse")
	proto.RegisterType((*QueryVaultsPubkeysRequest)(nil), "types.QueryVaultsPubkeysRequest")
	proto.RegisterType((*QueryVaultsPubkeysResponse)(nil), "types.QueryVaultsPubkeysResponse")
	proto.RegisterType((*VaultInfo)(nil), "types.VaultInfo")
	proto.RegisterType((*VaultRouter)(nil), "types.VaultRouter")
	proto.RegisterType((*VaultAddress)(nil), "types.VaultAddress")
}

func init() { proto.RegisterFile("types/query_vault.proto", fileDescriptor_941f4868303210e7) }

var fileDescriptor_941f4868303210e7 = []byte{
	// 698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x8e, 0x93, 0x26, 0x69, 0x26, 0x69, 0x69, 0xb7, 0x85, 0x6e, 0x7b, 0x88, 0x83, 0x05, 0x52,
	0x84, 0x44, 0x22, 0xb5, 0x48, 0x08, 0x90, 0x2a, 0x9a, 0x72, 0x00, 0xc1, 0x01, 0x4c, 0xd5, 0x03,
	0x1c, 0x22, 0x3b, 0xd9, 0x26, 0x56, 0x93, 0x5d, 0xd7, 0xbb, 0xae, 0x12, 0x1e, 0x02, 0xf1, 0x1c,
	0x3c, 0x49, 0x8f, 0x3d, 0x72, 0x0a, 0xa8, 0xbd, 0x85, 0x97, 0x40, 0xfb, 0xe3, 0xc4, 0x2d, 0x45,
	0x15, 0x27, 0xcf, 0x7c, 0xf3, 0xcd, 0xec, 0x78, 0xf6, 0xdb, 0x81, 0x0d, 0x31, 0x0e, 0x09, 0x6f,
	0x9e, 0xc4, 0x24, 0x1a, 0xb7, 0x4f, 0xbd, 0x78, 0x20, 0x1a, 0x61, 0xc4, 0x04, 0x43, 0x79, 0x15,
	0xd8, 0x5a, 0xef, 0xb1, 0x1e, 0x53, 0x48, 0x53, 0x5a, 0x3a, 0xb8, 0xb5, 0xd6, 0x61, 0xc3, 0x21,
	0xa3, 0x4d, 0xfd, 0xd1, 0xa0, 0xf3, 0x0a, 0x56, 0x3f, 0xc8, 0x32, 0x87, 0xb2, 0x8a, 0x4b, 0x4e,
	0x62, 0xc2, 0x05, 0xda, 0x80, 0x62, 0x18, 0xfb, 0xed, 0x63, 0x32, 0xc6, 0x56, 0xcd, 0xaa, 0x97,
	0xdc, 0x42, 0x18, 0xfb, 0x6f, 0xc9, 0x18, 0xdd, 0x83, 0x42, 0x9f, 0x04, 0xbd, 0xbe, 0xc0, 0x59,
	0x8d, 0x6b, 0xcf, 0xf9, 0xbd, 0x00, 0x28, 0x5d, 0x86, 0x87, 0x8c, 0x72, 0x82, 0xee, 0x43, 0xc5,
	0x1f, 0xb0, 0xce, 0x71, 0xdb, 0x24, 0xc9, 0x62, 0x39, 0xb7, 0xac, 0xb0, 0xd7, 0x0a, 0x4a, 0x1f,
	0x95, 0xbd, 0x72, 0x94, 0x0f, 0xf9, 0x0e, 0x0b, 0x28, 0xc7, 0xb9, 0x5a, 0xae, 0x5e, 0xde, 0xae,
	0x34, 0x4c, 0xdb, 0xfb, 0x2c, 0xa0, 0xad, 0xdd, 0xb3, 0x89, 0x9d, 0x99, 0x4e, 0x6c, 0x4d, 0xf9,
	0xfe, 0xd3, 0x7e, 0xdc, 0x0b, 0xc4, 0xc0, 0xf3, 0x25, 0xa9, 0x29, 0xfa, 0x2c, 0xea, 0xf4, 0xbd,
	0x80, 0x2a, 0x8b, 0xb2, 0x2e, 0x69, 0x9e, 0xee, 0x34, 0x53, 0xe9, 0xdc, 0xd5, 0x79, 0x08, 0xc1,
	0x82, 0x1c, 0x18, 0x5e, 0x50, 0x27, 0x2b, 0x1b, 0x39, 0x50, 0xe0, 0xc2, 0x13, 0x31, 0xc7, 0x79,
	0x89, 0xb6, 0x60, 0x3a, 0xb1, 0x0d, 0xe2, 0x9a, 0xaf, 0xfc, 0x2f, 0x6d, 0xb5, 0x79, 0x40, 0x3b,
	0x04, 0x17, 0xf4, 0x7f, 0x69, 0xec, 0xa3, 0x84, 0x50, 0x15, 0x60, 0x48, 0x86, 0x3e, 0x89, 0x78,
	0x3f, 0x08, 0x71, 0xb1, 0x96, 0xab, 0x97, 0xdc, 0x14, 0x22, 0x27, 0xa9, 0x7a, 0xe4, 0x78, 0x51,
	0xc5, 0x8c, 0x87, 0xea, 0xb0, 0x12, 0x50, 0x9f, 0xc5, 0xb4, 0xdb, 0x16, 0xa3, 0x76, 0x87, 0xc5,
	0x54, 0xe0, 0x92, 0x2a, 0xbf, 0x6c, 0xf0, 0x83, 0xd1, 0xbe, 0x44, 0xd1, 0x23, 0x58, 0x65, 0xb1,
	0xb8, 0x46, 0x05, 0x45, 0xbd, 0x93, 0x04, 0x12, 0xee, 0x53, 0xc0, 0x21, 0xa1, 0xdd, 0x80, 0xf6,
	0x24, 0x35, 0x7d, 0x27, 0x1c, 0x97, 0x6b, 0xb9, 0x7a, 0xce, 0xbd, 0x6b, 0xe2, 0x07, 0xa3, 0xd6,
	0xfc, 0x76, 0x38, 0x7a, 0x06, 0xc5, 0x88, 0xc5, 0x82, 0x44, 0x1c, 0x57, 0xd4, 0x3d, 0xa0, 0x86,
	0x92, 0x58, 0x43, 0x5f, 0xb4, 0x0a, 0xb5, 0xca, 0xd3, 0x89, 0x9d, 0xd0, 0xdc, 0xc4, 0x40, 0x2f,
	0xa1, 0xe4, 0x75, 0xbb, 0x11, 0xe1, 0x9c, 0x70, 0xbc, 0xa4, 0x92, 0xd7, 0xd2, 0xc9, 0x7b, 0x3a,
	0xd8, 0x5a, 0x9a, 0x4e, 0xec, 0x39, 0xd3, 0x9d, 0x9b, 0x72, 0x46, 0x47, 0x11, 0xfb, 0x42, 0x28,
	0x5e, 0xd6, 0x33, 0xd2, 0x9e, 0xb3, 0x0d, 0x58, 0x89, 0x6d, 0x8f, 0xf7, 0xbc, 0xa8, 0xab, 0x8a,
	0xf1, 0x44, 0xba, 0x73, 0x85, 0x5a, 0x57, 0x14, 0xfa, 0x19, 0x36, 0x6f, 0xc8, 0x31, 0x3a, 0xdd,
	0x85, 0x25, 0x4f, 0xe1, 0xfa, 0x31, 0x71, 0x6c, 0xa9, 0x76, 0x37, 0x4d, 0xbb, 0x7f, 0x2b, 0xdb,
	0xad, 0x78, 0xa9, 0x3a, 0xce, 0x8e, 0x29, 0xae, 0xdd, 0xf7, 0xb1, 0x7f, 0x4c, 0xc6, 0xb7, 0x76,
	0xf4, 0xd5, 0x82, 0xad, 0x9b, 0xb2, 0x4c, 0x4f, 0x4f, 0xa0, 0xa0, 0xcf, 0x30, 0xcd, 0xac, 0xa4,
	0x67, 0xf7, 0x86, 0x1e, 0x31, 0xad, 0x4c, 0xcd, 0x71, 0xcd, 0x17, 0x3d, 0x87, 0xc5, 0x80, 0x7a,
	0x1d, 0x11, 0x9c, 0x12, 0x9c, 0xfd, 0x47, 0x5e, 0x65, 0x3a, 0xb1, 0x67, 0x2c, 0x77, 0x66, 0x39,
	0x03, 0x28, 0xcd, 0x48, 0xe8, 0xc1, 0xb5, 0x15, 0xa0, 0x2f, 0xd9, 0x40, 0xb3, 0x47, 0x9a, 0x92,
	0x47, 0xf6, 0xff, 0xe4, 0xe1, 0xbc, 0x80, 0x72, 0x8a, 0x84, 0xd6, 0x21, 0xaf, 0x5e, 0x80, 0x19,
	0x92, 0x76, 0xe4, 0xec, 0x34, 0x3f, 0x59, 0x0e, 0xda, 0x73, 0x0e, 0xa1, 0x92, 0xd6, 0x10, 0xb2,
	0xaf, 0x64, 0xb7, 0x4a, 0x6a, 0x35, 0x48, 0x20, 0x29, 0xf4, 0x10, 0x8a, 0x46, 0x57, 0xba, 0x92,
	0x6e, 0xca, 0x40, 0x6e, 0x62, 0xb4, 0xde, 0x9d, 0x5d, 0x54, 0xad, 0xf3, 0x8b, 0xaa, 0xf5, 0xeb,
	0xa2, 0x6a, 0x7d, 0xbb, 0xac, 0x66, 0xce, 0x2f, 0xab, 0x99, 0x1f, 0x97, 0xd5, 0xcc, 0xa7, 0xed,
	0x5b, 0x17, 0xcc, 0x28, 0x8d, 0xcb, 0x21, 0xf8, 0x05, 0xb5, 0x62, 0x77, 0xfe, 0x04, 0x00, 0x00,
	0xff, 0xff, 0xdf, 0x8b, 0x94, 0xe5, 0xaf, 0x05, 0x00, 0x00,
}

func (m *QueryVaultRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVaultRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVaultRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Height) > 0 {
		i -= len(m.Height)
		copy(dAtA[i:], m.Height)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Height)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVaultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVaultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVaultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Frozen) > 0 {
		for iNdEx := len(m.Frozen) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Frozen[iNdEx])
			copy(dAtA[i:], m.Frozen[iNdEx])
			i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Frozen[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Addresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Routers) > 0 {
		for iNdEx := len(m.Routers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.PendingTxBlockHeights) > 0 {
		dAtA2 := make([]byte, len(m.PendingTxBlockHeights)*10)
		var j1 int
		for _, num1 := range m.PendingTxBlockHeights {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintQueryVault(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x5a
	}
	if m.OutboundTxCount != 0 {
		i = encodeVarintQueryVault(dAtA, i, uint64(m.OutboundTxCount))
		i--
		dAtA[i] = 0x50
	}
	if m.InboundTxCount != 0 {
		i = encodeVarintQueryVault(dAtA, i, uint64(m.InboundTxCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Chains[iNdEx])
			copy(dAtA[i:], m.Chains[iNdEx])
			i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Chains[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Membership) > 0 {
		for iNdEx := len(m.Membership) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Membership[iNdEx])
			copy(dAtA[i:], m.Membership[iNdEx])
			i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Membership[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.StatusSince != 0 {
		i = encodeVarintQueryVault(dAtA, i, uint64(m.StatusSince))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Coins) > 0 {
		for iNdEx := len(m.Coins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQueryVault(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryAsgardVaultsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAsgardVaultsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAsgardVaultsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Height) > 0 {
		i -= len(m.Height)
		copy(dAtA[i:], m.Height)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Height)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAsgardVaultsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAsgardVaultsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAsgardVaultsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AsgardVaults) > 0 {
		for iNdEx := len(m.AsgardVaults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AsgardVaults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryVaultsPubkeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVaultsPubkeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVaultsPubkeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Height) > 0 {
		i -= len(m.Height)
		copy(dAtA[i:], m.Height)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Height)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVaultsPubkeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVaultsPubkeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVaultsPubkeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Inactive) > 0 {
		for iNdEx := len(m.Inactive) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inactive[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Asgard) > 0 {
		for iNdEx := len(m.Asgard) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Asgard[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VaultInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Routers) > 0 {
		for iNdEx := len(m.Routers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQueryVault(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultRouter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultRouter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultRouter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Router) > 0 {
		i -= len(m.Router)
		copy(dAtA[i:], m.Router)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Router)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintQueryVault(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQueryVault(dAtA []byte, offset int, v uint64) int {
	offset -= sovQueryVault(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryVaultRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	l = len(m.Height)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	return n
}

func (m *QueryVaultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovQueryVault(uint64(m.BlockHeight))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	if len(m.Coins) > 0 {
		for _, e := range m.Coins {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	if m.StatusSince != 0 {
		n += 1 + sovQueryVault(uint64(m.StatusSince))
	}
	if len(m.Membership) > 0 {
		for _, s := range m.Membership {
			l = len(s)
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	if len(m.Chains) > 0 {
		for _, s := range m.Chains {
			l = len(s)
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	if m.InboundTxCount != 0 {
		n += 1 + sovQueryVault(uint64(m.InboundTxCount))
	}
	if m.OutboundTxCount != 0 {
		n += 1 + sovQueryVault(uint64(m.OutboundTxCount))
	}
	if len(m.PendingTxBlockHeights) > 0 {
		l = 0
		for _, e := range m.PendingTxBlockHeights {
			l += sovQueryVault(uint64(e))
		}
		n += 1 + sovQueryVault(uint64(l)) + l
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	if len(m.Frozen) > 0 {
		for _, s := range m.Frozen {
			l = len(s)
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	return n
}

func (m *QueryAsgardVaultsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Height)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	return n
}

func (m *QueryAsgardVaultsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AsgardVaults) > 0 {
		for _, e := range m.AsgardVaults {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	return n
}

func (m *QueryVaultsPubkeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Height)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	return n
}

func (m *QueryVaultsPubkeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Asgard) > 0 {
		for _, e := range m.Asgard {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	if len(m.Inactive) > 0 {
		for _, e := range m.Inactive {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	return n
}

func (m *VaultInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	if len(m.Routers) > 0 {
		for _, e := range m.Routers {
			l = e.Size()
			n += 1 + l + sovQueryVault(uint64(l))
		}
	}
	return n
}

func (m *VaultRouter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	return n
}

func (m *VaultAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQueryVault(uint64(l))
	}
	return n
}

func sovQueryVault(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQueryVault(x uint64) (n int) {
	return sovQueryVault(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryVaultRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVaultRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVaultRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Height = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVaultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVaultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVaultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coins = append(m.Coins, common.Coin{})
			if err := m.Coins[len(m.Coins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusSince", wireType)
			}
			m.StatusSince = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusSince |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Membership = append(m.Membership, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InboundTxCount", wireType)
			}
			m.InboundTxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InboundTxCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutboundTxCount", wireType)
			}
			m.OutboundTxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutboundTxCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQueryVault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PendingTxBlockHeights = append(m.PendingTxBlockHeights, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQueryVault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQueryVault
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQueryVault
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PendingTxBlockHeights) == 0 {
					m.PendingTxBlockHeights = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQueryVault
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PendingTxBlockHeights = append(m.PendingTxBlockHeights, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTxBlockHeights", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &VaultRouter{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, &VaultAddress{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frozen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frozen = append(m.Frozen, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAsgardVaultsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAsgardVaultsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAsgardVaultsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Height = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAsgardVaultsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAsgardVaultsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAsgardVaultsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsgardVaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsgardVaults = append(m.AsgardVaults, &QueryVaultResponse{})
			if err := m.AsgardVaults[len(m.AsgardVaults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVaultsPubkeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVaultsPubkeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVaultsPubkeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Height = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVaultsPubkeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVaultsPubkeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVaultsPubkeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asgard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asgard = append(m.Asgard, &VaultInfo{})
			if err := m.Asgard[len(m.Asgard)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inactive = append(m.Inactive, &VaultInfo{})
			if err := m.Inactive[len(m.Inactive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routers = append(m.Routers, &VaultRouter{})
			if err := m.Routers[len(m.Routers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultRouter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultRouter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultRouter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryVault
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQueryVault
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryVault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQueryVault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQueryVault(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQueryVault
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryVault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQueryVault
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQueryVault
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQueryVault
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQueryVault        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQueryVault          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQueryVault = fmt.Errorf("proto: unexpected end of group")
)
